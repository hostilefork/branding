1 
00:00:10,593 --> 00:00:14,410 
我们的下一位演讲者是Nenad Rakocevic 

2 
00:00:14,410 --> 00:00:17,039 
他给我们带来的是"什么是Red" 

3 
00:00:17,039 --> 00:00:22,496 
(掌声) 

4 
00:00:22,886 --> 00:00:27,767 
谢谢Gregg. 同时感谢所有 

5 
00:00:27,767 --> 00:00:31,908 
为我此次行程进行捐助 

6 
00:00:31,908 --> 00:00:33,728 
使我能够站在这里给大家做演示的人们。 

7 
00:00:33,728 --> 00:00:36,932 
我曾经做过很多关于Red的介绍 

8 
00:00:36,932 --> 00:00:43,013 
但是很多初次接触Red的人仍然跑来问我 

9 
00:00:43,013 --> 00:00:45,517 
这样一个简单的问题： 

10 
00:00:45,517 --> 00:00:47,400 
究竟“什么是Red呢？” 

11 
00:00:47,400 --> 00:00:50,166 
因为这个项目涉及的范围非常广泛， 

12 
00:00:50,166 --> 00:00:51,741 
这一点我可以理解。 

13 
00:00:51,741 --> 00:00:54,042 
所以，我会尽量在这次介绍中给大家 

14 
00:00:54,042 --> 00:00:58,673 
做一个全面的展示。 

15 
00:00:58,673 --> 00:01:02,522 
那么我们从问题的综述说起。 

16 
00:01:02,522 --> 00:01:06,517 
这可不是一张大脑细胞的图片， 

17 
00:01:06,517 --> 00:01:10,566 
而是一个目前已知的宇宙的 

18 
00:01:10,566 --> 00:01:12,772 
计算机模型图。 

19 
00:01:12,772 --> 00:01:14,740 
这可以让大家对这个问题涉及的范围之广 

20 
00:01:14,740 --> 00:01:18,230 
有一个直观的印象（笑声） 

21 
00:01:18,230 --> 00:01:20,329 
这实际上也为 

22 
00:01:20,329 --> 00:01:23,036 
我原本是打算做什么的提供了线索。 

23 
00:01:23,036 --> 00:01:26,011 
因为我以前学的是天体物理学 

24 
00:01:26,011 --> 00:01:30,570 
后来才转到了计算机科学专业。 

25 
00:01:30,570 --> 00:01:34,589 
我对于计算机世界的认识是 

26 
00:01:34,589 --> 00:01:38,792 
即便是到了今天，我们还在用着一些非常原始的 

27 
00:01:38,792 --> 00:01:41,018 
工具和技术。 

28 
00:01:41,018 --> 00:01:44,653 
所以在软件领域我们其实与这两个人 

29 
00:01:44,653 --> 00:01:46,357 
没太多差别。 

30 
00:01:46,357 --> 00:01:49,283 
我们仍然在使用一种非常原始的方法做软件开发， 

31 
00:01:49,283 --> 00:01:51,928 
因为我们不断地重复发明轮子 

32 
00:01:51,928 --> 00:01:54,513 
和犯相同的错误， 

33 
00:01:54,513 --> 00:01:56,041 
一次又一次。 

34 
00:01:56,041 --> 00:01:58,892 
相信连机器人见了都会发笑。 

35 
00:01:58,902 --> 00:02:02,541 
至少我希望如此 :-) （笑声） 

36 
00:02:02,541 --> 00:02:08,308 
现在回到正题上来 

37 
00:02:08,308 --> 00:02:12,563 
实际上，世界上已经有相当多的编程语言了 

38 
00:02:12,563 --> 00:02:14,927 
这是维基百科上的编程语言列表 

39 
00:02:14,927 --> 00:02:18,596 
以A开头的部分 

40 
00:02:18,596 --> 00:02:23,107 
甚至就连这部分一页都没能放得下。 

41 
00:02:23,107 --> 00:02:24,802 
所以说编程语言有成千上万 

42 
00:02:24,802 --> 00:02:27,188 
一点都不夸张。 

43 
00:02:27,188 --> 00:02:29,588 
在这里你会发现有一些语言 

44 
00:02:29,588 --> 00:02:32,839 
是在Amiga发明的 

45 
00:02:32,839 --> 00:02:34,465 
这是著名的"Amiga E"语言， 

46 
00:02:34,465 --> 00:02:37,288 
AMOS语言是一个非常聪明的法国人发明的， 

47 
00:02:37,288 --> 00:02:42,988 
他就是François Lionet。 

48 
00:02:42,988 --> 00:02:46,500 
AMOS BASIC可以看做是一种领域特定语言（DSL） 

49 
00:02:46,500 --> 00:02:50,240 
我曾在20多年前 

50 
00:02:50,240 --> 00:02:52,899 
使用过它。 

51 
00:02:52,899 --> 00:02:56,445 
这种领域编程语言(DSL)的用途是制作电影动画... 

52 
00:02:56,445 --> 00:03:00,268 
...它可以编译成本地代码。 

53 
00:03:00,268 --> 00:03:04,439 
AMOS整套的解释器、编译器和集成开发环境 

54 
00:03:04,439 --> 00:03:10,624 
都是用汇编语言编写的。 

55 
00:03:10,624 --> 00:03:15,262 
这位仁兄给了我相当大的启发。 

56 
00:03:15,262 --> 00:03:19,448 
尽管已经有了这么多的编程语言 

57 
00:03:19,448 --> 00:03:22,985 
和工具，但我们还是在不断寻找更新、 

58 
00:03:22,985 --> 00:03:25,197 
更好的方法。 

59 
00:03:25,197 --> 00:03:28,035 
软件领域经常遇到的问题 

60 
00:03:28,035 --> 00:03:31,225 
都已经是老生常谈了。 

61 
00:03:31,225 --> 00:03:34,345 
但是我们仍然在不断地与之相遇。 

62 
00:03:34,345 --> 00:03:37,582 
比如日益增加的软件复杂度...软件膨胀... 

63 
00:03:37,582 --> 00:03:40,334 
当然我说的不是Java(笑声) 

64 
00:03:40,334 --> 00:03:42,225 
不要联想到Java :-P 

65 
00:03:42,225 --> 00:03:44,769 
再比如运行效率差...以及黑盒子， 

66 
00:03:44,769 --> 00:03:46,554 
这一点可以以闭源软件为代表， 

67 
00:03:46,554 --> 00:03:49,598 
当你遇到的bug超出了你所能掌控的范围时， 

68 
00:03:49,598 --> 00:03:53,461 
这通常会是一个大问题。 

69 
00:03:53,461 --> 00:03:57,872 
所以与其花费时间在这些问题上碰壁， 

70 
00:03:57,872 --> 00:04:00,348 
不如把编程变成一件快乐的事情。 

71 
00:04:00,348 --> 00:04:02,665 
因为编程本来就应该是充满乐趣的一件事情。 

72 
00:04:02,665 --> 00:04:05,265 
这是我们在使用计算机进行工作时 

73 
00:04:05,265 --> 00:04:07,852 
应该有的精神状态。 

74 
00:04:07,852 --> 00:04:11,400 
就像在那些编程*仅仅*代表一种乐趣 

75 
00:04:11,400 --> 00:04:13,440 
的年代一样。 

76 
00:04:13,440 --> 00:04:16,441 
从那时起，即上个世纪八十年代， 

77 
00:04:16,441 --> 00:04:19,490 
发生了很多技术变革。 

78 
00:04:19,490 --> 00:04:21,716 
现今，我认为在计算机技术领域 

79 
00:04:21,716 --> 00:04:25,710 
有两个非常重要的变化 

80 
00:04:25,710 --> 00:04:28,281 
第一个是计算机的计算能力增强的途径 

81 
00:04:28,281 --> 00:04:31,224 
由提升CPU的频率 

82 
00:04:31,224 --> 00:04:34,934 
开始转变为增加CPU核数。 

83 
00:04:34,934 --> 00:04:39,320 
这个变化会对编程工具产生深远影响。 

84 
00:04:39,320 --> 00:04:44,062 
另一个重要的变化是，市场的重心正在逐渐 

85 
00:04:44,062 --> 00:04:46,772 
向移动端转移。 

86 
00:04:46,772 --> 00:04:49,987 
市场在飞速发展， 

87 
00:04:49,987 --> 00:04:52,947 
编程工具也应该顺应潮流而变。 

88 
00:04:52,947 --> 00:04:56,540 
然而尽管发生了这些变革， 

89 
00:04:56,540 --> 00:04:59,593 
实际情况是，我们仍然在使用一些非常古老的工具。 

90 
00:04:59,593 --> 00:05:03,677 
我仅就五个最流行的语言来说一说这个问题 

91 
00:05:03,677 --> 00:05:07,004 
这些语言摘自著名的 

92 
00:05:07,004 --> 00:05:09,111 
Tiobe编程语言排行榜。 

93 
00:05:09,111 --> 00:05:12,114 
是的，C语言仍然是最重要的一门语言， 

94 
00:05:12,114 --> 00:05:14,672 
迄今为止它已经被广泛使用了将近40年。 

95 
00:05:14,672 --> 00:05:18,748 
在计算机世界里，这可是一段相当长的时间！ 

96 
00:05:18,748 --> 00:05:22,984 
很显然C语言绝对不是为了解决 

97 
00:05:22,984 --> 00:05:25,417 
现代的计算需求而被发明出来的。 

98 
00:05:25,417 --> 00:05:27,973 
如果你再看看其他语言 

99 
00:05:27,973 --> 00:05:30,784 
也都大同小异。 

100 
00:05:30,784 --> 00:05:33,205 
所幸的是，有这么一些人... 

101 
00:05:33,205 --> 00:05:36,211 
...一些非凡之士意识到了这个问题， 

102 
00:05:36,211 --> 00:05:41,981 
并且给出了问题的答案。 

103 
00:05:41,981 --> 00:05:45,129 
比如Carl（向Carl示意） 

104 
00:05:45,129 --> 00:05:47,309 
他发明了Rebol...这门了不起的编程语言， 

105 
00:05:47,309 --> 00:05:50,383 
可以说是过去20年中编程领域 

106 
00:05:50,383 --> 00:05:55,080 
最伟大的发明之一。 

107 
00:05:55,080 --> 00:05:57,875 
在很多领域，Rebol都表现不错， 

108 
00:05:57,875 --> 00:06:00,598 
或者说非常棒。 

109 
00:06:00,598 --> 00:06:01,978 
*但是，并不是全部领域* 

110 
00:06:01,978 --> 00:06:05,352 
我想向Carl展示一些东西... 

111 
00:06:05,352 --> 00:06:08,556 
...或许他还没有见过？ 

112 
00:06:08,556 --> 00:06:12,917 
直到最近，Rebol取得的最好成就， 

113 
00:06:12,917 --> 00:06:17,277 
只是Rebol社区的人们在称赞它 

114 
00:06:17,277 --> 00:06:20,004 
并努力向他人解释Rebol是一门多么 

115 
00:06:20,004 --> 00:06:23,947 
高效，表达能力多么强的编程语言。 

116 
00:06:23,947 --> 00:06:28,282 
近期有一项科学研究试图衡量 

117 
00:06:28,282 --> 00:06:32,133 
各门语言的表达能力。 

118 
00:06:32,133 --> 00:06:37,597 
这是他们的研究结果。令人吃惊的是，Rebol居然排名第3。 

119 
00:06:37,597 --> 00:06:41,516 
实际情况是，排名第一和第二位的是两门领域特定语言（DSL） 

120 
00:06:41,516 --> 00:06:44,526 
猜猜是谁排名第一？（笑声） 

121 
00:06:44,526 --> 00:06:49,040 
其实这不过是验证了我们 

122 
00:06:49,040 --> 00:06:51,141 
早就知道的事情： 

123 
00:06:51,141 --> 00:06:53,307 
Rebol是一门生产效率极高的语言， 

124 
00:06:53,307 --> 00:06:55,935 
只不过现在有了明证。（笑声） 

125 
00:06:55,935 --> 00:07:00,715 
但是Red想要做的是超越Rebol。 

126 
00:07:00,715 --> 00:07:03,002 
主要是在实现方式方面 

127 
00:07:03,002 --> 00:07:06,519 
而不是语法或语义方面。 

128 
00:07:06,519 --> 00:07:10,458 
更多的是在工具链、实现方式 

129 
00:07:10,458 --> 00:07:13,065 
和延伸方面。 

130 
00:07:13,065 --> 00:07:16,160 
那么究竟什么是Red呢？ 

131 
00:07:16,160 --> 00:07:17,653 
Red是一门我称之为 

132 
00:07:17,653 --> 00:07:19,212 
*全栈式编程语言*的语言。 

133 
00:07:19,212 --> 00:07:22,317 
或许大家都听说过全栈工程师吧？ 

134 
00:07:22,317 --> 00:07:25,796 
现在又来了一门全栈式编程语言。 

135 
00:07:25,796 --> 00:07:28,995 
从某种意义上说它的主要特色是 

136 
00:07:28,995 --> 00:07:31,188 
这是一门真正意义上的 

137 
00:07:31,188 --> 00:07:33,287 
通用编程语言。 

138 
00:07:33,287 --> 00:07:35,182 
有相当多的编程语言 

139 
00:07:35,182 --> 00:07:39,288 
将自己*标榜*为通用编程语言... 

140 
00:07:39,288 --> 00:07:43,358 
...但是它们触及的范围都没有Red语言来的广泛。 

141 
00:07:43,358 --> 00:07:47,121 
Red语言的另一个特色是 

142 
00:07:47,121 --> 00:07:49,413 
它只有一个独立的工具链 

143 
00:07:49,413 --> 00:07:52,050 
这样的话我们就可以不依赖 

144 
00:07:52,050 --> 00:07:56,488 
经典的C语言工具链这样的标配了，我们有自己的工具链。 

145 
00:07:56,488 --> 00:07:59,648 
Red的再一个重要方面是 

146 
00:07:59,648 --> 00:08:01,421 
它是*自由*的。 

147 
00:08:01,421 --> 00:08:03,695 
由于我开发Red语言的初始动机是 

148 
00:08:03,695 --> 00:08:07,334 
突破各种限制 

149 
00:08:07,334 --> 00:08:08,995 
或者限度， 

150 
00:08:08,995 --> 00:08:14,230 
我希望使用Red的人们也有相同的感受。 

151 
00:08:14,230 --> 00:08:18,165 
Red的简单易用*受益于Rebol*... 

152 
00:08:18,165 --> 00:08:23,770 
...但是Red不存在任何局限性。 

153 
00:08:23,770 --> 00:08:26,374 
我们着眼于方方面面的需求 

154 
00:08:26,374 --> 00:08:28,138 
这样它就可以 

155 
00:08:28,138 --> 00:08:33,154 
被部署、移植到任何我们想要的平台。 

156 
00:08:33,154 --> 00:08:35,799 
另外，在编程中非常重要的一点： 

157 
00:08:35,799 --> 00:08:39,061 
对自己所使用的工具要有掌控感。 

158 
00:08:39,061 --> 00:08:42,836 
你会经常用到一些非常强大 

159 
00:08:42,836 --> 00:08:44,878 
但是不能自由掌控的工具，因为 

160 
00:08:44,878 --> 00:08:47,250 
你不了解它的内部是怎么运行的。 

161 
00:08:47,250 --> 00:08:48,730 
当然也通常因为它们是黑盒子。 

162 
00:08:48,730 --> 00:08:52,495 
或者是它们位于软件的一大堆层级当中 

163 
00:08:52,495 --> 00:08:56,225 
以至于你不能了解 

164 
00:08:56,225 --> 00:08:57,921 
内部究竟是怎么运行的。 

165 
00:08:57,921 --> 00:09:02,394 
还有最后一点，非常重要的一点 :-) 

166 
00:09:02,394 --> 00:09:04,521 
就是*快乐*。是的，我们想要找回编程的快乐。 

167 
00:09:04,521 --> 00:09:08,808 
一些用过Red 

168 
00:09:08,808 --> 00:09:11,465 
或者Red/System的朋友在成功编译和运行 

169 
00:09:11,465 --> 00:09:14,262 
他们的第一个程序之后 

170 
00:09:14,262 --> 00:09:16,175 
跑来告诉我说： 

171 
00:09:16,175 --> 00:09:17,367 
“非常好玩，棒极了！” 

172 
00:09:17,367 --> 00:09:21,281 
“我只是试了一下，居然运行起来了，太棒了。” 

173 
00:09:21,281 --> 00:09:25,132 
人们找到了那种我之前所说的 

174 
00:09:25,132 --> 00:09:27,620 
来自于上个世纪80年代的感觉， 

175 
00:09:27,620 --> 00:09:29,347 
那种你真的可以对你的编程工具 

176 
00:09:29,347 --> 00:09:31,121 
完全掌控的感觉。 

177 
00:09:31,121 --> 00:09:34,387 
接下来我会说一说我所说的 

178 
00:09:34,387 --> 00:09:36,782 
“全栈式编程语言”与 

179 
00:09:36,782 --> 00:09:40,455 
“真正意义上的通用编程语言”是什么。 

180 
00:09:40,455 --> 00:09:42,096 
我画了这张图： 

181 
00:09:42,096 --> 00:09:43,414 
部分主流编程语言的 

182 
00:09:43,414 --> 00:09:46,570 
“领域适用范围图”。 

183 
00:09:46,570 --> 00:09:49,393 
例如，汇编语言用来编写驱动程序， 

184 
00:09:49,393 --> 00:09:52,019 
属于非常低级的代码。 

185 
00:09:52,019 --> 00:09:54,895 
可以看到Java的能力局限于 

186 
00:09:54,895 --> 00:09:58,084 
解决各种抽象层的问题。 

187 
00:09:58,084 --> 00:10:00,607 
Ruby的适用范围很广; 

188 
00:10:00,607 --> 00:10:02,989 
但还没有低到操作系统层级吧？ 

189 
00:10:02,989 --> 00:10:05,598 
我不知道通过Ruby接口来 

190 
00:10:05,598 --> 00:10:09,888 
调用操作系统API是好还是坏。 

191 
00:10:09,888 --> 00:10:13,324 
Rebol的适用范围相当广泛。 

192 
00:10:13,324 --> 00:10:16,880 
Rascal是一种非常特别的编程语言， 

193 
00:10:16,880 --> 00:10:19,540 
它实际上是一种领域特定语言（DSL）， 

194 
00:10:19,540 --> 00:10:23,246 
用来编写别的领域特定语言（DSL）。 

195 
00:10:23,246 --> 00:10:26,522 
因此它的适用范围在meta-DSL层。 

196 
00:10:26,522 --> 00:10:30,356 
那么Red的适用范围呢？ 

197 
00:10:30,356 --> 00:10:33,954 
Red的目标是满足所有这些需求， 

198 
00:10:33,954 --> 00:10:37,272 
从底层到顶层， 

199 
00:10:37,272 --> 00:10:40,596 
因为我不想依赖另外一种工具。 

200 
00:10:40,596 --> 00:10:43,056 
我想让Red语言 

201 
00:10:43,056 --> 00:10:45,913 
不依赖别的任何东西 

202 
00:10:45,913 --> 00:10:48,272 
就能满足所有这些需求。 

203 
00:10:48,272 --> 00:10:51,236 
有人会说 

204 
00:10:51,236 --> 00:10:53,307 
发明一门适用范围如此之广的语言 

205 
00:10:53,307 --> 00:10:56,058 
是不可能的。 

206 
00:10:56,058 --> 00:10:58,201 
他很可能是对的。 

207 
00:10:58,201 --> 00:11:00,771 
但是Red不一样，它有自己的王牌。 

208 
00:11:00,771 --> 00:11:04,418 
Red/System语言会负责较低的层级， 

209 
00:11:04,418 --> 00:11:06,604 
Red语言则负责较高的层级。 

210 
00:11:06,604 --> 00:11:10,037 
二者可以相互协作， 

211 
00:11:10,037 --> 00:11:11,702 
配合无间。 

212 
00:11:11,702 --> 00:11:15,114 
Red/System实际上是Red的一种方言。 

213 
00:11:15,114 --> 00:11:17,191 
既可以单独使用， 

214 
00:11:17,191 --> 00:11:20,112 
也可以直接嵌入在Red代码中使用。 

215 
00:11:20,112 --> 00:11:25,446 
下面再看一看所支持的系统平台。 

216 
00:11:25,446 --> 00:11:26,597 
首先是桌面系统， 

217 
00:11:26,597 --> 00:11:30,755 
我们支持三大主流操作系统。 

218 
00:11:30,755 --> 00:11:34,424 
同时也支持其他一些操作系统 

219 
00:11:34,424 --> 00:11:36,693 
比如Syllable。 

220 
00:11:36,693 --> 00:11:38,829 
我们希望能够支持FreeBSD, 

221 
00:11:38,829 --> 00:11:41,350 
但是由于遇到了一些底层的问题 

222 
00:11:41,350 --> 00:11:45,053 
同时缺少FreeBSD专家 

223 
00:11:45,053 --> 00:11:48,456 
来解决这些问题，因此目前暂时被搁置了。 

224 
00:11:48,456 --> 00:11:52,454 
但如果可能的话，我们会尽快将Red移植到 

225 
00:11:52,454 --> 00:11:54,855 
FreeBSD上。 

226 
00:11:54,855 --> 00:11:57,687 
我们也要支持 

227 
00:11:57,687 --> 00:12:00,774 
嵌入式平台市场，是从Android开始着手的， 

228 
00:12:00,774 --> 00:12:02,771 
目前已经可以支持Android了。 

229 
00:12:02,771 --> 00:12:04,787 
下一个将会是iOS。 

230 
00:12:04,787 --> 00:12:07,905 
Red目前已经可以运行在 

231 
00:12:07,905 --> 00:12:10,367 
日渐流行的Raspberry Pi了。 

232 
00:12:10,367 --> 00:12:14,720 
我猜Bo可能会在明天给大家 

233 
00:12:14,720 --> 00:12:17,929 
做一些演示。 

234 
00:12:17,929 --> 00:12:22,868 
我们还有一个Arduino上的实验性质的移植版本 

235 
00:12:22,868 --> 00:12:27,030 
是为8位的AVR做的。 

236 
00:12:27,030 --> 00:12:30,044 
当然目前只是实验性质的， 

237 
00:12:30,044 --> 00:12:32,895 
因为不久其他一些电路板上的版本就会出现， 

238 
00:12:32,895 --> 00:12:36,014 
像是32位的或者Raspberry Pi， 

239 
00:12:36,014 --> 00:12:41,790 
所以8位的并不是当务之急。 

240 
00:12:41,790 --> 00:12:45,320 
我们还会支持虚拟机。 

241 
00:12:45,320 --> 00:12:49,753 
我们想要连通.NET平台 

242 
00:12:49,753 --> 00:12:53,139 
JVM平台以及Javascript平台。 

243 
00:12:53,139 --> 00:12:55,602 
实现这一点 

244 
00:12:55,602 --> 00:12:56,467 
一般有两种方法。 

245 
00:12:56,467 --> 00:13:00,940 
一种方法是使用桥接器，保持Red原样不动 

246 
00:13:00,940 --> 00:13:06,438 
使用桥接的方式来访问这些虚拟机。 

247 
00:13:06,438 --> 00:13:08,746 
另一种方法是为Red和Red/System 

248 
00:13:08,746 --> 00:13:11,146 
开发新的后端 

249 
00:13:11,146 --> 00:13:13,710 
使之能够直接编译成这些虚拟机的 

250 
00:13:13,710 --> 00:13:15,817 
字节码。 

251 
00:13:15,817 --> 00:13:17,905 
所以这样我们有两种选择。 

252 
00:13:17,905 --> 00:13:21,645 
我们是从为JVM创建桥接器开始着手的。 

253 
00:13:21,645 --> 00:13:26,405 
我们会为不同的虚拟机选择 

254 
00:13:26,405 --> 00:13:30,067 
最适合的方案。 

255 
00:13:30,067 --> 00:13:33,188 
所以现在是采用桥接的方式连接JVM虚拟机。 

256 
00:13:33,188 --> 00:13:37,997 
但对于JavaScript可能会采用直接编译的方式。 

257 
00:13:37,997 --> 00:13:41,551 
现在我们已经有了asm.js，这样我们就有了 

258 
00:13:41,551 --> 00:13:45,325 
一个相当吸引人的平台来支持。 

259 
00:13:45,325 --> 00:13:47,584 
我相信Red和Red/System能够 

260 
00:13:47,584 --> 00:13:50,755 
在这上面运行很快。 

261 
00:13:50,755 --> 00:13:53,753 
Red工作机制中更加务实的一面是， 

262 
00:13:53,753 --> 00:13:57,242 
只需要一个可执行文件， 

263 
00:13:57,242 --> 00:14:01,118 
将其下载下来，所有的特性就都具备了。 

264 
00:14:01,118 --> 00:14:04,756 
你可以直接从内存中执行Red脚本， 

265 
00:14:04,756 --> 00:14:08,124 
可以把它编译成一个可执行文件。 

266 
00:14:08,124 --> 00:14:12,805 
还可以进行交叉编译... 

267 
00:14:12,805 --> 00:14:15,324 
稍后我们再详细说这个特性。 

268 
00:14:15,324 --> 00:14:19,071 
你也可以直接编译Red/System脚本， 

269 
00:14:19,071 --> 00:14:22,291 
如果你不想使用Red 

270 
00:14:22,291 --> 00:14:26,063 
而是想编写一个底层应用程序的话。 

271 
00:14:26,063 --> 00:14:29,955 
你还可以编译共享库 

272 
00:14:29,955 --> 00:14:32,948 
这样就为Red的延伸打开了方便之门， 

273 
00:14:32,948 --> 00:14:36,582 
即可以将它以插件的形式安装到任何我们想要安装的地方。 

274 
00:14:36,582 --> 00:14:39,954 
你还可以启动Red的控制台模式 

275 
00:14:39,954 --> 00:14:42,206 
这样我们就拥有了一个Red控制台。 

276 
00:14:42,206 --> 00:14:45,499 
关于交叉编译...其实现阶段就可以进行交叉编译， 

277 
00:14:45,499 --> 00:14:49,442 
从任一系统编译其他任何一个系统所需要的文件。 

278 
00:14:49,442 --> 00:14:52,731 
实际上它可以从任一运行着Rebol的平台 

279 
00:14:52,731 --> 00:14:56,113 
编译出其他任何平台的可执行文件。 

280 
00:14:56,113 --> 00:15:00,808 
做到这一点不需要一份HOWTO文档 

281 
00:15:00,808 --> 00:15:02,363 
也不需要一份教程 

282 
00:15:02,363 --> 00:15:04,788 
更不需要去网络上进行搜索 

283 
00:15:04,788 --> 00:15:07,182 
该怎么实现。 

284 
00:15:07,182 --> 00:15:10,293 
你只需要添加一个“-t”命令和相应的目标ID就可以了， 

285 
00:15:10,293 --> 00:15:11,777 
就这些。 

286 
00:15:11,777 --> 00:15:16,750 
目标ID只是配置文件中的一个条目， 

287 
00:15:16,750 --> 00:15:21,988 
这个配置文件是一种Red的方言，在其中我们只是列出了 

288 
00:15:21,988 --> 00:15:26,132 
目标平台的一些可选项。 

289 
00:15:26,132 --> 00:15:31,110 
到目前为止，我们共支持8个目标平台 

290 
00:15:31,110 --> 00:15:33,602 
这样我们可以在任一平台上交叉编译其他平台需要的文件， 

291 
00:15:33,602 --> 00:15:35,828 
只要源平台上 

292 
00:15:35,828 --> 00:15:40,124 
运行着Rebol。 

293 
00:15:40,124 --> 00:15:41,557 
可以看到我们目前主要支持 

294 
00:15:41,557 --> 00:15:45,594 
基于X86和ARM的平台。 

295 
00:15:45,594 --> 00:15:49,412 
更深入看一看会发现我们的工具链 

296 
00:15:49,412 --> 00:15:51,796 
分为几个部分。 

297 
00:15:51,796 --> 00:15:54,506 
有编译器和链接器这对经典组合。 

298 
00:15:54,506 --> 00:16:01,832 
编译器主要支持 

299 
00:16:01,832 --> 00:16:07,115 
 x86和ARM这两种后端。 

300 
00:16:07,115 --> 00:16:11,919 
但是我们打算对其进行扩展以支持ARMv7 

301 
00:16:11,919 --> 00:16:17,236 
的Thumb模式和64位的平台。 

302 
00:16:17,236 --> 00:16:22,287 
我们以后还会支持虚拟机后端， 

303 
00:16:22,287 --> 00:16:26,207 
例如Javascript、JVM字节码，Dex指的是Dalvik虚拟机的dex档案， 

304 
00:16:26,207 --> 00:16:30,153 
是Android平台上的JVM， 

305 
00:16:30,153 --> 00:16:34,462 
MSIL指的是.NET平台上的 

306 
00:16:34,462 --> 00:16:37,043 
MSIL中间语言代码。 

307 
00:16:37,043 --> 00:16:39,737 
这样的话链接器就可以支持所有主流的文件格式了。 

308 
00:16:39,737 --> 00:16:43,532 
我们后面将会对它进行扩展使其能够支持静态链接库。 

309 
00:16:43,532 --> 00:16:46,418 
那时你就可以把Red程序编译成 

310 
00:16:46,418 --> 00:16:51,578 
静态链接库，之后与其他外部工具链—— 

311 
00:16:51,578 --> 00:16:55,233 
比如使用C语言编译的——进行链接。 

312 
00:16:55,233 --> 00:16:59,655 
这是另外一条延伸Red语言的途径， 

313 
00:16:59,655 --> 00:17:02,448 
允许它 

314 
00:17:02,448 --> 00:17:04,962 
和第三方语言或应用程序构成的工具链一起使用。 

315 
00:17:04,962 --> 00:17:09,242 
我们甚至深入到了内核层级 

316 
00:17:09,242 --> 00:17:14,305 
这样就可以直接使用Red语言 

317 
00:17:14,305 --> 00:17:19,234 
开发内核驱动程序， 

318 
00:17:19,234 --> 00:17:21,787 
甚至是完整的操作系统。 

319 
00:17:21,787 --> 00:17:24,199 
到目前为止已经可以支持Windows内核驱动程序的开发， 

320 
00:17:24,199 --> 00:17:27,504 
虽然是实验性的，但是是可以使用的。 

321 
00:17:27,504 --> 00:17:31,980 
如果在座的各位中有谁从事驱动程序开发 

322 
00:17:31,980 --> 00:17:34,213 
可以享用一下。 :-P 

323 
00:17:34,213 --> 00:17:37,458 
最后一点，据我所知， 

324 
00:17:37,458 --> 00:17:40,247 
有一样东西在经典的C语言工具链中是没有的： 

325 
00:17:40,247 --> 00:17:42,530 
我们将提供一个打包工具， 

326 
00:17:42,530 --> 00:17:46,044 
这个目前还没有实现，但是很快就会有。 

327 
00:17:46,044 --> 00:17:51,589 
我们最先从Android的APK后端做起。 

328 
00:17:51,589 --> 00:17:54,697 
这个工具主要用来 

329 
00:17:54,697 --> 00:17:58,850 
将一些文件打包 

330 
00:17:58,850 --> 00:18:03,445 
生成目标平台所需要的格式文件。 

331 
00:18:03,445 --> 00:18:06,426 
我们会支持Android,也会支持iOS， 

332 
00:18:06,426 --> 00:18:08,997 
其实这样一个打包器也可以用来 

333 
00:18:08,997 --> 00:18:13,409 
打包web应用。 

334 
00:18:13,409 --> 00:18:17,371 
就像Java中的.WAR包一样 

335 
00:18:17,371 --> 00:18:20,196 
WAR包有提供了很多吸引人的功能， 

336 
00:18:20,196 --> 00:18:23,489 
比如简化应用的部署过程， 

337 
00:18:23,489 --> 00:18:25,276 
进行版本管理， 

338 
00:18:25,276 --> 00:18:27,050 
或者对部署进行回滚， 

339 
00:18:27,050 --> 00:18:29,342 
这些都是相当有用的。 

340 
00:18:29,342 --> 00:18:31,027 
关于工具链的另外一点说明是 

341 
00:18:31,027 --> 00:18:32,544 
它目前处于自举阶段， 

342 
00:18:32,544 --> 00:18:36,774 
代码是用Rebol 2开发的， 

343 
00:18:36,774 --> 00:18:40,686 
迄今为止已经这么做有两年了。 

344 
00:18:40,686 --> 00:18:46,907 
不过最终形态的Red将会拥有一个JIT编译器， 

345 
00:18:46,907 --> 00:18:50,717 
而实现JIT编译器需要实现自托管。 

346 
00:18:50,717 --> 00:18:54,347 
因此我们需要使用Red语言自身来重写Red。 

347 
00:18:54,347 --> 00:18:58,587 
这是开发一个适合的JIT编译器的唯一途径。 

348 
00:18:58,587 --> 00:19:03,543 
我们很可能会在下一年就做这些工作。 

349 
00:19:03,543 --> 00:19:07,550 
我做了很多介绍Red语言自身特性的幻灯片 

350 
00:19:07,550 --> 00:19:10,796 
但是今天不会涉及太多细节的东西， 

351 
00:19:10,796 --> 00:19:13,394 
因为这需要很多时间。 

352 
00:19:13,394 --> 00:19:18,018 
理解Red语言的第一个要点是 

353 
00:19:18,018 --> 00:19:21,098 
它非常接近Rebol语言。 

354 
00:19:21,098 --> 00:19:26,585 
它具有Rebol的主要的特征， 

355 
00:19:26,585 --> 00:19:31,588 
比如可定义作用域（definitional scoping）和动态绑定。 

356 
00:19:31,588 --> 00:19:37,178 
你在使用Red进行开发时可以 

357 
00:19:37,178 --> 00:19:40,106 
选择你想使用的任何范式。 

358 
00:19:40,106 --> 00:19:43,031 
我非常喜欢Gabriele (Santilli)所说的 

359 
00:19:43,031 --> 00:19:46,673 
“范式中立”这一表述， 

360 
00:19:46,673 --> 00:19:50,013 
它准确描述了 

361 
00:19:50,013 --> 00:19:53,878 
不局限于任何一种范式的能力。 

362 
00:19:55,318 --> 00:19:59,298 
Red和Rebol之间的一个区别是 

363 
00:19:59,298 --> 00:20:05,376 
在Red中你可以选择性地指定函数中局部变量的类型， 

364 
00:20:05,376 --> 00:20:09,756 
同时还可以指定 

365 
00:20:09,756 --> 00:20:12,147 
返回值的类型。 

366 
00:20:12,147 --> 00:20:17,048 
在Rebol中，这样做意义不大， 

367 
00:20:17,048 --> 00:20:25,102 
因为它只是是个解释器，这样做没有必要。 

368 
00:20:25,102 --> 00:20:27,874 
但是对于编译器就不一样了，是非常有必要的。 

369 
00:20:27,874 --> 00:20:33,604 
因为在函数中指定这些数据的类型 

370 
00:20:33,604 --> 00:20:37,791 
可以使编译器产生 

371 
00:20:37,791 --> 00:20:43,616 
比没有指定时更加明确、快速和 

372 
00:20:43,616 --> 00:20:46,818 
高效率的代码。 

373 
00:20:47,728 --> 00:20:53,186 
在Red中数据类型是可以选择性地指定的。指定或者不指定都可以， 

374 
00:20:53,186 --> 00:20:56,989 
完全取决于你的需求或者编程的方式。 

375 
00:20:56,989 --> 00:20:59,333 
你可以选择类似于Rebol的方式编程， 

376 
00:20:59,333 --> 00:21:01,619 
这种方式非常灵活， 

377 
00:21:01,619 --> 00:21:06,168 
缺点是性能较差。 

378 
00:21:06,168 --> 00:21:08,549 
你也可以选择静态的方式， 

379 
00:21:08,549 --> 00:21:10,581 
即为所有的一切都指定好类型， 

380 
00:21:10,581 --> 00:21:13,702 
这样的话，编译器就会做更多的类型检查工作， 

381 
00:21:13,702 --> 00:21:16,969 
你就可以在编译阶段而不是运行阶段 

382 
00:21:16,969 --> 00:21:21,230 
获得警告或者错误提示。 

383 
00:21:21,230 --> 00:21:28,353 
另外，如果你没有添加类型描述， 

384 
00:21:28,353 --> 00:21:31,687 
在某些情况下，编译器可以 

385 
00:21:31,687 --> 00:21:34,141 
做一定的类型推断工作， 

386 
00:21:34,141 --> 00:21:36,654 
帮助你推测变量的类型。 

387 
00:21:36,654 --> 00:21:41,093 
但是和Rebol一样，Red也是一门动态性很高的语言， 

388 
00:21:41,093 --> 00:21:48,734 
所以推测引擎的功能 

389 
00:21:48,734 --> 00:21:53,581 
是非常有限的， 

390 
00:21:53,581 --> 00:21:56,756 
因此它能够提供的帮助也是很有限的。 

391 
00:21:56,756 --> 00:22:01,167 
我们当然会支持Unicode。 

392 
00:22:01,167 --> 00:22:04,623 
Red源代码的编码格式是UTF-8。 

393 
00:22:04,623 --> 00:22:09,567 
我们也会为其他编码格式提供一些外部的编解码器。 

394 
00:22:09,567 --> 00:22:16,728 
基本上，Red语言内部存储和操作 

395 
00:22:16,728 --> 00:22:20,036 
Unicode字符串的方式 

396 
00:22:20,036 --> 00:22:22,719 
与最新版本的Python语言相似。 

397 
00:22:22,719 --> 00:22:29,671 
内部存储是定长的， 

398 
00:22:29,671 --> 00:22:35,382 
但是每个不同的码点可能会占用 

399 
00:22:35,382 --> 00:22:37,921 
1到4个不等的字节。 

400 
00:22:37,921 --> 00:22:40,144 
系统会根据输入 

401 
00:22:40,144 --> 00:22:43,224 
和对字符串所做的修改 

402 
00:22:43,224 --> 00:22:48,908 
自动适应和调整所需要的长度。 

403 
00:22:48,908 --> 00:22:54,977 
Red的另外一个重要方面 

404 
00:22:54,977 --> 00:22:57,640 
是对并发的支持。 

405 
00:22:57,640 --> 00:23:00,108 
但是由于目前尚未实现 

406 
00:23:00,108 --> 00:23:04,207 
所以我就不进行深入探讨了。 

407 
00:23:04,207 --> 00:23:09,102 
两项主要的事情： 

408 
00:23:09,102 --> 00:23:11,330 
一是任务并行， 

409 
00:23:11,330 --> 00:23:15,331 
这样就可以在多核上 

410 
00:23:15,331 --> 00:23:18,367 
并行执行多个线程的代码。 

411 
00:23:18,367 --> 00:23:21,891 
我们可能会采用Actor模型。 

412 
00:23:21,891 --> 00:23:26,693 
但是从Red项目开始以来 

413 
00:23:26,693 --> 00:23:31,042 
我们考虑过众多其他的并发模型。 

414 
00:23:31,042 --> 00:23:34,926 
比如Go routines， 

415 
00:23:34,926 --> 00:23:38,981 
这是Go语言的一个 

416 
00:23:38,981 --> 00:23:40,645 
相当大的卖点。 

417 
00:23:40,645 --> 00:23:43,082 
也许我们也应该为Red考虑一下， 

418 
00:23:43,082 --> 00:23:45,725 
或许是... 

419 
00:23:45,725 --> 00:23:48,651 
作为actor及其他模型的补充， 

420 
00:23:48,651 --> 00:23:50,974 
或许是将它们替代。 

421 
00:23:50,974 --> 00:23:54,765 
因此当我们要着手实现 

422 
00:23:54,765 --> 00:23:57,311 
并发支持的时候会重新考虑 

423 
00:23:57,311 --> 00:23:59,900 
所有相关的设计决策， 

424 
00:23:59,900 --> 00:24:03,665 
看一看是否可以 

425 
00:24:03,665 --> 00:24:06,840 
复制其他的成功策略来完善它们。 

426 
00:24:06,840 --> 00:24:09,047 
我们还想通过使用单指令流多数据流（SIMD） 

427 
00:24:09,047 --> 00:24:13,712 
或是多核处理技术来实现 

428 
00:24:13,712 --> 00:24:16,582 
一定程度的数据并行。 

429 
00:24:16,582 --> 00:24:19,851 
主要会用到 

430 
00:24:19,851 --> 00:24:25,917 
Red系列值并行处理的功能。 

431 
00:24:25,917 --> 00:24:30,758 
我们还打算解决一些 

432 
00:24:30,758 --> 00:24:33,476 
目前Rebol尚未能真正解决的问题， 

433 
00:24:33,476 --> 00:24:36,231 
这就是：怎么实现一种方言， 

434 
00:24:36,231 --> 00:24:38,956 
或是领域特定语言（DSL）？ 

435 
00:24:38,956 --> 00:24:41,438 
Rebol非常擅长于此 

436 
00:24:41,438 --> 00:24:44,368 
它可能是做这类事情的最好的工具之一 

437 
00:24:44,368 --> 00:24:45,658 
因为它拥有PARSE以及 

438 
00:24:45,658 --> 00:24:48,084 
其他一些令人惊艳的特征， 

439 
00:24:48,084 --> 00:24:50,101 
这些使得它成为一个不错的选择。 

440 
00:24:50,101 --> 00:24:54,911 
然而创造一门领域特定语言或者方言 

441 
00:24:54,911 --> 00:24:57,186 
可不是一件那么容易的事情。 

442 
00:24:57,186 --> 00:24:59,774 
因为你首先需要进行设计， 

443 
00:24:59,774 --> 00:25:01,425 
这里面就有相当多的工作要做。 

444 
00:25:01,425 --> 00:25:03,427 
然后你还要去将其实现。 

445 
00:25:03,427 --> 00:25:07,113 
实现一种领域特定语言或者方言 

446 
00:25:07,113 --> 00:25:11,151 
其实就是实现一个解释器或者编译器。 

447 
00:25:11,151 --> 00:25:17,524 
到了这一步，你唯一拥有的就只是代码了。 

448 
00:25:17,524 --> 00:25:20,462 
你并没有一个真正意义上的框架 

449 
00:25:20,462 --> 00:25:22,134 
来辅助你做这些事情。 

450 
00:25:22,134 --> 00:25:25,585 
一种可行的方案是 

451 
00:25:25,585 --> 00:25:27,439 
借助Rebol语言的力量 

452 
00:25:27,439 --> 00:25:29,507 
在Red或者Rebol中 

453 
00:25:29,507 --> 00:25:32,431 
创造一种用来设计DSL的DSL（meta-DSL）， 

454 
00:25:32,431 --> 00:25:38,218 
借助它可以使你的工作更加富有成效， 

455 
00:25:38,218 --> 00:25:40,920 
同时也提供了一个 

456 
00:25:40,920 --> 00:25:44,260 
创建新的方言和领域特定语言（DSL）的框架。 

457 
00:25:44,260 --> 00:25:47,156 
总的说来它可以看做一个 

458 
00:25:47,156 --> 00:25:50,105 
更高级的PARSE。 

459 
00:25:50,105 --> 00:25:52,557 
举个例子，可以这样设想它， 

460 
00:25:52,557 --> 00:25:59,457 
在使用PARSE解析一个事件轮询时， 

461 
00:25:59,457 --> 00:26:03,732 
这个事件轮询会被隐藏起来， 

462 
00:26:03,732 --> 00:26:07,914 
就像Visual Basic中做的那样。 

463 
00:26:07,914 --> 00:26:11,544 
你只需要实现事件方法就可以创造出你的领域特定语言（DSL）了， 

464 
00:26:11,544 --> 00:26:17,351 
无论是以解释器还是编译器的形式。 

465 
00:26:17,351 --> 00:26:26,170 
Red的编译器用来做什么事情呢？ 

466 
00:26:26,170 --> 00:26:30,786 
它会把Red代码转换为 

467 
00:26:30,786 --> 00:26:34,944 
较低层级的Red/System代码。 

468 
00:26:34,944 --> 00:26:40,093 
下面我会演示给大家看。 

469 
00:26:40,093 --> 00:26:45,535 
首先这里有一个非常简单的Red表达式， 

470 
00:26:45,535 --> 00:26:48,493 
Red编译器会对其进行解析， 

471 
00:26:48,493 --> 00:26:53,884 
并且使用一个栈（stack）结构来存放解析后获得的参数。 

472 
00:26:53,884 --> 00:26:58,480 
实际上这里用到了两个堆栈：一个调用栈和 

473 
00:26:58,480 --> 00:27:01,819 
一个数据栈。 

474 
00:27:01,819 --> 00:27:05,361 
之后代码生成器会基于此 

475 
00:27:05,361 --> 00:27:08,363 
生成Red/System代码。 

476 
00:27:08,363 --> 00:27:10,782 
右边看到的部分就是 

477 
00:27:10,782 --> 00:27:14,350 
那个表达式最终生成的Red/System代码， 

478 
00:27:14,350 --> 00:27:18,061 
称之为Red运行时API。 

479 
00:27:22,651 --> 00:27:28,334 
Red编译器及Red语言 

480 
00:27:28,334 --> 00:27:29,406 
另外一个非凡的方面是 

481 
00:27:29,406 --> 00:27:34,169 
它把几种不同的方法结合在了一起， 

482 
00:27:34,169 --> 00:27:37,846 
这一点可以说是独一无二的。 

483 
00:27:37,846 --> 00:27:41,156 
最基本的组件是一个静态编译器。 

484 
00:27:41,156 --> 00:27:44,538 
这个静态编译器会与一个内置的解释器 

485 
00:27:44,538 --> 00:27:46,584 
一起生成编译后的代码， 

486 
00:27:46,584 --> 00:27:51,606 
将来还会在可执行文件中内嵌一个JIT编译器。 

487 
00:27:51,606 --> 00:27:58,368 
上述三个组件会 

488 
00:27:58,368 --> 00:28:02,334 
互相支持，协同工作。 

489 
00:28:02,334 --> 00:28:05,191 
例如，编译后的代码 

490 
00:28:05,191 --> 00:28:08,428 
可以调用内部的解释器， 

491 
00:28:08,428 --> 00:28:12,551 
而解释器本身也可以反过来调用编译后的代码。 

492 
00:28:12,551 --> 00:28:16,189 
对于JIT编译器来说也是如此。 

493 
00:28:16,189 --> 00:28:19,973 
听起来有点抽象，但是在演示结束之前 

494 
00:28:19,973 --> 00:28:21,707 
我会给大家展示一张幻灯片， 

495 
00:28:21,707 --> 00:28:23,904 
上面有一个运用这种方法的实例。 

496 
00:28:23,904 --> 00:28:28,901 
实际上，这是一种解决非常复杂的语义问题 

497 
00:28:28,901 --> 00:28:35,136 
的非常有效的方法。 

498 
00:28:35,136 --> 00:28:39,575 
例如，编译符号代码通常 

499 
00:28:39,575 --> 00:28:42,229 
是一件非常困难的事情。 

500 
00:28:42,229 --> 00:28:43,740 
但是如果把几种不同的方法结合在一起 

501 
00:28:43,740 --> 00:28:49,758 
就会找到一个非常有效的解决方案。 

502 
00:28:49,758 --> 00:28:54,407 
我下面用一个非常简单的示例 

503 
00:28:54,407 --> 00:29:00,583 
来演示一下Red代码长得什么样。 

504 
00:29:00,583 --> 00:29:03,399 
与Rebol一样， 

505 
00:29:03,399 --> 00:29:08,492 
最开始是一个[Red]标识符， 

506 
00:29:08,492 --> 00:29:13,355 
后面紧跟着的一个由方块构成的文件头， 

507 
00:29:13,355 --> 00:29:17,254 
之后是你的代码。 

508 
00:29:17,254 --> 00:29:19,921 
Hello world只需要写[print "Hello World"]就可以了， 

509 
00:29:19,921 --> 00:29:22,312 
与Rebol中一样。其余的代码 

510 
00:29:22,312 --> 00:29:26,336 
也看起来非常像Rebol代码， 

511 
00:29:26,336 --> 00:29:32,270 
有一点例外，就是[return: [type!]]， 

512 
00:29:32,270 --> 00:29:36,908 
这个是可选的，它属于我前面讲过的 

513 
00:29:36,908 --> 00:29:40,409 
可选的类型指定范畴。 

514 
00:29:40,409 --> 00:29:43,389 
这恰好是一个这方面的示例。 

515 
00:29:43,389 --> 00:29:48,196 
这一点并不是强制要求的，但是如果这么做了的话 

516 
00:29:48,196 --> 00:29:54,758 
编译器就会生成更好更快的代码。 

517 
00:29:54,758 --> 00:29:59,006 
以上就是对Red语言的内部细节 

518 
00:29:59,006 --> 00:30:02,905 
及不同的组成部分的介绍， 

519 
00:30:02,905 --> 00:30:05,640 
你现在应该对它们之间的关联关系 

520 
00:30:05,640 --> 00:30:09,472 
有了更清晰的认识。 

521 
00:30:09,472 --> 00:30:13,971 
让我们从最右边的人说起。 

522 
00:30:13,971 --> 00:30:17,047 
最前面是一个命令行， 

523 
00:30:17,047 --> 00:30:19,852 
目前是用Rebol2写的， 

524 
00:30:19,852 --> 00:30:25,527 
它后面的两堆东西 

525 
00:30:25,527 --> 00:30:28,351 
分别属于两个编译器。一个是Red的， 

526 
00:30:28,351 --> 00:30:32,604 
它比较简短，因为它只生成Red/System代码。 

527 
00:30:32,604 --> 00:30:34,311 
另一个是Red/System的， 

528 
00:30:34,311 --> 00:30:36,720 
从上到下直到打包器， 

529 
00:30:36,720 --> 00:30:41,424 
它可以生成二进制文件。 

530 
00:30:41,424 --> 00:30:47,027 
上述工具链都是使用Rebol 2 编写的。 

531 
00:30:47,027 --> 00:30:52,304 
在左边可以看到Red的运行环境， 

532 
00:30:52,304 --> 00:30:55,586 
非常大的一坨代码， 

533 
00:30:55,586 --> 00:30:59,651 
实际上可能会比另一边的代码量要大。 

534 
00:30:59,651 --> 00:31:02,964 
这部分是用Red/System写的。 

535 
00:31:02,964 --> 00:31:06,914 
你会发现所有的“大腕”们都位于这一边。 

536 
00:31:06,914 --> 00:31:08,649 
例如，所有的数据类型， 

537 
00:31:08,649 --> 00:31:12,104 
全部本地层面的代码（natives），中间层代码， 

538 
00:31:12,104 --> 00:31:16,600 
解释器，桥接器——像刚才提到的Java桥接器， 

539 
00:31:16,600 --> 00:31:19,025 
目前可供使用—— 

540 
00:31:19,025 --> 00:31:23,058 
内存管理器和用来访问底层部件 

541 
00:31:23,058 --> 00:31:26,485 
的低层级接口等。 

542 
00:31:26,485 --> 00:31:28,829 
举个例子，你不仅可以直接访问 

543 
00:31:28,829 --> 00:31:31,993 
操作系统的API，而且还可以访问内核代码。 

544 
00:31:31,993 --> 00:31:34,001 
在Linux系统上可以直接进行系统调用。 

545 
00:31:34,001 --> 00:31:38,340 
如果需要的话，甚至可以深入到硬件层级， 

546 
00:31:38,340 --> 00:31:41,869 
来调用非常低级的功能。 

547 
00:31:44,599 --> 00:31:46,625 
我刚才可能忘了介绍Red的控制台， 

548 
00:31:46,625 --> 00:31:49,985 
它也是用Red语言写的， 

549 
00:31:49,985 --> 00:31:52,946 
Red/System负责比较低层级的部分。 

550 
00:31:53,816 --> 00:31:57,120 
说到Red/System...明天我还会有一个比较简短的 

551 
00:31:57,120 --> 00:32:01,142 
专门介绍Red/System的演示，因为 

552 
00:32:01,142 --> 00:32:06,082 
相比Rebol，这是Red中的一个新玩意。 

553 
00:32:06,082 --> 00:32:08,541 
所以今天我只准备了一张幻灯片来介绍Red/System， 

554 
00:32:08,541 --> 00:32:10,120 
大家有一个大概的印象就好了。 

555 
00:32:10,120 --> 00:32:16,748 
本质上它是一种与C语言同一级别的语言， 

556 
00:32:16,748 --> 00:32:20,078 
不过采用的是Red语言形式的语法。 

557 
00:32:20,078 --> 00:32:22,760 
所以虽然感觉像是在用Red语言编程 

558 
00:32:22,760 --> 00:32:29,827 
但是使用的是非常低级的数据类型和操作。 

559 
00:32:29,827 --> 00:32:32,630 
它采用静态编译的方法。 

560 
00:32:32,630 --> 00:32:35,956 
到目前为止还没有进行任何优化。:-) 

561 
00:32:35,956 --> 00:32:40,988 
不过它只比经过“-O2”级别优化编译的C语言代码 

562 
00:32:40,988 --> 00:32:43,849 
慢4倍。 

563 
00:32:43,849 --> 00:32:47,674 
因此还算是相当不错的，实际上是非常不错的， 

564 
00:32:47,674 --> 00:32:51,224 
因为一旦我们对其进行了优化， 

565 
00:32:51,224 --> 00:32:53,398 
运行效率将会非常非常接近C语言。 

566 
00:32:53,398 --> 00:32:57,362 
虽然不会超越C语言，那不是我们的目标， 

567 
00:32:57,362 --> 00:33:00,014 
但是会非常非常接近。 

568 
00:33:00,014 --> 00:33:05,041 
所以Red/System非常有潜力成为C语言之外的第二选择。 

569 
00:33:05,041 --> 00:33:09,334 
例如，它已经在图像处理领域 

570 
00:33:09,334 --> 00:33:11,936 
取得了不错的成绩， 

571 
00:33:11,936 --> 00:33:15,680 
Bo (Lechnowsky)会在明天给大家做一个这方面的演示。 

572 
00:33:15,680 --> 00:33:17,968 
下面是一些C语言本身不具备， 

573 
00:33:17,968 --> 00:33:22,310 
或者说大多数低级编程语言都不具备的特性： 

574 
00:33:22,310 --> 00:33:24,792 
Red/System有命名空间的概念， 

575 
00:33:24,792 --> 00:33:27,024 
类似于Rebol里的语境， 

576 
00:33:27,024 --> 00:33:33,586 
但是是静态的，所以我们在Red/System中也用CONTEXT关键字 

577 
00:33:33,586 --> 00:33:35,909 
来声明它们。 

578 
00:33:35,909 --> 00:33:38,936 
你还可以使用WITH关键字 

579 
00:33:38,936 --> 00:33:43,428 
将部分代码置于某个语境中， 

580 
00:33:43,428 --> 00:33:47,121 
类似于其他编程语言中命名空间的声明。 

581 
00:33:47,121 --> 00:33:52,155 
在Red/System中数据类型非常有限， 

582 
00:33:52,155 --> 00:34:00,763 
共有9种类型， 

583 
00:34:00,763 --> 00:34:05,467 
基本上与C语言一致。 

584 
00:34:05,467 --> 00:34:11,372 
函数类型并不属于完全意义上的"一等公民"， 

585 
00:34:11,372 --> 00:34:16,155 
我曾对此考虑再三，因为... 

586 
00:34:16,155 --> 00:34:19,723 
如果我将它实现为一个完全意义上的“一等公民”类型的话， 

587 
00:34:19,723 --> 00:34:22,571 
可能就会有人要求我 

588 
00:34:22,571 --> 00:34:24,925 
将Red/System设计成一种函数式编程语言。 

589 
00:34:24,925 --> 00:34:27,986 
这一点是可以做到的，但是它并不是我们的目标。 

590 
00:34:27,986 --> 00:34:32,540 
这样做其实没有什么用途，因此我很不愿意 

591 
00:34:32,540 --> 00:34:37,835 
给这个数据类型添加新功能。 

592 
00:34:37,835 --> 00:34:40,324 
我们还有类型推断， 

593 
00:34:40,324 --> 00:34:42,395 
可以不用指定局部变量的数据类型， 

594 
00:34:42,395 --> 00:34:45,235 
编译器会进行推测。 

595 
00:34:45,235 --> 00:34:48,666 
兼容的数据类型之间可以进行的类型转换， 

596 
00:34:48,666 --> 00:34:52,473 
当然仅限于兼容的数据之间。 

597 
00:34:52,473 --> 00:34:56,548 
我们还支持一定水平的反射功能， 

598 
00:34:56,548 --> 00:35:04,017 
这是C语言不具备但是C++具备的。 

599 
00:35:04,017 --> 00:35:07,445 
你可以在Red/System中声明一个 

600 
00:35:07,445 --> 00:35:12,157 
参数个数可变的函数， 

601 
00:35:12,157 --> 00:35:14,311 
使用方括号将参数括起来 

602 
00:35:14,311 --> 00:35:16,341 
然后在函数内部 

603 
00:35:16,341 --> 00:35:19,854 
遍历参数列表， 

604 
00:35:19,854 --> 00:35:23,665 
查询每个参数的类型。 

605 
00:35:23,665 --> 00:35:26,778 
这是一个相当强大的特征， 

606 
00:35:26,778 --> 00:35:32,499 
事实上Kaj de Vos已经利用这个功能用Red/System构建了 

607 
00:35:32,499 --> 00:35:36,773 
一个与VID类似的方言 

608 
00:35:36,773 --> 00:35:38,853 
这是一项伟大的壮举，因为 

609 
00:35:38,853 --> 00:35:42,243 
在Red/System语言中并不能进行符号式编程。:-) 

610 
00:35:42,243 --> 00:35:47,656 
这个方言看起来很像VID，但是实际上使用反射机制来执行， 

611 
00:35:47,656 --> 00:35:50,854 
真的非常棒。 

612 
00:35:50,854 --> 00:35:55,630 
在Red/System中还有一个预处理器， 

613 
00:35:55,630 --> 00:36:01,262 
不过我打算在下一个较大版本发布中将其去除， 

614 
00:36:01,262 --> 00:36:06,590 
因为它对我们来说要 

615 
00:36:06,590 --> 00:36:11,779 
弊大于利。 

616 
00:36:11,779 --> 00:36:13,727 
我们可能会有选择地保留一部分， 

617 
00:36:13,727 --> 00:36:16,774 
但是需要重新考虑和设计。 

618 
00:36:16,774 --> 00:36:20,186 
#define是一个相当强大的功能， 

619 
00:36:20,186 --> 00:36:22,128 
可以与C语言中的宏相媲美， 

620 
00:36:22,128 --> 00:36:27,392 
你甚至可以向它传递参数。 

621 
00:36:27,392 --> 00:36:34,001 
我们还设想要有一些能够访问CPU的低层级的功能， 

622 
00:36:34,001 --> 00:36:39,385 
目前我们可以支持跨平台 

623 
00:36:39,385 --> 00:36:41,747 
访问CPU的部分寄存器。 

624 
00:36:41,747 --> 00:36:43,617 
我们还可以支持访问堆栈（stack）—— 

625 
00:36:43,617 --> 00:36:46,743 
你可以在Red/System层面 

626 
00:36:46,743 --> 00:36:49,724 
跨平台操作本地堆栈（native stack）。 

627 
00:36:49,724 --> 00:36:55,232 
我们之后会添加对中断、I/O 

628 
00:36:55,232 --> 00:37:02,004 
以及其他CPU基本功能的支持。 

629 
00:37:02,004 --> 00:37:07,289 
我们可能还会增加一些对内联汇编的支持， 

630 
00:37:07,289 --> 00:37:10,224 
但是目前还不是一个要紧的需求。 

631 
00:37:10,224 --> 00:37:13,926 
下面是对Red项目的一些统计说明。 

632 
00:37:13,926 --> 00:37:18,596 
大部分代码在BSD协议下开源， 

633 
00:37:18,596 --> 00:37:22,560 
Red的运行时部分则在“BSL”协议下开源。 

634 
00:37:22,560 --> 00:37:25,945 
"BSL"的意思是“Boost软件协议”（Boost Software License） 

635 
00:37:25,945 --> 00:37:32,015 
这个协议比BSD协议还要宽松， 

636 
00:37:32,015 --> 00:37:34,999 
受到的限制更少。 

637 
00:37:34,999 --> 00:37:37,856 
我们从一开始就将代码托管在了Github上， 

638 
00:37:37,856 --> 00:37:43,033 
我们有9个核心提交者...我想这里有点小差错 

639 
00:37:43,033 --> 00:37:46,604 
现在应该是11个了。 

640 
00:37:46,604 --> 00:37:50,335 
共计有2000多次提交， 

641 
00:37:50,335 --> 00:37:52,867 
不包括提交合并。 

642 
00:37:52,867 --> 00:37:58,035 
在bug追踪库里有大约500个tickets， 

643 
00:37:58,035 --> 00:38:00,490 
不过大多都已经处于关闭状态了。 

644 
00:38:00,490 --> 00:38:03,576 
我们尽可能做到bug一出现就其将解决掉 

645 
00:38:03,576 --> 00:38:05,852 
以防它们积累起来。 

646 
00:38:05,852 --> 00:38:07,516 
因为一但积累起来， 

647 
00:38:07,516 --> 00:38:10,788 
就几乎不可能对它们进行处理了。 

648 
00:38:10,788 --> 00:38:14,469 
所以非常有必要将它们的数量保持在一个极低的水平。 

649 
00:38:14,469 --> 00:38:16,696 
我们还有非常多的单元测试用例 

650 
00:38:16,696 --> 00:38:19,569 
这些都是Peter Wood编写的， 

651 
00:38:19,569 --> 00:38:23,180 
他为此做了大量的工作， 

652 
00:38:23,180 --> 00:38:25,361 
真的是帮了我们的大忙。 

653 
00:38:25,361 --> 00:38:27,897 
下面是对 

654 
00:38:27,897 --> 00:38:30,019 
源代码代码量的统计， 

655 
00:38:30,019 --> 00:38:32,026 
分别对Red和Red/System两部分进行了统计， 

656 
00:38:32,026 --> 00:38:34,073 
包括编译器、链接器等。 

657 
00:38:34,073 --> 00:38:35,923 
你可以亲眼看到 

658 
00:38:35,923 --> 00:38:37,897 
这个代码库有多么小。 

659 
00:38:37,897 --> 00:38:41,619 
可以做这么多事情, 这些都要归功于Rebol :-) 

660 
00:38:41,619 --> 00:38:45,444 
用一个很小的代码库、很少量的代码 

661 
00:38:45,444 --> 00:38:47,680 
就可以多这么多事情。 

662 
00:38:47,680 --> 00:38:50,946 
如果你将它与其他工具链做一个比较的话， 

663 
00:38:50,946 --> 00:38:55,006 
在代码量上通常会发现一到两个 

664 
00:38:55,006 --> 00:38:57,700 
数量级的差距。 

665 
00:38:57,700 --> 00:38:59,251 
固然其他工具链涉及的领域 

666 
00:38:59,251 --> 00:39:01,428 
比我们的要广。 

667 
00:39:01,428 --> 00:39:06,544 
然而我们仅仅使用一个很小的代码库就 

668 
00:39:06,544 --> 00:39:09,376 
可以涵盖相当多的领域。 

669 
00:39:09,376 --> 00:39:14,352 
我们仍然有很多工作要做， 

670 
00:39:14,352 --> 00:39:18,824 
项目仍然处在繁忙的开发过程中。 

671 
00:39:18,824 --> 00:39:23,389 
我们还有几个核心部分尚未进行开发。 

672 
00:39:23,389 --> 00:39:30,653 
我们需要支持对象，这部分还没有。 

673 
00:39:30,653 --> 00:39:34,083 
也还没有合适的错误处理机制， 

674 
00:39:34,083 --> 00:39:36,009 
因为需要OBJECT!类型（即对象）来支持它。 

675 
00:39:36,009 --> 00:39:40,244 
在编译器的某些部分 

676 
00:39:40,244 --> 00:39:42,915 
还缺乏对参数类型进行检查的功能。 

677 
00:39:42,915 --> 00:39:45,487 
目前我们还不支持I/O，不过 

678 
00:39:45,487 --> 00:39:50,941 
对象和I/O的优先级很高 

679 
00:39:50,941 --> 00:39:54,697 
它们大概会在今年夏天开发出来。 

680 
00:39:54,697 --> 00:39:59,696 
在1.0版本中我们打算支持一定的并发功能， 

681 
00:39:59,696 --> 00:40:05,334 
自然我们还打算提供 

682 
00:40:05,334 --> 00:40:09,829 
一个模块化编译系统和模块体系。 

683 
00:40:09,829 --> 00:40:14,260 
我们可能会提供一个非常小的Red IDE， 

684 
00:40:14,260 --> 00:40:18,032 
它可以用作一个编辑器 

685 
00:40:18,032 --> 00:40:23,468 
外加调试器...我们会在以后的版本中 

686 
00:40:23,468 --> 00:40:27,570 
对它进行扩展。 

687 
00:40:27,570 --> 00:40:31,050 
我们要有一份全面的文档， 

688 
00:40:31,050 --> 00:40:37,597 
这将会是1.0版本发布过程中相当受欢迎的一点。 

689 
00:40:37,597 --> 00:40:41,836 
所以编写文档和教程 

690 
00:40:41,836 --> 00:40:43,650 
还有相当多的工作要做。 

691 
00:40:43,650 --> 00:40:46,529 
当然了，为了准备1.0版本的发布 

692 
00:40:46,529 --> 00:40:49,753 
我们还需要准备一个新的网站。 

693 
00:40:51,613 --> 00:40:54,761 
不过这还不是全部... :-) 

694 
00:40:54,761 --> 00:40:57,310 
这还不是真正的Red。 

695 
00:40:57,310 --> 00:41:00,523 
真正地Red将会出现在2.0版本中， 

696 
00:41:00,523 --> 00:41:05,640 
届时会有一个相当华丽的阵容（笑声） 

697 
00:41:05,640 --> 00:41:07,538 
那么什么才是“真正的Red”呢？ 

698 
00:41:07,538 --> 00:41:11,329 
实际上，到目前为止我所说的那些 

699 
00:41:11,329 --> 00:41:13,583 
不过是用来辅助修建建筑的脚手架罢了。 

700 
00:41:13,583 --> 00:41:15,570 
因为真正的Red将会是这样的。 

701 
00:41:15,570 --> 00:41:23,308 
真正地Red基本上就是一个JIT编译器， 

702 
00:41:23,308 --> 00:41:27,206 
它也可以用作静态编译器。 

703 
00:41:27,206 --> 00:41:29,613 
整个的内部结构 

704 
00:41:29,613 --> 00:41:32,929 
将会与目前这个处于自举阶段的版本 

705 
00:41:32,929 --> 00:41:35,846 
大不相同。 

706 
00:41:35,846 --> 00:41:39,254 
它是面向插件的， 

707 
00:41:39,254 --> 00:41:40,910 
所以编译器和工具链基本上 

708 
00:41:40,910 --> 00:41:44,718 
就是一个外壳——或者说一个框架—— 

709 
00:41:44,718 --> 00:41:49,830 
从语法分析到目标文件的生成各个阶段， 

710 
00:41:49,830 --> 00:41:54,223 
你都可以为之添加一些模块 

711 
00:41:54,223 --> 00:41:57,606 
来为它添加一些新功能。 

712 
00:41:57,606 --> 00:42:00,981 
所有的这些你都会有与之对应的API来做这些事情。 

713 
00:42:00,981 --> 00:42:03,679 
我只提供一个框架 

714 
00:42:03,679 --> 00:42:07,304 
和极少数量的模块， 

715 
00:42:07,304 --> 00:42:10,946 
使之能够提供与1.0版本的相同的功能点。 

716 
00:42:10,946 --> 00:42:15,920 
这些API当然会写入公开文档中， 

717 
00:42:15,920 --> 00:42:18,986 
这样的话人人都可以以一种互不影响 

718 
00:42:18,986 --> 00:42:22,012 
和非常结构化的方式 

719 
00:42:22,012 --> 00:42:25,657 
对编译器进行修改和添加新功能。 

720 
00:42:25,657 --> 00:42:29,935 
这样的API也可以在运行过程中被调用。 

721 
00:42:29,935 --> 00:42:34,584 
所以大家可以想象一下 

722 
00:42:34,584 --> 00:42:37,270 
在程序运行过程中对编译器自身及其工具链进行修改 

723 
00:42:37,270 --> 00:42:38,819 
会带来多少做事情的选择和可达成的可能性！ 

724 
00:42:38,819 --> 00:42:40,186 
在运行过程中对语言自身进行修改 

725 
00:42:40,186 --> 00:42:43,657 
或是添加新的功能是完全可能的。 

726 
00:42:43,657 --> 00:42:47,107 
这些听起来相当疯狂， 

727 
00:42:47,107 --> 00:42:48,494 
然而这正是某些正在发展中的语言 

728 
00:42:48,494 --> 00:42:53,525 
在做的事情， 

729 
00:42:53,525 --> 00:42:56,184 
比如， 

730 
00:42:56,184 --> 00:42:57,921 
Scala就是这么做的。 

731 
00:42:57,921 --> 00:43:00,094 
一些来自于Scala社区的人 

732 
00:43:00,094 --> 00:43:04,242 
利用这种功能做出了令人惊叹的东西。 

733 
00:43:04,242 --> 00:43:07,042 
举个例子，一个非常聪明的哥们 

734 
00:43:07,042 --> 00:43:13,634 
利用这个API为循环添加了并行计算支持， 

735 
00:43:13,634 --> 00:43:18,648 
实现并行计算使用的是GPGPU， 

736 
00:43:18,648 --> 00:43:23,715 
底层使用的是开放计算语言（OpenCL）。 

737 
00:43:23,715 --> 00:43:27,094 
因此这是一个非常强大的特性， 

738 
00:43:27,094 --> 00:43:31,124 
同时也使得编译器的架构更加健壮， 

739 
00:43:31,124 --> 00:43:37,405 
也使得人们 

740 
00:43:37,405 --> 00:43:39,391 
以更加简单 

741 
00:43:39,391 --> 00:43:42,666 
更加结构化的方式贡献代码。 

742 
00:43:42,666 --> 00:43:45,410 
这里的言外之意是当前这个编译器的代码库 

743 
00:43:45,410 --> 00:43:50,145 
...就是位于Red内部结构示意图 

744 
00:43:50,145 --> 00:43:53,929 
右侧的部分... 

745 
00:43:53,929 --> 00:43:56,942 
这个目前使用Rebol 2写的代码库 

746 
00:43:56,942 --> 00:44:00,594 
用完就可以丢弃。 

747 
00:44:00,594 --> 00:44:04,283 
从一开始我就写得非常快， 

748 
00:44:04,283 --> 00:44:08,540 
觉得在一年之内就可以 

749 
00:44:08,540 --> 00:44:10,412 
堆砌起来， 

750 
00:44:10,412 --> 00:44:14,035 
之后就可以用Red自身快速地重写一遍。 

751 
00:44:14,035 --> 00:44:18,069 
但是由于中间我们修改了很多东西， 

752 
00:44:18,069 --> 00:44:22,374 
为应对环境的变化做了很多调整 

753 
00:44:22,374 --> 00:44:25,218 
因此现在尚未达到预期的目标。 

754 
00:44:25,218 --> 00:44:29,434 
因此我们会先在1.0版本中发布这个自举的版本 

755 
00:44:29,434 --> 00:44:32,590 
而后再在2.0版本中发布使用Red重写后的 

756 
00:44:32,590 --> 00:44:35,173 
自托管的版本。 

757 
00:44:35,173 --> 00:44:41,975 
整个Red运行时部分将会保持不变， 

758 
00:44:41,975 --> 00:44:43,714 
因为它是用Red/System写的， 

759 
00:44:43,714 --> 00:44:47,340 
它会被保留下来，这是一个非常大的代码库。 

760 
00:44:47,340 --> 00:44:50,087 
这样的话就只有使用Rebol 2写的部分 

761 
00:44:50,087 --> 00:44:53,342 
需要被重写，基本上 

762 
00:44:53,342 --> 00:44:56,511 
就是Red和Red/System的编译器部分。 

763 
00:44:56,511 --> 00:44:59,654 
简单介绍一些这个项目的管理结构： 

764 
00:44:59,654 --> 00:45:05,659 
我们在GitHub上有两位合作者， 

765 
00:45:05,659 --> 00:45:10,028 
也就是说除管理员外还有另外两个成员拥有管理员权限。 

766 
00:45:10,028 --> 00:45:15,747 
如果我不幸被车撞了， 

767 
00:45:15,747 --> 00:45:21,832 
这两名成员就会接管Red代码库中的源代码 

768 
00:45:21,832 --> 00:45:26,973 
并对其进行管理。 

769 
00:45:26,973 --> 00:45:30,940 
从开始到现在我们共有11名贡献者。 

770 
00:45:30,940 --> 00:45:33,673 
我们有一个邮件列表， 

771 
00:45:33,673 --> 00:45:37,359 
一个Facebook页面，一个IRC频道， 

772 
00:45:37,359 --> 00:45:42,087 
里面有一个出自Andreas之手的非常可爱IRC机器人 

773 
00:45:42,087 --> 00:45:44,471 
用来报告代码的提交情况。 

774 
00:45:44,471 --> 00:45:46,792 
当然我们也在努力寻找 

775 
00:45:46,792 --> 00:45:49,389 
有兴趣贡献代码 

776 
00:45:49,389 --> 00:45:52,707 
以及以任何一种方式参与到这个项目中来的同路人 

777 
00:45:52,707 --> 00:45:54,940 
因为这是一个极其宏大的项目... 

778 
00:45:54,940 --> 00:45:58,775 
我们需要很多援手。 

779 
00:46:00,945 --> 00:46:03,564 
最后一点，也是非常重要的一点 :-) 

780 
00:46:03,564 --> 00:46:09,450 
自两年半之前开始到现在， 

781 
00:46:09,450 --> 00:46:12,146 
我已经把我的每一分积蓄 

782 
00:46:12,146 --> 00:46:16,020 
都投入到了这个项目当中。 :-) 

783 
00:46:16,020 --> 00:46:20,434 
因此我对这个项目的成功 

784 
00:46:20,434 --> 00:46:22,075 
有着十足的信心。 

785 
00:46:22,075 --> 00:46:27,231 
但是，我很快就经济拮据了。:-) 

786 
00:46:27,231 --> 00:46:30,128 
一年以来，我完全依靠 

787 
00:46:30,128 --> 00:46:33,280 
这门语言的使用者和追随者们的捐助生活。 

788 
00:46:33,280 --> 00:46:35,522 
所以在此我对他们表示诚挚的谢意 

789 
00:46:35,522 --> 00:46:39,136 
因为如果没有他们，我不会走到今天， 

790 
00:46:39,136 --> 00:46:41,448 
如果没有人们的援助的话 

791 
00:46:41,448 --> 00:46:42,987 
Red也不会走到现今这个阶段， 

792 
00:46:42,987 --> 00:46:45,865 
甚至可能早就不存在了。 

793 
00:46:45,865 --> 00:46:49,165 
所以真的非常感谢！我们需要继续 

794 
00:46:49,165 --> 00:46:52,832 
对它进行援助，使它早日完成。 

795 
00:46:52,832 --> 00:46:55,053 
谢谢大家！ 

796 
00:46:55,053 --> 00:46:59,053 
（掌声） 


