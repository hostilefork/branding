1
00:00:10,593 --> 00:00:14,410
Il nostro prossimo oratore è Nenad Rakocevic

2
00:00:14,410 --> 00:00:17,039
che ci dirà "Cos'è Red"

3
00:00:17,039 --> 00:00:22,496
(applausi)

4
00:00:22,886 --> 00:00:27,767
Grazie, Gregg. E grazie a tutte le persone

5
00:00:27,767 --> 00:00:31,908
che hanno contribuito a pagare il costo per il mio viaggio

6
00:00:31,908 --> 00:00:33,728
così ho potuto farlo.

7
00:00:33,728 --> 00:00:36,932
Ho fatto un sacco di presentazioni di Red,

8
00:00:36,932 --> 00:00:43,013
ma i nuovi arrivati a Red stanno ancora venendo da me

9
00:00:43,013 --> 00:00:45,517
con questa semplice domanda:

10
00:00:45,517 --> 00:00:47,400
soltanto "Cos'è Red"

11
00:00:47,400 --> 00:00:50,166
perché il progetto ha molti aspetti

12
00:00:50,166 --> 00:00:51,741
e posso capirlo.

13
00:00:51,741 --> 00:00:54,042
Dunque cercherò in questa presentazione di darvi

14
00:00:54,042 --> 00:00:58,673
una buona visione di ogni parte del progetto.

15
00:00:58,673 --> 00:01:02,522
Allora partiamo da una panoramica del problema.

16
00:01:02,522 --> 00:01:06,517
Non è una foto delle mie cellule cerebrali.

17
00:01:06,517 --> 00:01:10,566
È un modello al computer di una mappa globale

18
00:01:10,566 --> 00:01:12,772
dell'Universo conosciuto.

19
00:01:12,772 --> 00:01:14,740
Questo vi dà una buona immagine

20
00:01:14,740 --> 00:01:18,230
delle dimensioni del problema (risate)

21
00:01:18,230 --> 00:01:20,329
E in realtà è un accenno a

22
00:01:20,329 --> 00:01:23,036
quello che avrei dovuto diventare,

23
00:01:23,036 --> 00:01:26,011
perché stavo studiando astrofisica

24
00:01:26,011 --> 00:01:30,570
e al college sono passato a Computer Science.

25
00:01:30,570 --> 00:01:34,589
La mia visione del mondo dell'informatica è che

26
00:01:34,589 --> 00:01:38,792
ancora oggi stiamo ancora usando alcuni

27
00:01:38,792 --> 00:01:41,018
strumenti e tecniche primitive.

28
00:01:41,018 --> 00:01:44,653
Quindi non siamo molto lontani da questi due ragazzi

29
00:01:44,653 --> 00:01:46,357
sul lato software.

30
00:01:46,357 --> 00:01:49,283
Stiamo ancora lavorando in un modo molto primitivo,

31
00:01:49,283 --> 00:01:51,928
perché continuiamo a reinventare la ruota

32
00:01:51,928 --> 00:01:54,513
e stiamo facendo costantemente gli stessi errori

33
00:01:54,513 --> 00:01:56,041
più e più volte.

34
00:01:56,041 --> 00:01:58,892
Così AI starà ridendo.

35
00:01:58,902 --> 00:02:02,541
Almeno spero. :-) (Risate)

36
00:02:02,541 --> 00:02:08,308
Dunque, tornando un po' di più sul tema,

37
00:02:08,308 --> 00:02:12,563
ci sono veramente un sacco di linguaggi di programmazione.

38
00:02:12,563 --> 00:02:14,927
Se si guarda l'elenco Wikipedia

39
00:02:14,927 --> 00:02:18,596
dei linguaggi di programmazione, questa è solo la parte A

40
00:02:18,596 --> 00:02:23,107
e la pagina non è nemmeno completa.

41
00:02:23,107 --> 00:02:24,802
Quindi ci sono letteralmente migliaia

42
00:02:24,802 --> 00:02:27,188
di linguaggi di programmazione.

43
00:02:27,188 --> 00:02:29,588
Se si guarda lì si vedranno alcuni linguaggi

44
00:02:29,588 --> 00:02:32,839
che sono stati creati su Amiga.

45
00:02:32,839 --> 00:02:34,465
Il famoso "Amiga E"

46
00:02:34,465 --> 00:02:37,288
e AMOS, fatto da un ragazzo francese...

47
00:02:37,288 --> 00:02:42,988
un ragazzo molto brillante, il cui nome è François Lionet.

48
00:02:42,988 --> 00:02:46,500
Questo fondamentalmente era caratterizzato da un DSL.

49
00:02:46,500 --> 00:02:50,240
Era uno strumento che usavo

50
00:02:50,240 --> 00:02:52,899
più di 20 anni fa.

51
00:02:52,899 --> 00:02:56,445
Il DSL è stato pensato per le animazioni...

52
00:02:56,445 --> 00:03:00,268
... è stato compilato in codice nativo.

53
00:03:00,268 --> 00:03:04,439
E l'insieme di interprete e compilatore e IDE

54
00:03:04,439 --> 00:03:10,624
per AMOS è stato completamente scritto in assembler.

55
00:03:10,624 --> 00:03:15,262
Questo ragazzo era veramente d'ispirazione per me.

56
00:03:15,262 --> 00:03:19,448
Nonostante i tanti linguaggi di programmazione

57
00:03:19,448 --> 00:03:22,985
e i tanti strumenti stiamo ancora cercando una nuova,

58
00:03:22,985 --> 00:03:25,197
migliore soluzione.

59
00:03:25,197 --> 00:03:28,035
I problemi che ci troviamo ad affrontare ogni giorno

60
00:03:28,035 --> 00:03:31,225
nel mondo del software sono ormai ben noti,

61
00:03:31,225 --> 00:03:34,345
ma continuiamo a sbatterci contro.

62
00:03:34,345 --> 00:03:37,582
Come complessità esplosiva... bloatware...

63
00:03:37,582 --> 00:03:40,334
No, non mi riferisco Java, naturalmente. (risate)

64
00:03:40,334 --> 00:03:42,225
Non pensiamo a Java. :-P

65
00:03:42,225 --> 00:03:44,769
Rallentamento delle prestazioni... Scatole nere, come può essere

66
00:03:44,769 --> 00:03:46,554
il software closed source, per esempio,

67
00:03:46,554 --> 00:03:49,598
che è spesso un grosso problema quando si cerca

68
00:03:49,598 --> 00:03:53,461
di risolvere i bug che non si possono raggiungere.

69
00:03:53,461 --> 00:03:57,872
Così, invece di spendere il nostro tempo a sbattere contro questi muri

70
00:03:57,872 --> 00:04:00,348
dovremmo divertirci a programmare,

71
00:04:00,348 --> 00:04:02,665
perché la programmazione è divertirsi.

72
00:04:02,665 --> 00:04:05,265
E questo è lo spirito che dovremmo avere quando

73
00:04:05,265 --> 00:04:07,852
ci mettiamo di fronte al nostro computer per lavorarci.

74
00:04:07,852 --> 00:04:11,400
E' come a quei tempi in cui la programmazione

75
00:04:11,400 --> 00:04:13,440
era *solo* divertimento.

76
00:04:13,440 --> 00:04:16,441
Da allora, sin dagli anni '80

77
00:04:16,441 --> 00:04:19,490
sono avvenuti un sacco di cambiamenti.

78
00:04:19,490 --> 00:04:21,716
E attualmente abbiamo due - credo -

79
00:04:21,716 --> 00:04:25,710
cambiamenti molto importanti nel mondo informatico.

80
00:04:25,710 --> 00:04:28,281
Il primo è l'aumento di potenza dei computer

81
00:04:28,281 --> 00:04:31,224
ottenuta aggiungendo nuovi core

82
00:04:31,224 --> 00:04:34,934
invece di aumentare la frequenza delle CPU.

83
00:04:34,934 --> 00:04:39,320
Questo ha implicazioni profonde per gli strumenti di programmazione.

84
00:04:39,320 --> 00:04:44,062
L'altra grande rivoluzione è che ora tutti noi

85
00:04:44,062 --> 00:04:46,772
stiamo passando ai dispositivi mobili.

86
00:04:46,772 --> 00:04:49,987
Il mercato sta cambiando molto velocemente.

87
00:04:49,987 --> 00:04:52,947
Quindi anche gli strumenti di programmazione devono adattarsi.

88
00:04:52,947 --> 00:04:56,540
Nonostante questi cambiamenti,

89
00:04:56,540 --> 00:04:59,593
in effetti stiamo ancora usando strumenti molto vecchi.

90
00:04:59,593 --> 00:05:03,677
Così ho preso solo i cinque più popolari

91
00:05:03,677 --> 00:05:07,004
linguaggi di programmazione dall'indice Tiobe...

92
00:05:07,004 --> 00:05:09,111
... il famoso indice.

93
00:05:09,111 --> 00:05:12,114
Sì, il C è ancora quello principale

94
00:05:12,114 --> 00:05:14,672
ed è stato in giro per quasi 40 anni ormai.

95
00:05:14,672 --> 00:05:18,748
E' un tempo piuttosto lungo per l'informatica!

96
00:05:18,748 --> 00:05:22,984
E il C non è assolutamente pensato per rispondere

97
00:05:22,984 --> 00:05:25,417
alle esigenze moderne dell'informatica.

98
00:05:25,417 --> 00:05:27,973
E se si guardano gli altri

99
00:05:27,973 --> 00:05:30,784
è quasi più o meno la stessa cosa.

100
00:05:30,784 --> 00:05:33,205
Fortunatamente per noi, alcune persone...

101
00:05:33,205 --> 00:05:36,211
... alcune persone molto rare erano consapevoli di questo

102
00:05:36,211 --> 00:05:41,981
e in grado di dare una risposta a questi problemi.

103
00:05:41,981 --> 00:05:45,129
Persone come Carl (indica Carl Sassenrath)

104
00:05:45,129 --> 00:05:47,309
che ha inventato Rebol... strumento fantastico.

105
00:05:47,309 --> 00:05:50,383
Probabilmente una delle più grandi invenzioni

106
00:05:50,383 --> 00:05:55,080
nel mondo della programmazione negli ultimi 20 anni.

107
00:05:55,080 --> 00:05:57,875
Così Rebol era una soluzione buona,

108
00:05:57,875 --> 00:06:00,598
o anche molto buona per un sacco di aspetti.

109
00:06:00,598 --> 00:06:01,978
*Ma non tutti.*

110
00:06:01,978 --> 00:06:05,352
Qualcosa che vorrei mostrare a Carl...

111
00:06:05,352 --> 00:06:08,556
... forse non l'ha visto?

112
00:06:08,556 --> 00:06:12,917
Le meraviglie che Rebol stava facendo, fino a poco tempo fa,

113
00:06:12,917 --> 00:06:17,277
c'era solo la comunità Rebol a tesserne le lodi

114
00:06:17,277 --> 00:06:20,004
e a cercare di spiegare alla gente come Rebol

115
00:06:20,004 --> 00:06:23,947
fosse uno strumento produttivo, ed espressivo.

116
00:06:23,947 --> 00:06:28,282
Ma recentemente uno studio scientifico ha cercato di misurare

117
00:06:28,282 --> 00:06:32,133
l'espressività dei linguaggi di programmazione.

118
00:06:32,133 --> 00:06:37,597
Così hanno fatto. E Rebol... *sorpresa* ! È il numero 3.

119
00:06:37,597 --> 00:06:41,516
Infatti: il numero 1 e il numero 2 sono DSL.

120
00:06:41,516 --> 00:06:44,526
Così indovinate chi è il primo? (risate)

121
00:06:44,526 --> 00:06:49,040
Questo conferma semplicemente qualcosa che tutti noi sapevamo

122
00:06:49,040 --> 00:06:51,141
fin dall'inizio.

123
00:06:51,141 --> 00:06:53,307
Rebol è uno strumento molto produttivo

124
00:06:53,307 --> 00:06:55,935
ed è ormai dimostrato. (risate)

125
00:06:55,935 --> 00:07:00,715
Ma Red cerca di andare oltre ciò che Rebol fornisce.

126
00:07:00,715 --> 00:07:03,002
Soprattutto in termini di implementazione

127
00:07:03,002 --> 00:07:06,519
non in termini di semantica del linguaggio o di sintassi.

128
00:07:06,519 --> 00:07:10,458
Ma più in termini di toolchain, implementazioni,

129
00:07:10,458 --> 00:07:13,065
e diffusione.

130
00:07:13,065 --> 00:07:16,160
Così che cosa è Red, veramente?

131
00:07:16,160 --> 00:07:17,653
Red è quello che io chiamo

132
00:07:17,653 --> 00:07:19,212
un *linguaggio di programmazione full-stack*

133
00:07:19,212 --> 00:07:22,317
Forse avete sentito parlare di sviluppatori full-stack?

134
00:07:22,317 --> 00:07:25,796
Ecco, questo è un linguaggio di programmazione full-stack.

135
00:07:25,796 --> 00:07:28,995
E probabilmente la sua caratteristica principale

136
00:07:28,995 --> 00:07:31,188
è che si tratta di una vera e propria

137
00:07:31,188 --> 00:07:33,287
soluzione di programmazione di uso generale.

138
00:07:33,287 --> 00:07:35,182
Ci sono molti linguaggi

139
00:07:35,182 --> 00:07:39,288
che *si presentano* come general purpose...

140
00:07:39,288 --> 00:07:43,358
... ma non sono tanto ampi quanto può essere Red.

141
00:07:43,358 --> 00:07:47,121
L'altra grande caratteristica di Red

142
00:07:47,121 --> 00:07:49,413
è che si tratta di un toolchain stand-alone

143
00:07:49,413 --> 00:07:52,050
quindi non dipendiamo dalla classica

144
00:07:52,050 --> 00:07:56,488
toolchain standard del C, abbiamo la nostra.

145
00:07:56,488 --> 00:07:59,648
Un altro aspetto importante di Red

146
00:07:59,648 --> 00:08:01,421
è la *libertà*.

147
00:08:01,421 --> 00:08:03,695
Fin dall'inizio la mia motivazione per Red

148
00:08:03,695 --> 00:08:07,334
era liberarsi di qualsiasi tipo di restrizione

149
00:08:07,334 --> 00:08:08,995
o qualsiasi tipo di limite.

150
00:08:08,995 --> 00:08:14,230
Voglio che gli utenti di Red si sentano così.

151
00:08:14,230 --> 00:08:18,165
Dunque Red è semplice da usare, *grazie a Rebol*...

152
00:08:18,165 --> 00:08:23,770
... ma Red non ha restrizioni arbitrarie.

153
00:08:23,770 --> 00:08:26,374
Cerchiamo di affrontare ogni possibile esigenza

154
00:08:26,374 --> 00:08:28,138
e ogni aspetto possibile, in modo che

155
00:08:28,138 --> 00:08:33,154
possa essere distribuito, portato su qualsiasi piattaforma di cui abbiamo bisogno.

156
00:08:33,154 --> 00:08:35,799
Inoltre, cosa molto importante in programmazione:

157
00:08:35,799 --> 00:08:39,061
è necessario sentirsi al controllo del proprio strumento.

158
00:08:39,061 --> 00:08:42,836
Spesso si utilizzano alcuni strumenti che possono essere potenti,

159
00:08:42,836 --> 00:08:44,878
ma non si controllano, perché

160
00:08:44,878 --> 00:08:47,250
non si capisce cosa sta succedendo dentro.

161
00:08:47,250 --> 00:08:48,730
Spesso perché sono scatole nere.

162
00:08:48,730 --> 00:08:52,495
O perché si appoggiano su una grande pila di strati

163
00:08:52,495 --> 00:08:56,225
di software quindi non si può capire

164
00:08:56,225 --> 00:08:57,921
cosa sta succedendo dentro.

165
00:08:57,921 --> 00:09:02,394
E un ultima cosa importante :-)

166
00:09:02,394 --> 00:09:04,521
è il *divertimento*. Sì, rivogliamo il divertimento.

167
00:09:04,521 --> 00:09:08,808
Alcune persone che hanno cercato di utilizzare Red

168
00:09:08,808 --> 00:09:11,465
o Red/System, dopo la compilazione e l'esecuzione

169
00:09:11,465 --> 00:09:14,262
con successo del loro primo programma

170
00:09:14,262 --> 00:09:16,175
sono tornate da me e hanno detto:

171
00:09:16,175 --> 00:09:17,367
"È grande, perché è divertente "

172
00:09:17,367 --> 00:09:21,281
"Ho appena provato, ha funzionato, ed è stato fantastico".

173
00:09:21,281 --> 00:09:25,132
La gente ha quella sensazione - quella di cui stavo parlando

174
00:09:25,132 --> 00:09:27,620
quella sensazione degli anni '80

175
00:09:27,620 --> 00:09:29,347
dove ti senti davvero al controllo

176
00:09:29,347 --> 00:09:31,121
del tuo strumento di programmazione.

177
00:09:31,121 --> 00:09:34,387
Quindi cercherò di spiegare cosa intendo per

178
00:09:34,387 --> 00:09:36,782
"Linguaggio di programmazione Full-Stack" e

179
00:09:36,782 --> 00:09:40,455
"Linguaggio di programmazione veramente General-Purpose".

180
00:09:40,455 --> 00:09:42,096
Così ho fatto questo schema:

181
00:09:42,096 --> 00:09:43,414
"Ambito di applicazione"

182
00:09:43,414 --> 00:09:46,570
per alcuni dei principali linguaggi di programmazione.

183
00:09:46,570 --> 00:09:49,393
Ad esempio, l'assembler è per driver

184
00:09:49,393 --> 00:09:52,019
e codice di livello molto basso.

185
00:09:52,019 --> 00:09:54,895
Si può vedere che Java è davvero limitato nella sua

186
00:09:54,895 --> 00:09:58,084
capacità di affrontare diversi livelli di astrazione.

187
00:09:58,084 --> 00:10:00,607
Ruby è piuttosto ampio;

188
00:10:00,607 --> 00:10:02,989
forse non va giù fino al sistema operativo?

189
00:10:02,989 --> 00:10:05,598
Non so se l'interfaccia di Ruby

190
00:10:05,598 --> 00:10:09,888
per chiamare le OS API è veramente buono o no.

191
00:10:09,888 --> 00:10:13,324
Rebol ha una portata piuttosto ampia.

192
00:10:13,324 --> 00:10:16,880
Rascal è un linguaggio di programmazione molto specifico.

193
00:10:16,880 --> 00:10:19,540
E' una specie di DSL,

194
00:10:19,540 --> 00:10:23,246
che è pensato per la scrittura di altri DSL.

195
00:10:23,246 --> 00:10:26,522
Così sta al livello meta-DSL.

196
00:10:26,522 --> 00:10:30,356
Allora, dove è Red su questa scala?

197
00:10:30,356 --> 00:10:33,954
Bene, Red mira a rispondere a tutte le esigenze

198
00:10:33,954 --> 00:10:37,272
dal basso verso l'alto.

199
00:10:37,272 --> 00:10:40,596
Perché io non voglio dover fare affidamento su un altro strumento.

200
00:10:40,596 --> 00:10:43,056
Voglio che il linguaggio di programmazione Red

201
00:10:43,056 --> 00:10:45,913
sia in grado di affrontare tutte le esigenze

202
00:10:45,913 --> 00:10:48,272
senza fare affidamento su qualcos'altro.

203
00:10:48,272 --> 00:10:51,236
Ora mi direte che è abbastanza impossibile

204
00:10:51,236 --> 00:10:53,307
fare un linguaggio che affronta

205
00:10:53,307 --> 00:10:56,058
una portata così ampia.

206
00:10:56,058 --> 00:10:58,201
E avreste ragione.

207
00:10:58,201 --> 00:11:00,771
Ma Red ha un asso nella manica.

208
00:11:00,771 --> 00:11:04,418
Red/System copre i livelli bassi

209
00:11:04,418 --> 00:11:06,604
e Red copre i livelli superiori.

210
00:11:06,604 --> 00:11:10,037
Essi sono integrati insieme

211
00:11:10,037 --> 00:11:11,702
e lavorano insieme.

212
00:11:11,702 --> 00:11:15,114
Red/System, in effetti, è un dialetto di Red.

213
00:11:15,114 --> 00:11:17,191
Si può usare separatamente

214
00:11:17,191 --> 00:11:20,112
o direttamente integrato totalmente in Red.

215
00:11:20,112 --> 00:11:25,446
Adesso diamo uno sguardo alle piattaforme che supportiamo.

216
00:11:25,446 --> 00:11:26,597
Innanzitutto circa il desktop,

217
00:11:26,597 --> 00:11:30,755
supportiamo i 3 classici principali.

218
00:11:30,755 --> 00:11:34,424
Supportiamo inoltre alcuni

219
00:11:34,424 --> 00:11:36,693
sistemi operativi aggiuntivi come Syllable.

220
00:11:36,693 --> 00:11:38,829
Vorremmo supportare FreeBSD,

221
00:11:38,829 --> 00:11:41,350
ma abbiamo avuto alcuni problemi di basso livello

222
00:11:41,350 --> 00:11:45,053
e nessun esperto di FreeBSD tra noi

223
00:11:45,053 --> 00:11:48,456
per risolverli, quindi per ora è un po' in stallo.

224
00:11:48,456 --> 00:11:52,454
Ma potremmo probabilmente ottenere Red portato

225
00:11:52,454 --> 00:11:54,855
su FreeBSD rapidamente.

226
00:11:54,855 --> 00:11:57,687
Poi vogliamo anche affrontare

227
00:11:57,687 --> 00:12:00,774
il mercato embedded, iniziando con Android,

228
00:12:00,774 --> 00:12:02,771
che già supportiamo.

229
00:12:02,771 --> 00:12:04,787
Il prossimo sarà iOS.

230
00:12:04,787 --> 00:12:07,905
E giriamo già su Raspberry Pi

231
00:12:07,905 --> 00:12:10,367
che sta diventando molto popolare.

232
00:12:10,367 --> 00:12:14,720
Credo Bo farà alcune dimostrazioni

233
00:12:14,720 --> 00:12:17,929
forse domani.

234
00:12:17,929 --> 00:12:22,868
Abbiamo anche un port sperimentale su Arduino

235
00:12:22,868 --> 00:12:27,030
Abbiamo iniziato con AVR 8-bit.

236
00:12:27,030 --> 00:12:30,044
Ma è un esperimento per ora,

237
00:12:30,044 --> 00:12:32,895
perché altre schede sono in arrivo,

238
00:12:32,895 --> 00:12:36,014
come le schede a 32 bit o Raspberry Pi.

239
00:12:36,014 --> 00:12:41,790
Così il supporto 8-bit forse non è la cosa da fare adesso.

240
00:12:41,790 --> 00:12:45,320
Vogliamo anche supportare le macchine virtuali.

241
00:12:45,320 --> 00:12:49,753
Vogliamo essere in grado di connetterci a .NET

242
00:12:49,753 --> 00:12:53,139
alla JVM, e a JavaScript.

243
00:12:53,139 --> 00:12:55,602
Ci sono fondamentalmente due metodi

244
00:12:55,602 --> 00:12:56,467
per raggiungere questo obiettivo.

245
00:12:56,467 --> 00:13:00,940
Possiamo avere un bridge, tenendo Red come è ora

246
00:13:00,940 --> 00:13:06,438
e usando il bridge con queste macchine virtuali.

247
00:13:06,438 --> 00:13:08,746
Oppure possiamo sviluppare un nuovo backend

248
00:13:08,746 --> 00:13:11,146
per Red e Red/System

249
00:13:11,146 --> 00:13:13,710
per essere in grado di compilare direttamente il bytecode

250
00:13:13,710 --> 00:13:15,817
di queste macchine virtuali.

251
00:13:15,817 --> 00:13:17,905
Così abbiamo queste due opzioni.

252
00:13:17,905 --> 00:13:21,645
Abbiamo iniziato facendo alcuni bridge per la JVM.

253
00:13:21,645 --> 00:13:26,405
Cercheremo di scegliere ogni volta

254
00:13:26,405 --> 00:13:30,067
la soluzione giusta - la migliore per lo scopo.

255
00:13:30,067 --> 00:13:33,188
Così adesso stiamo facendo il bridge con la JVM.

256
00:13:33,188 --> 00:13:37,997
Ma probabilmente compileremo per JavaScript direttamente.

257
00:13:37,997 --> 00:13:41,551
Abbiamo asm.js adesso, quindi abbiamo

258
00:13:41,551 --> 00:13:45,325
una piattaforma molto interessante da supportare.

259
00:13:45,325 --> 00:13:47,584
Mi aspetto che Red e Red/System

260
00:13:47,584 --> 00:13:50,755
girino abbastanza velocemente su di essa.

261
00:13:50,755 --> 00:13:53,753
Più praticamente, solo un'altra visione di come funziona

262
00:13:53,753 --> 00:13:57,242
Così abbiamo Red: un file binario.

263
00:13:57,242 --> 00:14:01,118
Si scarica e si hanno tutte queste caratteristiche.

264
00:14:01,118 --> 00:14:04,756
Si può eseguire uno script Red direttamente dalla memoria.

265
00:14:04,756 --> 00:14:08,124
Si può compilarlo su un file eseguibile.

266
00:14:08,124 --> 00:14:12,805
Si può cross-compilarlo....

267
00:14:12,805 --> 00:14:15,324
torneremo in seguito su questa funzione.

268
00:14:15,324 --> 00:14:19,071
Si possono anche compilare direttamente script Red/System,

269
00:14:19,071 --> 00:14:22,291
se non si desidera utilizzare il livello Red,

270
00:14:22,291 --> 00:14:26,063
ma si vuole scrivere un'applicazione di basso livello.

271
00:14:26,063 --> 00:14:29,955
E ora si possono anche compilare le librerie condivise

272
00:14:29,955 --> 00:14:32,948
il che apre la porta per la diffusione di Red

273
00:14:32,948 --> 00:14:36,582
inserendolo ovunque possiamo.

274
00:14:36,582 --> 00:14:39,954
Si può anche avviare Red in una modalità console

275
00:14:39,954 --> 00:14:42,206
in modo da avere una console Red.

276
00:14:42,206 --> 00:14:45,499
Dunque, cross- compilation... Red è ora in grado di cross-compilare

277
00:14:45,499 --> 00:14:49,442
ad altri sistemi, da qualsiasi sistema a un altro.

278
00:14:49,442 --> 00:14:52,731
In realtà è in grado di compilare da qualsiasi piattaforma

279
00:14:52,731 --> 00:14:56,113
dove Rebol giri a qualsiasi altra piattaforma.

280
00:14:56,113 --> 00:15:00,808
Per ottenere questo non c'è bisogno di un HOWTO

281
00:15:00,808 --> 00:15:02,363
Non c'è bisogno di un tutorial.

282
00:15:02,363 --> 00:15:04,788
Non c'è bisogno di cercare in rete

283
00:15:04,788 --> 00:15:07,182
per sapere come fare.

284
00:15:07,182 --> 00:15:10,293
È sufficiente passare un comando " -t " e l' ID di destinazione

285
00:15:10,293 --> 00:15:11,777
e questo è tutto.

286
00:15:11,777 --> 00:15:16,750
Un ID di destinazione è solo una voce in un file di configurazione

287
00:15:16,750 --> 00:15:21,988
di un semplice dialetto Red, dove elenchiamo semplicemente

288
00:15:21,988 --> 00:15:26,132
alcune opzioni per la piattaforma di destinazione.

289
00:15:26,132 --> 00:15:31,110
Al presente abbiamo questa lista di circa 8 obiettivi

290
00:15:31,110 --> 00:15:33,602
così possiamo cross-compilare da uno qualsiasi

291
00:15:33,602 --> 00:15:35,828
a qualsiasi altro, purché Rebol

292
00:15:35,828 --> 00:15:40,124
giri sulla piattaforma di origine.

293
00:15:40,124 --> 00:15:41,557
Quindi, come potete vedere stiamo supportando principalmente

294
00:15:41,557 --> 00:15:45,594
le piattaforme basate su x86 e ARM.

295
00:15:45,594 --> 00:15:49,412
Per andare un po' più in profondità all'interno della toolchain

296
00:15:49,412 --> 00:15:51,796
abbiamo diverse parti.

297
00:15:51,796 --> 00:15:54,506
Abbiamo la coppia classica: compilatore, linker.

298
00:15:54,506 --> 00:16:01,832
Il compilatore è in grado di gestire principalmente

299
00:16:01,832 --> 00:16:07,115
questi due backend, x86 e ARM.

300
00:16:07,115 --> 00:16:11,919
Ma abbiamo intenzione di estenderlo a supportare ARMv7

301
00:16:11,919 --> 00:16:17,236
in modalità "thumb" e piattaforme a 64 bit.

302
00:16:17,236 --> 00:16:22,287
Ci sarà anche da aggiungere i backend macchina virtuale.

303
00:16:22,287 --> 00:16:26,207
Come JavaScript, JVM bytecode... Dex per Dalvik

304
00:16:26,207 --> 00:16:30,153
come alternativa per la JVM su piattaforma Android.

305
00:16:30,153 --> 00:16:34,462
E MSIL è il nome del bytecode

306
00:16:34,462 --> 00:16:37,043
per la piattaforma .NET.

307
00:16:37,043 --> 00:16:39,737
Il Linker supporta i principali formati di file.

308
00:16:39,737 --> 00:16:43,532
Lo estenderemo per supportare anche le librerie statiche.

309
00:16:43,532 --> 00:16:46,418
Così si potrà compilare un programma Red

310
00:16:46,418 --> 00:16:51,578
come libreria statica in modo da poterlo poi linkare

311
00:16:51,578 --> 00:16:55,233
con un altra toolchain esterna, tipo quella del C.

312
00:16:55,233 --> 00:16:59,655
Questo è un modo alternativo per diffondere Red

313
00:16:59,655 --> 00:17:02,448
e mettere in grado le persone di utilizzare Red

314
00:17:02,448 --> 00:17:04,962
in toolchain o applicazioni di terze parti.

315
00:17:04,962 --> 00:17:09,242
E scendiamo anche al livello del kernel

316
00:17:09,242 --> 00:17:14,305
vi forniremo supporto per il building

317
00:17:14,305 --> 00:17:19,234
dei driver del kernel, o anche interi sistemi operativi,

318
00:17:19,234 --> 00:17:21,787
direttamente da Red.

319
00:17:21,787 --> 00:17:24,199
E attualmente abbiamo il supporto sperimentale

320
00:17:24,199 --> 00:17:27,504
per i driver del kernel di Windows, già funzionanante.

321
00:17:27,504 --> 00:17:31,980
Se ci sono qui degli sviluppatori di driver del kernel

322
00:17:31,980 --> 00:17:34,213
ci possiamo divertire con esso. :-P

323
00:17:34,213 --> 00:17:37,458
Ultimo punto: qualcosa che non esiste,

324
00:17:37,458 --> 00:17:40,247
per quanto ne so, nella classica toolchain C:

325
00:17:40,247 --> 00:17:42,530
avremo un livello packager

326
00:17:42,530 --> 00:17:46,044
che non è ancora implementato, ma lo sarà presto.

327
00:17:46,044 --> 00:17:51,589
Inizieremo con il backend Android APK.

328
00:17:51,589 --> 00:17:54,697
L'obiettivo di questo livello

329
00:17:54,697 --> 00:17:58,850
è solo quello di prendere diversi file e confezionarli

330
00:17:58,850 --> 00:18:03,445
e formattarli comd la piattaforma di destinazione richiede.

331
00:18:03,445 --> 00:18:06,426
Quindi supporteremo Android, supporteremo iOS.

332
00:18:06,426 --> 00:18:08,997
Ma questo packager potrebbe anche essere utilizzato

333
00:18:08,997 --> 00:18:13,409
per il confezionamento di applicazioni web.

334
00:18:13,409 --> 00:18:17,371
Così come Java fa per il formato .WAR

335
00:18:17,371 --> 00:18:20,196
che ha capacità molto interessanti

336
00:18:20,196 --> 00:18:23,489
come semplificare la distribuzione di applicazioni web

337
00:18:23,489 --> 00:18:25,276
e di essere in grado di versionarli

338
00:18:25,276 --> 00:18:27,050
o fare il rollback di distribuzione,

339
00:18:27,050 --> 00:18:29,342
che sono grand belle cose da avere.

340
00:18:29,342 --> 00:18:31,027
Un altro aspetto della toolchain

341
00:18:31,027 --> 00:18:32,544
è che attualmente la toolchain

342
00:18:32,544 --> 00:18:36,774
fa il bootstrap in Rebol 2.

343
00:18:36,774 --> 00:18:40,686
Siamo già funzionando così da due anni.

344
00:18:40,686 --> 00:18:46,907
Ma il Red finale avrà un compilatore JIT.

345
00:18:46,907 --> 00:18:50,717
Per avere un compilatore JIT dobbiamo diventare self-hosted.

346
00:18:50,717 --> 00:18:54,347
Quindi abbiamo bisogno di avere Red scritto in Red.

347
00:18:54,347 --> 00:18:58,587
È l'unico modo per ottenere un compilatore JIT adeguato.

348
00:18:58,587 --> 00:19:03,543
Dovremo probabilmente lavorare su questo il prossimo anno.

349
00:19:03,543 --> 00:19:07,550
Ho un paio di diapositive sul linguaggio Red stesso.

350
00:19:07,550 --> 00:19:10,796
Ma non voglio entrare in troppi dettagli

351
00:19:10,796 --> 00:19:13,394
perché ci vorrebbe troppo tempo.

352
00:19:13,394 --> 00:19:18,018
La prima cosa da capire sul linguaggio Red

353
00:19:18,018 --> 00:19:21,098
è che è molto simile a Rebol.

354
00:19:21,098 --> 00:19:26,585
Ha alcune delle principali caratteristiche di Rebol

355
00:19:26,585 --> 00:19:31,588
come scoping di definizione e binding dinamico.

356
00:19:31,588 --> 00:19:37,178
C'è anche la possibilità di programmare in Red

357
00:19:37,178 --> 00:19:40,106
utilizzando qualunque paradigma si voglia.

358
00:19:40,106 --> 00:19:43,031
*"Paradigma-neutrale" * è un'espressione

359
00:19:43,031 --> 00:19:46,673
di Gabriele (Santilli) e mi piace molto

360
00:19:46,673 --> 00:19:50,013
perché esprime molto bene questa capacità

361
00:19:50,013 --> 00:19:53,878
di non essere vincolato ad un paradigma specifico.

362
00:19:55,318 --> 00:19:59,298
Una differenza tra Red e Rebol

363
00:19:59,298 --> 00:20:05,376
è che in Red è possibile facoltativamente dare tipo alle variabili locali

364
00:20:05,376 --> 00:20:09,756
e anche al valore di ritorno

365
00:20:09,756 --> 00:20:12,147
delle funzioni.

366
00:20:12,147 --> 00:20:17,048
In Rebol questo non ha molto senso

367
00:20:17,048 --> 00:20:25,102
perché è un interprete, e non ha importanza.

368
00:20:25,102 --> 00:20:27,874
Ma per un compilatore, questo ha una grande importanza.

369
00:20:27,874 --> 00:20:33,604
Perché annotare i tipi in una funzione

370
00:20:33,604 --> 00:20:37,791
permette al compilatore di generare

371
00:20:37,791 --> 00:20:43,616
codice molto più specializzato, più veloce ed efficiente

372
00:20:43,616 --> 00:20:46,818
che senza le annotazioni.

373
00:20:47,728 --> 00:20:53,186
Red è "facoltativamente tipizzato". Cioè è possibile tipizzare o no.

374
00:20:53,186 --> 00:20:56,989
Dipende dalle vostre esigenze, o dal modo in cui programmate.

375
00:20:56,989 --> 00:20:59,333
Così si può usare il modo Rebol

376
00:20:59,333 --> 00:21:01,619
che sarà molto flessibile.

377
00:21:01,619 --> 00:21:06,168
Ma si otterranno prestazioni più lente.

378
00:21:06,168 --> 00:21:08,549
Oppure si può fare nel modo statico

379
00:21:08,549 --> 00:21:10,581
in cui si tipizza tutto

380
00:21:10,581 --> 00:21:13,702
e il compilatore potrà fare più controlli di tipo

381
00:21:13,702 --> 00:21:16,969
in modo da ottenere alcuni avvisi o alcuni errori

382
00:21:16,969 --> 00:21:21,230
in fase di compilazione, invece che in run-time.

383
00:21:21,230 --> 00:21:28,353
Comunque, se non si utilizzano le annotazioni di tipo

384
00:21:28,353 --> 00:21:31,687
il compilatore sarà in grado in alcuni casi

385
00:21:31,687 --> 00:21:34,141
di fare qualche inferenza di tipo.

386
00:21:34,141 --> 00:21:36,654
Cioè sarà in grado di indovinare i tipi per voi.

387
00:21:36,654 --> 00:21:41,093
Ma, siccome Red, come Rebol, è un linguaggio molto dinamico

388
00:21:41,093 --> 00:21:48,734
la misura in cui il motore di inferenza

389
00:21:48,734 --> 00:21:53,581
può intuire i tipi è abbastanza limitato.

390
00:21:53,581 --> 00:21:56,756
Quindi, sarà un po' di aiuto, ma non molto.

391
00:21:56,756 --> 00:22:01,167
Naturalmente abbiamo il supporto Unicode.

392
00:22:01,167 --> 00:22:04,623
Il codice sorgente di Red è UTF-8.

393
00:22:04,623 --> 00:22:09,567
Forniremo alcuni codec esterni per altre codifiche.

394
00:22:09,567 --> 00:22:16,728
Internamente, alla base, Red memorizza e gestisce

395
00:22:16,728 --> 00:22:20,036
stringhe Unicode, come fa Python

396
00:22:20,036 --> 00:22:22,719
nelle ultime versioni.

397
00:22:22,719 --> 00:22:29,671
Così la dimensione interna è fissa,

398
00:22:29,671 --> 00:22:35,382
ma può occupare da 1 byte fino a 4 byte

399
00:22:35,382 --> 00:22:37,921
per codepoint.

400
00:22:37,921 --> 00:22:40,144
E il sistema si adatterà automaticamente

401
00:22:40,144 --> 00:22:43,224
e regolerà le dimensioni secondo l'input

402
00:22:43,224 --> 00:22:48,908
e le modifiche che si stanno facendo sulla string.

403
00:22:48,908 --> 00:22:54,977
Un'altro aspetto che è molto importante in Red

404
00:22:54,977 --> 00:22:57,640
è il supporto di concorrenza.

405
00:22:57,640 --> 00:23:00,108
Ma attualmente non è implementato

406
00:23:00,108 --> 00:23:04,207
dunque non entrerò nei dettagli al riguardo.

407
00:23:04,207 --> 00:23:09,102
Vogliamo supportare due cose principali:

408
00:23:09,102 --> 00:23:11,330
vogliamo supportare il parallelismo dei task

409
00:23:11,330 --> 00:23:15,331
in modo da poter eseguire più thread di codice

410
00:23:15,331 --> 00:23:18,367
in parallelo usando core multipli.

411
00:23:18,367 --> 00:23:21,891
Probabilmente useremo le astrazioni Actor.

412
00:23:21,891 --> 00:23:26,693
Ma ci sono altre astrazioni

413
00:23:26,693 --> 00:23:31,042
che dall'inizio del progetto Red

414
00:23:31,042 --> 00:23:34,926
stanno ingranando molto. Come le routine Go,

415
00:23:34,926 --> 00:23:38,981
che stanno diventando un punto determinante

416
00:23:38,981 --> 00:23:40,645
per il linguaggio Go.

417
00:23:40,645 --> 00:23:43,082
Ecco, questo è qualcosa che dovremmo prendere in considerazione

418
00:23:43,082 --> 00:23:45,725
anche per Red, forse...

419
00:23:45,725 --> 00:23:48,651
in aggiunta o in sostituzione di attori

420
00:23:48,651 --> 00:23:50,974
e altri tipi di astrazioni.

421
00:23:50,974 --> 00:23:54,765
Così, quando arriveremo al punto di implementare

422
00:23:54,765 --> 00:23:57,311
il supporto di concorrenza dovremo rivedere

423
00:23:57,311 --> 00:23:59,900
tutte le scelte progettuali e vedere

424
00:23:59,900 --> 00:24:03,665
se possiamo aggiornarle copiando

425
00:24:03,665 --> 00:24:06,840
alcune altre strategie di successo.

426
00:24:06,840 --> 00:24:09,047
Vogliamo anche avere un certo livello di

427
00:24:09,047 --> 00:24:13,712
parallelismo dati utilizzando SIMD

428
00:24:13,712 --> 00:24:16,582
o elaborazione multicore.

429
00:24:16,582 --> 00:24:19,851
In pratica utilizzeremo la possibilità

430
00:24:19,851 --> 00:24:25,917
di parallelizzare l'elaborazione delle serie Red.

431
00:24:25,917 --> 00:24:30,758
Vorremmo inoltre affrontare qualcosa

432
00:24:30,758 --> 00:24:33,476
che Rebol attualmente in realtà non affronta

433
00:24:33,476 --> 00:24:36,231
cioè: come si fa a realizzare un dialetto?

434
00:24:36,231 --> 00:24:38,956
O come si fa a realizzare un DSL?

435
00:24:38,956 --> 00:24:41,438
Rebol è fantastico per questo -

436
00:24:41,438 --> 00:24:44,368
è probabilmente uno dei migliori strumenti per farlo

437
00:24:44,368 --> 00:24:45,658
perché ha PARSE e perché

438
00:24:45,658 --> 00:24:48,084
ha alcune caratteristiche interessanti

439
00:24:48,084 --> 00:24:50,101
che lo rendono una buona scelta per questo.

440
00:24:50,101 --> 00:24:54,911
In ogni caso costruire un DSL o costruire un dialetto

441
00:24:54,911 --> 00:24:57,186
non è una cosa facile.

442
00:24:57,186 --> 00:24:59,774
Perché è necessario progettarlo prima.

443
00:24:59,774 --> 00:25:01,425
Questo è già un sacco di lavoro.

444
00:25:01,425 --> 00:25:03,427
E poi bisogna implementarlo.

445
00:25:03,427 --> 00:25:07,113
E implementare un DSL o un dialetto

446
00:25:07,113 --> 00:25:11,151
è implementare un interprete o un compilatore.

447
00:25:11,151 --> 00:25:17,524
Per questo si è quasi lasciati soli con il codice.

448
00:25:17,524 --> 00:25:20,462
Non si ha veramente un framework

449
00:25:20,462 --> 00:25:22,134
per farlo.

450
00:25:22,134 --> 00:25:25,585
Ma è possibile sfruttare le qualità

451
00:25:25,585 --> 00:25:27,439
del linguaggio Rebol in Red

452
00:25:27,439 --> 00:25:29,507
o forse anche in Rebol

453
00:25:29,507 --> 00:25:32,431
per fare una sorta di meta-DSL

454
00:25:32,431 --> 00:25:38,218
che permetterà di essere molto più produttivi

455
00:25:38,218 --> 00:25:40,920
e darà un framework

456
00:25:40,920 --> 00:25:44,260
per la creazione di nuovi dialetti e nuovi DSL.

457
00:25:44,260 --> 00:25:47,156
Fondamentalmente sarà qualcosa di simile

458
00:25:47,156 --> 00:25:50,105
a una versione più alto livello di PARSE.

459
00:25:50,105 --> 00:25:52,557
Si può pensare, per esempio,

460
00:25:52,557 --> 00:25:59,457
di avere PARSE con un ciclo di eventi

461
00:25:59,457 --> 00:26:03,732
ma il ciclo degli eventi sarà nascosto.

462
00:26:03,732 --> 00:26:07,914
Qualcosa di simile a quello che fa Visual Basic.

463
00:26:07,914 --> 00:26:11,544
E ci sarà solo da implementare gli eventi

464
00:26:11,544 --> 00:26:17,351
per creare il DSL come interprete o compilatore.

465
00:26:17,351 --> 00:26:26,170
Quindi cosa fa il compilatore Red?

466
00:26:26,170 --> 00:26:30,786
Il compilatore converte il codice Red

467
00:26:30,786 --> 00:26:34,944
in Red/System, che è il livello inferiore.

468
00:26:34,944 --> 00:26:40,093
Volevo solo mostrare a cosa assomiglia.

469
00:26:40,093 --> 00:26:45,535
Quindi, se prendiamo una semplice espressione Red,

470
00:26:45,535 --> 00:26:48,493
il compilatore Red la analizza

471
00:26:48,493 --> 00:26:53,884
e utilizza una stack abstraction per collocare gli argomenti

472
00:26:53,884 --> 00:26:58,480
Di fatto utilizza due stack: uno per le chiamate

473
00:26:58,480 --> 00:27:01,819
e uno per gli argomenti.

474
00:27:01,819 --> 00:27:05,361
Poi l'emettitore produrrà codice Red/System

475
00:27:05,361 --> 00:27:08,363
basato su quello.

476
00:27:08,363 --> 00:27:10,782
Quindi, quello che si vede sul lato destro

477
00:27:10,782 --> 00:27:14,350
è l'uscita Red/System per l'espressione

478
00:27:14,350 --> 00:27:18,061
che chiama le runtime API di Red.

479
00:27:22,651 --> 00:27:28,334
Un altro aspetto singolare del compilatore Red

480
00:27:28,334 --> 00:27:29,406
e del linguaggio Red

481
00:27:29,406 --> 00:27:34,169
è che combina diversi tipi di approcci

482
00:27:34,169 --> 00:27:37,846
il che è qualcosa di abbastanza unico, credo.

483
00:27:37,846 --> 00:27:41,156
Quindi, in pratica si ha un compilatore statico.

484
00:27:41,156 --> 00:27:44,538
Questo compilatore statico genererà codice

485
00:27:44,538 --> 00:27:46,584
con un interprete all'interno, e domani

486
00:27:46,584 --> 00:27:51,606
un JIT compiler incorporato all'interno del file eseguibile.

487
00:27:51,606 --> 00:27:58,368
Tutte queste tre parti saranno in grado di lavorare insieme

488
00:27:58,368 --> 00:28:02,334
in un modo molto collaborativo.

489
00:28:02,334 --> 00:28:05,191
Così, per esempio, il codice compilato

490
00:28:05,191 --> 00:28:08,428
può chiamare l'interprete interno

491
00:28:08,428 --> 00:28:12,551
che a sua volta può chiamare di nuovo il codice compilato.

492
00:28:12,551 --> 00:28:16,189
Stessa cosa per il compilatore JIT.

493
00:28:16,189 --> 00:28:19,973
E' un po' astratto, ma è possibile mostrare al termine

494
00:28:19,973 --> 00:28:21,707
della presentazione una diapositiva

495
00:28:21,707 --> 00:28:23,904
con un caso pratico di tale approccio.

496
00:28:23,904 --> 00:28:28,901
In effetti, un tale approccio è uno strumento molto potente 

497
00:28:28,901 --> 00:28:35,136
per risolvere casi semantici molto complessi.

498
00:28:35,136 --> 00:28:39,575
Ad esempio, la compilazione di codice simbolico,

499
00:28:39,575 --> 00:28:42,229
che è qualcosa di molto difficile da realizzare.

500
00:28:42,229 --> 00:28:43,740
Ma se si combinano approcci diversi

501
00:28:43,740 --> 00:28:49,758
è possibile trovare una soluzione molto efficiente.

502
00:28:49,758 --> 00:28:54,407
Questo è solo un esempio molto semplice

503
00:28:54,407 --> 00:29:00,583
di come appare il codice Red.

504
00:29:00,583 --> 00:29:03,399
È lo stesso principio come in Rebol

505
00:29:03,399 --> 00:29:08,492
cioè hai un marcatore che è [Red]

506
00:29:08,492 --> 00:29:13,355
seguito da un blocco che costituisce un header

507
00:29:13,355 --> 00:29:17,254
e il tuo codice va dopo.

508
00:29:17,254 --> 00:29:19,921
Hello World è semplicemente [print "Hello World"]

509
00:29:19,921 --> 00:29:22,312
come in Rebol, e il resto del codice

510
00:29:22,312 --> 00:29:26,336
probabilmente assomiglia molto a Rebol,

511
00:29:26,336 --> 00:29:32,270
tranne forse per il [return: [type!]],

512
00:29:32,270 --> 00:29:36,908
che è facoltativo, ma è il tipo di

513
00:29:36,908 --> 00:29:40,409
tipizzazione opzionale di cui stavo parlando poco prima.

514
00:29:40,409 --> 00:29:43,389
Ecco, avete qui un esempio.

515
00:29:43,389 --> 00:29:48,196
Non è obbligatorio metterlo, ma se lo si mette

516
00:29:48,196 --> 00:29:54,758
il compilatore genererà un codice migliore, più veloce.

517
00:29:54,758 --> 00:29:59,006
Ora uno sguardo un po' più dettagliato

518
00:29:59,006 --> 00:30:02,905
sulle diverse parti interne di Red,

519
00:30:02,905 --> 00:30:05,640
in modo da ottenere un quadro migliore di come

520
00:30:05,640 --> 00:30:09,472
tutti questi elementi sono correlati.

521
00:30:09,472 --> 00:30:13,971
Quindi, se partiamo dal ragazzo sulla destra

522
00:30:13,971 --> 00:30:17,047
abbiamo uno script front-end da riga di comando

523
00:30:17,047 --> 00:30:19,852
che è scritto attualmente in Rebol2

524
00:30:19,852 --> 00:30:25,527
e dietro di esso abbiamo i due stack

525
00:30:25,527 --> 00:30:28,351
per i due compilatori. Uno per Red, che è

526
00:30:28,351 --> 00:30:32,604
più breve perché emette solo codice per Red/System.

527
00:30:32,604 --> 00:30:34,311
E uno per Red/System

528
00:30:34,311 --> 00:30:36,720
che va giù al packager

529
00:30:36,720 --> 00:30:41,424
in modo che esso possa emettere e produrre file binari.

530
00:30:41,424 --> 00:30:47,027
Tutto ciò è la toolchain scritta in Rebol 2.

531
00:30:47,027 --> 00:30:52,304
Sul lato sinistro, si ha il runtime Red.

532
00:30:52,304 --> 00:30:55,586
Che è un pezzo di codice piuttosto grande,

533
00:30:55,586 --> 00:30:59,651
di fatto probabilmente più grande rispetto al lato opposto.

534
00:30:59,651 --> 00:31:02,964
E che è scritto in Red/System.

535
00:31:02,964 --> 00:31:06,914
Quindi troverete tutto il potere reale su quel lato,

536
00:31:06,914 --> 00:31:08,649
ad esempio, tutti i tipi di dati,

537
00:31:08,649 --> 00:31:12,104
tutti i nativi, il mezzanine code,

538
00:31:12,104 --> 00:31:16,600
l'interprete, i bridge - come quello Java

539
00:31:16,600 --> 00:31:19,025
che è già disponibile.

540
00:31:19,025 --> 00:31:23,058
Il gestore della memoria e le interfacce di basso livello

541
00:31:23,058 --> 00:31:26,485
per le parti sottostanti.

542
00:31:26,485 --> 00:31:28,829
Così, per esempio, si ha l'accesso diretto

543
00:31:28,829 --> 00:31:31,993
alle API del sistema operativo, ma anche al kernel.

544
00:31:31,993 --> 00:31:34,001
Su Linux si possono fare direttamente le syscall.

545
00:31:34,001 --> 00:31:38,340
E, se necessario, si può andare anche giù

546
00:31:38,340 --> 00:31:41,869
verso l'hardware e chiamare funzioni di livello molto basso.

547
00:31:44,599 --> 00:31:46,625
Forse ho tralasciato la console Red

548
00:31:46,625 --> 00:31:49,985
che è pure scritta in Red

549
00:31:49,985 --> 00:31:52,946
e Red/System per le parti di basso livello.

550
00:31:53,816 --> 00:31:57,120
Circa Red/System... Ho una piccola presentazione

551
00:31:57,120 --> 00:32:01,142
domani specificamente su Red/System, perché

552
00:32:01,142 --> 00:32:06,082
è una cosa di genere nuovo in Red rispetto al Rebol.

553
00:32:06,082 --> 00:32:08,541
Ora solo una diapositiva su Red/System

554
00:32:08,541 --> 00:32:10,120
per darvi giusto una panoramica.

555
00:32:10,120 --> 00:32:16,748
Fondamentalmente è solo un tipo di linguaggio C-level,

556
00:32:16,748 --> 00:32:20,078
ma con una sintassi Red.

557
00:32:20,078 --> 00:32:22,760
Così ci si sente spesso come programmando in Red

558
00:32:22,760 --> 00:32:29,827
ma con tipi di dati e azioni di livello molto basso.

559
00:32:29,827 --> 00:32:32,630
È compilato staticamente.

560
00:32:32,630 --> 00:32:35,956
Attualmente non è per niente ottimizzato. :-)

561
00:32:35,956 --> 00:32:40,988
Ma è solo 4 volte più lento del C ottimizzato

562
00:32:40,988 --> 00:32:43,849
compilato con "-O2".

563
00:32:43,849 --> 00:32:47,674
Quindi è abbastanza buono, in realtà è molto buono.

564
00:32:47,674 --> 00:32:51,224
Perché quando aggiungeremo l'ottimizzazione

565
00:32:51,224 --> 00:32:53,398
saremo molto, molto vicino al C.

566
00:32:53,398 --> 00:32:57,362
Probabilmente non lo batteremo, ma non è questo l'obiettivo.

567
00:32:57,362 --> 00:33:00,014
Ma gli andremo molto, molto vicino.

568
00:33:00,014 --> 00:33:05,041
Così Red/System sarà davvero un valida alternativa al C.

569
00:33:05,041 --> 00:33:09,334
E fa già miracoli in qualche

570
00:33:09,334 --> 00:33:11,936
elaborazione di immagini per esempio,

571
00:33:11,936 --> 00:33:15,680
che Bo (Lechnowsky) mostrerà domani.

572
00:33:15,680 --> 00:33:17,968
Qualcosa che il linguaggio C non ha

573
00:33:17,968 --> 00:33:22,310
e molti linguaggi di basso livello non hanno:

574
00:33:22,310 --> 00:33:24,792
Red/System dispone di namespace,

575
00:33:24,792 --> 00:33:27,024
che sono qualcosa come i contesti in Rebol

576
00:33:27,024 --> 00:33:33,586
ma molto statici, quindi stiamo usando la keyword CONTEXT

577
00:33:33,586 --> 00:33:35,909
per dichiararli anche in Red/System.

578
00:33:35,909 --> 00:33:38,936
E si può anche utilizzare la keyword WITH

579
00:33:38,936 --> 00:33:43,428
per mettere una parte del codice dentro un contesto 

580
00:33:43,428 --> 00:33:47,121
qualcosa come le dichiarazioni in altre linguaggi.

581
00:33:47,121 --> 00:33:52,155
In Red/System abbiamo un sistema di tipi molto limitato.

582
00:33:52,155 --> 00:34:00,763
Abbiamo nove tipi.

583
00:34:00,763 --> 00:34:05,467
Cioè sostanzialmente gli stessi tipi di dati del C.

584
00:34:05,467 --> 00:34:11,372
Il datatype funzione non è completamente first-class

585
00:34:11,372 --> 00:34:16,155
Ho esitato molto su questo, perché...

586
00:34:16,155 --> 00:34:19,723
se lo rendessi un tipo completamente first-class

587
00:34:19,723 --> 00:34:22,571
la gente comincerebbe a chiedermi

588
00:34:22,571 --> 00:34:24,925
di rendere Red/System un linguaggio funzionale.

589
00:34:24,925 --> 00:34:27,986
Il che è possibile ma non è l'obiettivo.

590
00:34:27,986 --> 00:34:32,540
Non serve a nulla, quindi sono abbastanza riluttante

591
00:34:32,540 --> 00:34:37,835
ad aggiungere nuove funzionalità su quel tipo di dati.

592
00:34:37,835 --> 00:34:40,324
Abbiamo inferenza di tipo,

593
00:34:40,324 --> 00:34:42,395
in modo da non dover specificare il tipo di dati

594
00:34:42,395 --> 00:34:45,235
per le variabili locali, il compilatore li indovina.

595
00:34:45,235 --> 00:34:48,666
Abbiamo anche un limitato type-casting

596
00:34:48,666 --> 00:34:52,473
tra tipi di dati compatibili.

597
00:34:52,473 --> 00:34:56,548
E abbiamo qualcosa che il C non ha,

598
00:34:56,548 --> 00:35:04,017
mentre il C++ sì, cioè un certo livello di riflessione.

599
00:35:04,017 --> 00:35:07,445
Cioé si può dichiarare una qualche funzione in Red/System

600
00:35:07,445 --> 00:35:12,157
con un numero variabile di argomenti

601
00:35:12,157 --> 00:35:14,311
si possono mettere questi tra parentesi

602
00:35:14,311 --> 00:35:16,341
e nel corpo della funzione

603
00:35:16,341 --> 00:35:19,854
si può muoversi attraverso quella lista di argomenti

604
00:35:19,854 --> 00:35:23,665
ed è possibile chiedere il tipo di ogni argomento.

605
00:35:23,665 --> 00:35:26,778
Ecco, questa è una caratteristica piuttosto potente,

606
00:35:26,778 --> 00:35:32,499
e infatti Kaj de Vos l'ha usata per costruire

607
00:35:32,499 --> 00:35:36,773
un dialetto VID-like in Red/System

608
00:35:36,773 --> 00:35:38,853
cosa che è una vera impresa, perché

609
00:35:38,853 --> 00:35:42,243
non abbiamo i simboli in Red/System :-)

610
00:35:42,243 --> 00:35:47,656
Quindi sembra VID ma utilizza questa funzione

611
00:35:47,656 --> 00:35:50,854
per farlo funzionare, ed è davvero fantastico.

612
00:35:50,854 --> 00:35:55,630
Abbiamo anche un preprocessore in Red/System

613
00:35:55,630 --> 00:36:01,262
ma vorrei rimandarlo alla prossima major release,

614
00:36:01,262 --> 00:36:06,590
perché abbiamo più problemi con quello

615
00:36:06,590 --> 00:36:11,779
che vantaggi.

616
00:36:11,779 --> 00:36:13,727
Così ne terremo alcuni,

617
00:36:13,727 --> 00:36:16,774
ma dobbiamo ripensarlo e riprogettarlo.

618
00:36:16,774 --> 00:36:20,186
La #define è una opzione molto potente

619
00:36:20,186 --> 00:36:22,128
perché ci dà quasi la stessa potenza

620
00:36:22,128 --> 00:36:27,392
delle macro C, così possiamo utilizzare anche i parametri.

621
00:36:27,392 --> 00:36:34,001
Vogliamo anche avere un supporto di CPU a basso livello

622
00:36:34,001 --> 00:36:39,385
attualmente abbiamo accesso ad alcuni registri della CPU

623
00:36:39,385 --> 00:36:41,747
in modo cross-platform.

624
00:36:41,747 --> 00:36:43,617
Abbiamo accesso allo stack -

625
00:36:43,617 --> 00:36:46,743
è possibile manipolare lo stack nativo

626
00:36:46,743 --> 00:36:49,724
al livello Red/System in modo cross-platform.

627
00:36:49,724 --> 00:36:55,232
E aggiungeremo il supporto per l'interruzione I/O

628
00:36:55,232 --> 00:37:02,004
e altre caratteristiche di base della CPU.

629
00:37:02,004 --> 00:37:07,289
Forse aggiungeremo qualche supporto inline assembler

630
00:37:07,289 --> 00:37:10,224
ma non è attualmente una grande necessità.

631
00:37:10,224 --> 00:37:13,926
Un paio di metriche per il progetto Red.

632
00:37:13,926 --> 00:37:18,596
È BSD, per la maggior parte del codice di base.

633
00:37:18,596 --> 00:37:22,560
E le parti di runtime di Red sono "BSL"

634
00:37:22,560 --> 00:37:25,945
che è la "Boost Software License"

635
00:37:25,945 --> 00:37:32,015
che è ancora più liberale di BSD.

636
00:37:32,015 --> 00:37:34,999
Così avete anche meno restrizioni di BSD.

637
00:37:34,999 --> 00:37:37,856
Siamo su GitHub fin dall'inizio

638
00:37:37,856 --> 00:37:43,033
abbiamo 9 committers... Penso che sia sbagliato

639
00:37:43,033 --> 00:37:46,604
sono 11 committers al momento.

640
00:37:46,604 --> 00:37:50,335
Abbiamo più di 2.000 commit

641
00:37:50,335 --> 00:37:52,867
senza contare i merge commit.

642
00:37:52,867 --> 00:37:58,035
Abbiamo circa 500 tickets nel bug tracker,

643
00:37:58,035 --> 00:38:00,490
ma sono quasi tutti chiusi

644
00:38:00,490 --> 00:38:03,576
cerchiamo di chiuderli il più velocemente possibile,

645
00:38:03,576 --> 00:38:05,852
per evitare che si accumulino.

646
00:38:05,852 --> 00:38:07,516
Perché una volta che si accumulano,

647
00:38:07,516 --> 00:38:10,788
quasi mai si riesce a smaltirli.

648
00:38:10,788 --> 00:38:14,469
Quindi dobbiamo tenere il numero molto, molto basso.

649
00:38:14,469 --> 00:38:16,696
Abbiamo un sacco di unit test

650
00:38:16,696 --> 00:38:19,569
costruiti da Peter Wood,

651
00:38:19,569 --> 00:38:23,180
che ha fatto un ottimo lavoro su questo.

652
00:38:23,180 --> 00:38:25,361
E' molto, molto d'aiuto.

653
00:38:25,361 --> 00:38:27,897
E qui avete un paio di metriche

654
00:38:27,897 --> 00:38:30,019
circa le dimensioni del codice sorgente

655
00:38:30,019 --> 00:38:32,026
per le parti Red e Red/System.

656
00:38:32,026 --> 00:38:34,073
Per il compilatore, per il linker.

657
00:38:34,073 --> 00:38:35,923
Come potete vedere da voi

658
00:38:35,923 --> 00:38:37,897
è davvero un piccolo codebase.

659
00:38:37,897 --> 00:38:41,619
Si può ottenere molto, grazie a Rebol :-)

660
00:38:41,619 --> 00:38:45,444
si può ottenere molto con un piccolo codebase

661
00:38:45,444 --> 00:38:47,680
e poche righe di codice.

662
00:38:47,680 --> 00:38:50,946
Potete fare il confronto con altri toolchain

663
00:38:50,946 --> 00:38:55,006
e spesso vedrete uno o due

664
00:38:55,006 --> 00:38:57,700
ordini di grandezza di differenza.

665
00:38:57,700 --> 00:38:59,251
Naturalmente stanno coprendo un'area

666
00:38:59,251 --> 00:39:01,428
probabilmente maggiore di quanto facciamo noi.

667
00:39:01,428 --> 00:39:06,544
Ma con un codebase così piccolo

668
00:39:06,544 --> 00:39:09,376
stiamo già coprendo un sacco di cose.

669
00:39:09,376 --> 00:39:14,352
Abbiamo ancora un sacco di lavoro

670
00:39:14,352 --> 00:39:18,824
E' ancora pesantemente sotto costruzione.

671
00:39:18,824 --> 00:39:23,389
Ci sono ancora alcune grandi parti centrali mancanti.

672
00:39:23,389 --> 00:39:30,653
Serve il supporto agli oggetti, che non c'è ancora.

673
00:39:30,653 --> 00:39:34,083
Non abbiamo ancora una corretta gestione degli errori

674
00:39:34,083 --> 00:39:36,009
perché per questo ci vuole OBJECT!.

675
00:39:36,009 --> 00:39:40,244
Ci manca la verifica del tipo di argomenti

676
00:39:40,244 --> 00:39:42,915
in alcune parti del compilatore.

677
00:39:42,915 --> 00:39:45,487
Non abbiamo ancora l'I/O, ma...

678
00:39:45,487 --> 00:39:50,941
naturalmente oggetti e I/O, sono molto in alto nella lista

679
00:39:50,941 --> 00:39:54,697
Probabilmente saranno implementati questa estate.

680
00:39:54,697 --> 00:39:59,696
Vogliamo un certo livello di supporto di concorrenza

681
00:39:59,696 --> 00:40:05,334
in 1.0, e ovviamente vogliamo anche

682
00:40:05,334 --> 00:40:09,829
una compilazione modulare e un sistema di moduli.

683
00:40:09,829 --> 00:40:14,260
Probabilmente forniremo un IDE Red minimale

684
00:40:14,260 --> 00:40:18,032
che sarà probabilmente solo un editor di codice

685
00:40:18,032 --> 00:40:23,468
più un debugger... e lavoreremo

686
00:40:23,468 --> 00:40:27,570
per estenderlo nelle versioni future.

687
00:40:27,570 --> 00:40:31,050
Vogliamo anche una documentazione completa

688
00:40:31,050 --> 00:40:37,597
e questo è un grande freno a rilasciare una 1.0

689
00:40:37,597 --> 00:40:41,836
quindi abbiamo un sacco di lavoro per scrivere

690
00:40:41,836 --> 00:40:43,650
la documentazione e i tutorial.

691
00:40:43,650 --> 00:40:46,529
E naturalmente abbiamo bisogno di avere un nuovo sito web

692
00:40:46,529 --> 00:40:49,753
per il lancio della versione 1.0.

693
00:40:51,613 --> 00:40:54,761
Ma non è tutto... :-)

694
00:40:54,761 --> 00:40:57,310
Non è quello il vero Red.

695
00:40:57,310 --> 00:41:00,523
Il vero Red sarà la 2.0.

696
00:41:00,523 --> 00:41:05,640
E abbiamo un buon cast per lui (risate)

697
00:41:05,640 --> 00:41:07,538
Così che cosa è "The Real Red" ?

698
00:41:07,538 --> 00:41:11,329
In realtà, quello che ho presentato finora

699
00:41:11,329 --> 00:41:13,583
è una sorta di impalcatura.

700
00:41:13,583 --> 00:41:15,570
Poiché il vero Red è questo.

701
00:41:15,570 --> 00:41:23,308
Il vero Red sarà essenzialmente un compilatore JIT

702
00:41:23,308 --> 00:41:27,206
che sarà in grado di lavorare anche come un compilatore statico.

703
00:41:27,206 --> 00:41:29,613
L'intera architettura interna

704
00:41:29,613 --> 00:41:32,929
sarà totalmente diverso da quella attuale

705
00:41:32,929 --> 00:41:35,846
implementata nella versione bootstrap.

706
00:41:35,846 --> 00:41:39,254
Sarà plugin-orientato

707
00:41:39,254 --> 00:41:40,910
cioè sostanzialmente il compilatore e il toolchain

708
00:41:40,910 --> 00:41:44,718
saranno gusci vuoti - un framework -

709
00:41:44,718 --> 00:41:49,830
nei quali si potranno innestare alcuni moduli

710
00:41:49,830 --> 00:41:54,223
per aggiungere funzionalità in ogni fase della compilazione,

711
00:41:54,223 --> 00:41:57,606
dal parsing fino alla generazione dei file.

712
00:41:57,606 --> 00:42:00,981
Ci sarà un'API con cui lavorare.

713
00:42:00,981 --> 00:42:03,679
Fornirò il framework

714
00:42:03,679 --> 00:42:07,304
e i moduli minimali per renderlo funzionante

715
00:42:07,304 --> 00:42:10,946
con lo stesso livello di funzionalità della 1.0.

716
00:42:10,946 --> 00:42:15,920
E tale API sarà naturalmente documentata

717
00:42:15,920 --> 00:42:18,986
così chiunque sarà in grado di modificare

718
00:42:18,986 --> 00:42:22,012
e aggiungere nuove funzionalità al compilatore

719
00:42:22,012 --> 00:42:25,657
in modo isolato, e molto strutturato.

720
00:42:25,657 --> 00:42:29,935
Una tale API potrebbe anche essere chiamata a runtime.

721
00:42:29,935 --> 00:42:34,584
Vi lascio immaginare le opzioni e le possibilità

722
00:42:34,584 --> 00:42:37,270
con la modifica del compilatore stesso e della toolchain

723
00:42:37,270 --> 00:42:38,819
in fase di esecuzione.

724
00:42:38,819 --> 00:42:40,186
Sarà possibile in fase di esecuzione

725
00:42:40,186 --> 00:42:43,657
cambiare il linguaggio stesso o aggiungere nuove funzionalità.

726
00:42:43,657 --> 00:42:47,107
Può sembrare totalmente folle

727
00:42:47,107 --> 00:42:48,494
ma è qualcosa che altri linguaggi

728
00:42:48,494 --> 00:42:53,525
che stanno crescendo in questo momento

729
00:42:53,525 --> 00:42:56,184
stanno facendo... per esempio, il linguaggio Scala

730
00:42:56,184 --> 00:42:57,921
sta facendo esattamente questo.

731
00:42:57,921 --> 00:43:00,094
E alcune persone della comunità Scala

732
00:43:00,094 --> 00:43:04,242
stanno usando questo tipo di funzione per fare miracoli in Scala.

733
00:43:04,242 --> 00:43:07,042
Ad esempio, un ragazzo molto intelligente

734
00:43:07,042 --> 00:43:13,634
ha usato questa API per aggiungere il supporto parallelo per i loop

735
00:43:13,634 --> 00:43:18,648
utilizzando il GPGPU per parallelizzarlo

736
00:43:18,648 --> 00:43:23,715
usando OpenCL come strato di basso livello.

737
00:43:23,715 --> 00:43:27,094
Ecco, questo è una caratteristica molto potente

738
00:43:27,094 --> 00:43:31,124
e inoltre rende l'architettura del compilatore

739
00:43:31,124 --> 00:43:37,405
molto più solida e permette alle persone di contribuire

740
00:43:37,405 --> 00:43:39,391
in un modo molto più semplice

741
00:43:39,391 --> 00:43:42,666
e molto più strutturato.

742
00:43:42,666 --> 00:43:45,410
Quindi l'implicazione è che l'attuale codebase

743
00:43:45,410 --> 00:43:50,145
del compilatore... Nel diagramma interno Red

744
00:43:50,145 --> 00:43:53,929
era il lato destro dei blocchi...

745
00:43:53,929 --> 00:43:56,942
Il codebase attuale Rebol 2

746
00:43:56,942 --> 00:44:00,594
è una specie di codice usa e getta.

747
00:44:00,594 --> 00:44:04,283
Fin dall'inizio, l'ho scritto molto velocemente

748
00:44:04,283 --> 00:44:08,540
pensando che l'avrei scartato rapidamente

749
00:44:08,540 --> 00:44:10,412
in circa un anno,

750
00:44:10,412 --> 00:44:14,035
e sarei stato in grado di riscriverlo rapidamente in Red.

751
00:44:14,035 --> 00:44:18,069
Ma abbiamo cambiato un sacco di cose nel progetto

752
00:44:18,069 --> 00:44:22,374
l'abbiamo adattato all'ambiente in evoluzione

753
00:44:22,374 --> 00:44:25,218
e quindi non siamo ancora arrivati lì.

754
00:44:25,218 --> 00:44:29,434
Quindi per prima cosa andiamo verso 1.0 nella versione bootstrap

755
00:44:29,434 --> 00:44:32,590
e il 2.0 sarà la versione self-hosted

756
00:44:32,590 --> 00:44:35,173
con la toolchain riscritta in Red.

757
00:44:35,173 --> 00:44:41,975
Tutta la parte runtime di Red rimarrà uguale

758
00:44:41,975 --> 00:44:43,714
perché è scritta in Red/System

759
00:44:43,714 --> 00:44:47,340
in modo da sopravvivere, e questo è un grande codebase.

760
00:44:47,340 --> 00:44:50,087
Quindi l'unica parte che verrà riscritta

761
00:44:50,087 --> 00:44:53,342
sarà il codebase Rebol 2, che sono

762
00:44:53,342 --> 00:44:56,511
fondamentalmente i compilatori Red e Red/System

763
00:44:56,511 --> 00:44:59,654
Poche parole circa l'organizzazione del progetto:

764
00:44:59,654 --> 00:45:05,659
abbiamo due collaboratori su GitHub

765
00:45:05,659 --> 00:45:10,028
che significa che c'è un admin e altre due persone

766
00:45:10,028 --> 00:45:15,747
con i diritti di amministratore. Quindi, se vengo colpito da un autobus

767
00:45:15,747 --> 00:45:21,832
questi due ragazzi potrebbero prendere il codice sorgente

768
00:45:21,832 --> 00:45:26,973
nel repository Red e gestirlo.

769
00:45:26,973 --> 00:45:30,940
Abbiamo circa 11 collaboratori per il codebase

770
00:45:30,940 --> 00:45:33,673
fin dall'inizio. Abbiamo una mailing list.

771
00:45:33,673 --> 00:45:37,359
Abbiamo una pagina Facebook, un canale IRC

772
00:45:37,359 --> 00:45:42,087
con un bel IRC bot fatto da Andreas

773
00:45:42,087 --> 00:45:44,471
per la segnalazione dei commit.

774
00:45:44,471 --> 00:45:46,792
E naturalmente stiamo cercando altre persone

775
00:45:46,792 --> 00:45:49,389
che siano interessate a contribuire

776
00:45:49,389 --> 00:45:52,707
e partecipare in ogni modo

777
00:45:52,707 --> 00:45:54,940
perché è decisamente un grande progetto...

778
00:45:54,940 --> 00:45:58,775
e abbiamo bisogno di un sacco di mani che aiutino.

779
00:46:00,945 --> 00:46:03,564
Ultimo ma non meno importante :-)

780
00:46:03,564 --> 00:46:09,450
Ho investito in questo progetto... da quando ho iniziato

781
00:46:09,450 --> 00:46:12,146
circa 2 anni e mezzo fa...

782
00:46:12,146 --> 00:46:16,020
fino all'ultimo centesimo dei risparmi che avevo. :-)

783
00:46:16,020 --> 00:46:20,434
Quindi sto davvero credendo totalmente nel progetto

784
00:46:20,434 --> 00:46:22,075
e nel suo successo.

785
00:46:22,075 --> 00:46:27,231
Ma ho finito i soldi abbastanza rapidamente. :-)

786
00:46:27,231 --> 00:46:30,128
Da ormai un anno sto vivendo solo con le donazioni

787
00:46:30,128 --> 00:46:33,280
che gli utenti e seguaci mi stanno inviando.

788
00:46:33,280 --> 00:46:35,522
Quindi voglio ringraziarli molto

789
00:46:35,522 --> 00:46:39,136
perché io non sarei qui senza di loro

790
00:46:39,136 --> 00:46:41,448
e Red non sarebbe a questo stadio,

791
00:46:41,448 --> 00:46:42,987
o probabilmente non esisterebbe

792
00:46:42,987 --> 00:46:45,865
se la gente non mi avesse sostenuto.

793
00:46:45,865 --> 00:46:49,165
Quindi grazie molto, e dobbiamo continuare

794
00:46:49,165 --> 00:46:52,832
a sostenerlo per renderlo una realtà.

795
00:46:52,832 --> 00:46:55,053
Grazie a tutti per l'ascolto.

796
00:46:55,053 --> 00:46:59,053
(applausi)
