1
00:00:10,593 --> 00:00:14,410
Notre prochain invité est Nenad Rakocevic

2
00:00:14,410 --> 00:00:17,039
qui va nous expliquer "Ce qu'est Red".

3
00:00:17,039 --> 00:00:22,496
(applaudissements)

4
00:00:22,886 --> 00:00:27,767
Merci, Gregg. Et merci à toutes le personnes

5
00:00:27,767 --> 00:00:31,908
qui ont contribué financièrement aux frais de mon voyage

6
00:00:31,908 --> 00:00:33,728
et l'ont rendu possible.

7
00:00:33,728 --> 00:00:36,932
J'ai déjà donné plusieurs présentations de Red

8
00:00:36,932 --> 00:00:43,013
mais de nouveaux venus se présentent encore à moi

9
00:00:43,013 --> 00:00:45,517
avec cette simple question :

10
00:00:45,517 --> 00:00:47,400
"C'est quoi Red ?"

11
00:00:47,400 --> 00:00:50,166
parce que le projet a plusieurs facettes

12
00:00:50,166 --> 00:00:51,741
et je peux le comprendre.

13
00:00:51,741 --> 00:00:54,042
C'est pourquoi j'essayerais dans cette présentation

14
00:00:54,042 --> 00:00:58,673
de donner un bon aperçu de chaque facette du projet.

15
00:00:58,673 --> 00:01:02,522
Commençons par un panorama du problème.

16
00:01:02,522 --> 00:01:06,517
Ce n'est pas une image de mes petites cellules grises,

17
00:01:06,517 --> 00:01:10,566
c'est un modèle informatique d'une carte globale

18
00:01:10,566 --> 00:01:12,772
de l'univers connu.

19
00:01:12,772 --> 00:01:14,740
Ceci vous donne une bonne image

20
00:01:14,740 --> 00:01:18,230
de la taille du problème (rires).

21
00:01:18,230 --> 00:01:20,329
En fait c'est une allusion à

22
00:01:20,329 --> 00:01:23,036
ce que j'étais supposé devenir

23
00:01:23,036 --> 00:01:26,011
parce que j'étais étudiant en astrophysique

24
00:01:26,011 --> 00:01:30,570
et j'ai changé pour l'informatique au collège.

25
00:01:30,570 --> 00:01:34,589
Mon regard sur le monde de l'informatique est

26
00:01:34,589 --> 00:01:38,792
que nous utilisons aujourd'hui encore

27
00:01:38,792 --> 00:01:41,018
des outils et techniques archaïques.

28
00:01:41,018 --> 00:01:44,653
Nous ne sommes pas très éloignés de ces deux gars

29
00:01:44,653 --> 00:01:46,357
sur l'aspect logiciel.

30
00:01:46,357 --> 00:01:49,283
Nous sommes toujours à un stade primitif

31
00:01:49,283 --> 00:01:51,928
parce que nous réinventons sans cesse la roue

32
00:01:51,928 --> 00:01:54,513
reproduisant constamment les mêmes erreurs

33
00:01:54,513 --> 00:01:56,041
encore et encore.

34
00:01:56,041 --> 00:01:58,892
Al doit bien se marrer.

35
00:01:58,902 --> 00:02:02,541
Du moins je l'espère. :-) (rires)

36
00:02:02,541 --> 00:02:08,308
Si nous revenons sur le sujet qui nous occupe

37
00:02:08,308 --> 00:02:12,563
nous voyons un grand nombre de langages de programmation.

38
00:02:12,563 --> 00:02:14,927
Si vous regardez sur Wikipedia la liste

39
00:02:14,927 --> 00:02:18,596
des langages, vous tombez sur la lettre A

40
00:02:18,596 --> 00:02:23,107
et la page continue.

41
00:02:23,107 --> 00:02:24,802
Il y a vraiment des milliers

42
00:02:24,802 --> 00:02:27,188
de langages de programmation.

43
00:02:27,188 --> 00:02:29,588
Si vous regardez de plus près, vous voyez

44
00:02:29,588 --> 00:02:32,839
des langages créés pour l'Amiga.

45
00:02:32,839 --> 00:02:34,465
Le fameux « Amiga E »

46
00:02:34,465 --> 00:02:37,288
et AMOS qui a été créé par un français…

47
00:02:37,288 --> 00:02:42,988
un gars très brillant, dont le nom est François Lionet.

48
00:02:42,988 --> 00:02:46,500
Ce Basic était fondamentalement un DSL.

49
00:02:46,500 --> 00:02:50,240
C'était un outil que j'ai utilisé

50
00:02:50,240 --> 00:02:52,899
il y a plus de 20 ans.

51
00:02:52,899 --> 00:02:56,445
Ce DSL était pensé pour l'animation…

52
00:02:56,445 --> 00:03:00,268
…il était compilé en code natif.

53
00:03:00,268 --> 00:03:04,439
Et la totalité de l'interpréteur, du compilateur et de l'IDE

54
00:03:04,439 --> 00:03:10,624
était écrit exclusivement en assembleur.

55
00:03:10,624 --> 00:03:15,262
Ce gars a été une source d'inspiration pour moi.

56
00:03:15,262 --> 00:03:19,448
Malgré tant de langages de programmation

57
00:03:19,448 --> 00:03:22,985
et d'outils nous en cherchons toujours un nouveau,

58
00:03:22,985 --> 00:03:25,197
une meilleure solution.

59
00:03:25,197 --> 00:03:28,035
Les problèmes auxquels nous devons faire face chaque jour

60
00:03:28,035 --> 00:03:31,225
dans le monde logiciel sont maintenant bien connus

61
00:03:31,225 --> 00:03:34,345
mais nous n'arrivons pas à les dépasser.

62
00:03:34,345 --> 00:03:37,582
Comme l'explosion de la complexité… les usines à gaz…

63
00:03:37,582 --> 00:03:40,334
Non, bien évidemment, je ne pense pas à Java. (rires)

64
00:03:40,334 --> 00:03:42,225
Ne pas penser à Java. :-P

65
00:03:42,225 --> 00:03:44,769
Ralentissement des performances… Boîtes noires,

66
00:03:44,769 --> 00:03:46,554
logiciels au code fermé, par exemple.

67
00:03:46,554 --> 00:03:49,598
Ce qui peut être un gros problème lorsque vous essayez

68
00:03:49,598 --> 00:03:53,461
de résoudre des bogues que vous ne pouvez pas atteindre.

69
00:03:53,461 --> 00:03:57,872
Donc au lieu de passer notre temps à frapper des murs

70
00:03:57,872 --> 00:04:00,348
nous devrions nous amuser en programmant

71
00:04:00,348 --> 00:04:02,665
parce que programmer est une activité ludique.

72
00:04:02,665 --> 00:04:05,265
Et c'est l'esprit que nous devrions avoir lorsque

73
00:04:05,265 --> 00:04:07,852
nous sommes face à un ordinateur et travaillons avec.

74
00:04:07,852 --> 00:04:11,400
C'est comme en ce temps où la programmation

75
00:04:11,400 --> 00:04:13,440
n'était *que* ludique.

76
00:04:13,440 --> 00:04:16,441
Depuis lors, les années 80,

77
00:04:16,441 --> 00:04:19,490
tout à été chamboulé.

78
00:04:19,490 --> 00:04:21,716
Et actuellement nous avons — je pense — deux

79
00:04:21,716 --> 00:04:25,710
changements particulièrement importants du monde informatique.

80
00:04:25,710 --> 00:04:28,281
Le premier est l'augmentation de la puissance

81
00:04:28,281 --> 00:04:31,224
des ordinateurs par l'ajout de nouveaux cœurs

82
00:04:31,224 --> 00:04:34,934
au lieu de l'augmentation de la fréquence des processeurs.

83
00:04:34,934 --> 00:04:39,320
Ça a de grandes répercussions sur les outils de programmation.

84
00:04:39,320 --> 00:04:44,062
La seconde révolution principale est le passage

85
00:04:44,062 --> 00:04:46,772
généralisé aux périphériques mobiles.

86
00:04:46,772 --> 00:04:49,987
Le marché évolue très vite.

87
00:04:49,987 --> 00:04:52,947
Les outils de programmation doivent s'adapter.

88
00:04:52,947 --> 00:04:56,540
Malgré ces changements,

89
00:04:56,540 --> 00:04:59,593
nous utilisons encore de vieux outils, en fait.

90
00:04:59,593 --> 00:05:03,677
J'ai pris les cinq langages de programmation

91
00:05:03,677 --> 00:05:07,004
les plus populaires de Tiobe…

92
00:05:07,004 --> 00:05:09,111
...le fameux index.

93
00:05:09,111 --> 00:05:12,114
Houaou, C est encore en tête

94
00:05:12,114 --> 00:05:14,672
alors qu'il a presque 40 ans maintenant.

95
00:05:14,672 --> 00:05:18,748
C'est vraiment très long pour l'informatique !

96
00:05:18,748 --> 00:05:22,984
Et C n'est absolument pas fait pour répondre

97
00:05:22,984 --> 00:05:25,417
aux besoins modernes de l'informatique.

98
00:05:25,417 --> 00:05:27,973
Si vous regardez les suivants

99
00:05:27,973 --> 00:05:30,784
c'est à peu de choses près la même histoire.

100
00:05:30,784 --> 00:05:33,205
Heureusement pour nous, centaines personnes…

101
00:05:33,205 --> 00:05:36,211
… quelques rares personnes sont au fait

102
00:05:36,211 --> 00:05:41,981
et capables d'apporter une réponse à ces problèmes.

103
00:05:41,981 --> 00:05:45,129
des personnes comme Carl (signe de la main à Carl Sassenrath)

104
00:05:45,129 --> 00:05:47,309
qui ont inventé Rebol… un outil fantastique.

105
00:05:47,309 --> 00:05:50,383
Probablement une des plus grandes inventions

106
00:05:50,383 --> 00:05:55,080
du monde informatique de ces 20 dernières années.

107
00:05:55,080 --> 00:05:57,875
Rebol était une bonne solution, ou une très

108
00:05:57,875 --> 00:06:00,598
bonne solution à un grand nombre de questions.

109
00:06:00,598 --> 00:06:01,978
**Mais pas toutes.*

110
00:06:01,978 --> 00:06:05,352
Il y a une chose que j'aimerais montrer à Carl…

111
00:06:05,352 --> 00:06:08,556
… peut-être ne l'a-t-il pas vu ?

112
00:06:08,556 --> 00:06:12,917
Les merveilles que faisait Rebol, jusqu'à récemment,

113
00:06:12,917 --> 00:06:17,277
était tout simplement le fait de la communauté

114
00:06:17,277 --> 00:06:20,004
louant et essayant d'expliquer aux gens comment Rebol

115
00:06:20,004 --> 00:06:23,947
peut être un outil productif et expressif.

116
00:06:23,947 --> 00:06:28,282
Mais récemment une étude scientifique a essayé de mesurer

117
00:06:28,282 --> 00:06:32,13
l'expressivité des langages de programmation.

118
00:06:32,133 --> 00:06:37,597
Ils ont participé. Et Rebol… *surprise* ! A obtenu un 3.

119
00:06:37,597 --> 00:06:41,516
En fait : les nombres 1 et 2 sont des DSLs.

120
00:06:41,516 --> 00:06:44,526
Alors devinez qui est le premier ? (rires)

121
00:06:44,526 --> 00:06:49,040
Ceci confirme seulement une chose

122
00:06:49,040 --> 00:06:51,141
que nous savions depuis le départ.

123
00:06:51,141 --> 00:06:53,307
Rebol est un outil très productif

124
00:06:53,307 --> 00:06:55,935
et c'est maintenant prouvé. (rires)

125
00:06:55,935 --> 00:07:00,715
Mais Red tente d'aller au delà de ce que Rebol peut offrir.

126
00:07:00,715 --> 00:07:03,002
Principalement en terme d'implémentation

127
00:07:03,002 --> 00:07:06,519
non en terme de sémantique ou de syntaxe.

128
00:07:06,519 --> 00:07:10,458
Surtout en terme de chaîne de compilation, d'implémentations,

129
00:07:10,458 --> 00:07:13,065
et de diffusion.

130
00:07:13,065 --> 00:07:16,160
Mais en fin de compte, c'est quoi Red ?

131
00:07:16,160 --> 00:07:17,653
Red est ce que j'appelle

132
00:07:17,653 --> 00:07:19,212
un *langage de programmation full-Stack*.

133
00:07:19,212 --> 00:07:22,317
Peut-être avez-vous entendu parler de développeurs full-Stack ?

134
00:07:22,317 --> 00:07:25,796
De la même manière, c'est un langage de programmation full-Stack.

135
00:07:25,796 --> 00:07:28,995
Et probablement sa caractéristique principale

136
00:07:28,995 --> 00:07:31,188
réside dans son domaine d'application

137
00:07:31,188 --> 00:07:33,287
réellement général.

138
00:07:33,287 --> 00:07:35,182
Il y a beaucoup de langages

139
00:07:35,182 --> 00:07:39,288
qui se dise *généralistes*…

140
00:07:39,288 --> 00:07:43,358
…mais il ne le sont pas autant que Red peut l'être.

141
00:07:43,358 --> 00:07:47,121
L'autre grande caractéristique de Red

142
00:07:47,121 --> 00:07:49,413
est sa chaîne de compilation intégrée

143
00:07:49,413 --> 00:07:52,050
qui le rend indépendant de la celle de C,

144
00:07:52,050 --> 00:07:56,488
nous avons la notre.

145
00:07:56,488 --> 00:07:59,648
Un autre aspect important de red

146
00:07:59,648 --> 00:08:01,421
est son *ouverture* (freedom).

147
00:08:01,421 --> 00:08:03,695
Depuis le début, mon projet pour Red

148
00:08:03,695 --> 00:08:07,334
était de l'affranchir de toute restriction

149
00:08:07,334 --> 00:08:08,995
et de toutes les limites possibles.

150
00:08:08,995 --> 00:08:14,230
Je veux que les utilisateurs de Red se sentent comme chez eux.

151
00:08:14,230 --> 00:08:18,165
Red est facile à utiliser, *merci Rebol*…

152
00:08:18,165 --> 00:08:23,770
…mais Red n'a pas de restrictions arbitraires.

153
00:08:23,770 --> 00:08:26,374
Nous essayons de répondre autant que possible

154
00:08:26,374 --> 00:08:28,138
à chaque besoin et chaque aspect pour qu'il puisse

155
00:08:28,138 --> 00:08:33,154
être porté et distribué sur le maximum de plateformes.

156
00:08:33,154 --> 00:08:35,799
Ensuite, une chose importante en programmation :

157
00:08:35,799 --> 00:08:39,061
nous avons besoin de ressentir qui nous contrôlons l'outil.

158
00:08:39,061 --> 00:08:42,836
Souvent nous utilisons certains outils qui peuvent être puissant

159
00:08:42,836 --> 00:08:44,878
mais que nous ne contrôlons pas, parce que

160
00:08:44,878 --> 00:08:47,250
nous ne comprenons pas leur fonctionnement interne.

161
00:08:47,250 --> 00:08:48,730
Le plus souvent parce que ce sont des boîtes noires.

162
00:08:48,730 --> 00:08:52,495
Ou parce qu'ils sont au sommet d'une grande pile

163
00:08:52,495 --> 00:08:56,225
de couches logicielles dont le fonctionnement interne

164
00:08:56,225 --> 00:08:57,921
ne nous est pas compréhensible.

165
00:08:57,921 --> 00:09:02,394
Une dernière chose importante :-)

166
00:09:02,394 --> 00:09:04,521
Le *Fun*. Parfaitement, nous voulons revenir à quelque chose de fun.

167
00:09:04,521 --> 00:09:08,808
Certaines personnes qui ont essayé Red

168
00:09:08,808 --> 00:09:11,465
ou Red / System, après la compilation et le lancement

169
00:09:11,465 --> 00:09:14,262
réussi de leur premier programme 

170
00:09:14,262 --> 00:09:16,175
viennent me voir et me disent :

171
00:09:16,175 --> 00:09:17,367
« C'est génial parce que c'est amusant. »

172
00:09:17,367 --> 00:09:21,281
« J'ai seulement essayé ça, ça marche, et c'est super. »

173
00:09:21,281 --> 00:09:25,132
Les gens ont ce sentiment — ce dont je voulais parler

174
00:09:25,132 --> 00:09:27,620
Ce sentiment des années 80 !

175
00:09:27,620 --> 00:09:29,347
Où vous vous sentez au contrôle

176
00:09:29,347 --> 00:09:31,121
de votre outil de programmation.

177
00:09:31,121 --> 00:09:34,387
Je vais essayé d'expliquer ce que je veux dire par

178
00:09:34,387 --> 00:09:36,782
« langage de programmation full-stack » et

179
00:09:36,782 --> 00:09:40,455
« langage de programmation vraiment généraliste ».

180
00:09:40,455 --> 00:09:42,096
J'ai fait ce graphique :

181
00:09:42,096 --> 00:09:43,414
« Domaine d'application d'un logiciel »

182
00:09:43,414 --> 00:09:46,570
pour un petit nombre de langages de programmation.

183
00:09:46,570 --> 00:09:49,393
Par exemple, l'assembleur est pour les pilotes

184
00:09:49,393 --> 00:09:52,019
et pour le code très bas niveau.

185
00:09:52,019 --> 00:09:54,895
Vous pouvez voir que Java est réellement limité

186
00:09:54,895 --> 00:09:58,084
dans ses capacités à modéliser différents niveaux d'abstraction.

187
00:09:58,084 --> 00:10:00,607
Ruby est assez étendu ;

188
00:10:00,607 --> 00:10:02,989
peut-être qu'il n'atteint pas l'OS ?

189
00:10:02,989 --> 00:10:05,598
Je ne sais pas si l'interface Ruby

190
00:10:05,598 --> 00:10:09,888
qui appelle l'API de l'OS est réellement bonne ou pas.

191
00:10:09,888 --> 00:10:13,324
Rebol a un très large rayon d'action.

192
00:10:13,324 --> 00:10:16,880
Rascal est un langage de programmation très spécifique.

193
00:10:16,880 --> 00:10:19,540
C'est une sorte de DSL,

194
00:10:19,540 --> 00:10:23,246
destiné à écrire d'autres DSLs.

195
00:10:23,246 --> 00:10:26,522
Il se tient au niveau d'un meta-DSL.

196
00:10:26,522 --> 00:10:30,356
Mais où est Red sur cette échelle ?

197
00:10:30,356 --> 00:10:33,954
Red est conçu pour couvrir tous

198
00:10:33,954 --> 00:10:37,272
les besoins de bas en haut.

199
00:10:37,272 --> 00:10:40,596
parce que je ne veux pas avoir à utiliser un autre outil.

200
00:10:40,596 --> 00:10:43,056
Je veux que le langage de programmation Red 

201
00:10:43,056 --> 00:10:45,913
soit capable de couvrir tous ces besoins

202
00:10:45,913 --> 00:10:48,272
sans dépendre d'aucun autre.

203
00:10:48,272 --> 00:10:51,236
Vous me direz peut-être que c'est impossible

204
00:10:51,236 --> 00:10:53,307
de créer un langage capable

205
00:10:53,307 --> 00:10:56,058
d'appréhender un spectre aussi large.

206
00:10:56,058 --> 00:10:58,201
Et vous avez raison.

207
00:10:58,201 --> 00:11:00,771
Mais red a une carte maîtresse.

208
00:11:00,771 --> 00:11:04,418
Red / System couvre les couches basses

209
00:11:04,418 --> 00:11:06,604
et Red les couches hautes.

210
00:11:06,604 --> 00:11:10,037
Elles sont intégrées ensemble

211
00:11:10,037 --> 00:11:11,702
et marche de concert.

212
00:11:11,702 --> 00:11:15,114
Red / System, en fait, est un dialect de Red.

213
00:11:15,114 --> 00:11:17,191
Vous pouvez l'utiliser séparément

214
00:11:17,191 --> 00:11:20,112
ou directement embarqué dans Red

215
00:11:20,112 --> 00:11:25,446
Laissez moi vous montrer les plateformes que nous prenons en charge.

216
00:11:25,446 --> 00:11:26,597
D'abord sur les stations de travail,

217
00:11:26,597 --> 00:11:30,755
nous prenons en charge les trois principaux.

218
00:11:30,755 --> 00:11:34,424
Nous prenons aussi en charge d'autres

219
00:11:34,424 --> 00:11:36,693
systèmes comme Syllable.

220
00:11:36,693 --> 00:11:38,829
Nous souhaitons prendre en charge FreeBSD

221
00:11:38,829 --> 00:11:41,350
mais nous rencontrons quelques problèmes de bas niveau

222
00:11:41,350 --> 00:11:45,053
et n'avons parmi nous aucun expert FreeBSD

223
00:11:45,053 --> 00:11:48,456
pour les résoudre, donc pour le moment c'est au point mort.

224
00:11:48,456 --> 00:11:52,454
Mais nous pourrons probablement porter Red

225
00:11:52,454 --> 00:11:54,855
sur FreeBSD rapidement.

226
00:11:54,855 --> 00:11:57,687
Nous visons aussi le marché

227
00:11:57,687 --> 00:12:00,774
de l'embarqué, à commencer par Android

228
00:12:00,774 --> 00:12:02,771
avec déjà un très bon support.

229
00:12:02,771 --> 00:12:04,787
Le suivant sera iOS.

230
00:12:04,787 --> 00:12:07,905
Et avons déjà une version Raspberry Pi

231
00:12:07,905 --> 00:12:10,367
qui est devenu très populaire.

232
00:12:10,367 --> 00:12:14,720
Je suppose que Bo donnera quelques

233
00:12:14,720 --> 00:12:17,929
démonstrations demain probablement.

234
00:12:17,929 --> 00:12:22,868
Nous avons aussi un port expérimental pour Arduino.

235
00:12:22,868 --> 00:12:27,030
Nous commençons sur AVR 8-bit.

236
00:12:27,030 --> 00:12:30,044
Mais c'est une expérience pour le moment

237
00:12:30,044 --> 00:12:32,895
parce que d'autres cartes viendront

238
00:12:32,895 --> 00:12:36,014
comme les cartes 32-bit ou le Raspberry Pi.

239
00:12:36,014 --> 00:12:41,790
Le support 8-bit n'est pas notre préoccupation immédiate.

240
00:12:41,790 --> 00:12:45,320
Nous voulons prendre en charge également les machines virtuelles.

241
00:12:45,320 --> 00:12:49,753
Nous voulons être capable de nous connecter à .Net,

242
00:12:49,753 --> 00:12:53,139
la JVM, ou encore JavaScript.

243
00:12:53,139 --> 00:12:55,602
Il y a deux méthodes essentielles

244
00:12:55,602 --> 00:12:56,467
pour y parvenir.

245
00:12:56,467 --> 00:13:00,940
Avoir un pont, conserver Red tel qu'il est maintenant

246
00:13:00,940 --> 00:13:06,438
et ajouter ce qu'il manque pour les machines virtuelles.

247
00:13:06,438 --> 00:13:08,746
Ou développer un nouveau backend

248
00:13:08,746 --> 00:13:11,146
pour que Red et Red / System

249
00:13:11,146 --> 00:13:13,710
soient capables de compiler directement du code objet 

250
00:13:13,710 --> 00:13:15,817
pour les machines virtuelles.

251
00:13:15,817 --> 00:13:17,905
Nous avons ces deux options.

252
00:13:17,905 --> 00:13:21,645
Nous avons commencé par le pont pour la JVM.

253
00:13:21,645 --> 00:13:26,405
Nous essaierons chaque fois de choisir

254
00:13:26,405 --> 00:13:30,067
la bonne solution — la meilleure pour cette tâche.

255
00:13:30,067 --> 00:13:33,188
Pour le moment nous faisons le pont pour la JVM.

256
00:13:33,188 --> 00:13:37,997
Mais probablement que nous compileront directement pour JavaScript

257
00:13:37,997 --> 00:13:41,551
Nous avons asm.js maintenant, donc nous avons

258
00:13:41,551 --> 00:13:45,325
une plateforme cible très intéressante.

259
00:13:45,325 --> 00:13:47,584
Je m'attend à ce que Red et Red / System

260
00:13:47,584 --> 00:13:50,755
soient particulièrement performant sur ce point.

261
00:13:50,755 --> 00:13:53,753
Sur le plan pratiquement, un autre aperçu de son fonctionnement 

262
00:13:53,753 --> 00:13:57,242
Nous avons Red : un exécutable.

263
00:13:57,242 --> 00:14:01,118
Vous le téléchargez et tout est inclus.

264
00:14:01,118 --> 00:14:04,756
Vous pouvez exécuter un script Red directement en mémoire.

265
00:14:04,756 --> 00:14:08,124
Vous pouvez le compiler en un exécutable.

266
00:14:08,124 --> 00:14:12,805
Vous pouvez le cross-compiler…

267
00:14:12,805 --> 00:14:15,324
Nous reviendrons sur ces fonctionnalités.

268
00:14:15,324 --> 00:14:19,071
Vous pouvez aussi compiler directement des scripts Red / System,

269
00:14:19,071 --> 00:14:22,291
si vous ne voulez pas utiliser la couche Red

270
00:14:22,291 --> 00:14:26,063
et coder une application bas niveau.

271
00:14:26,063 --> 00:14:29,955
Et maintenant vous pouvez aussi compiler des bibliothèques partagées

272
00:14:29,955 --> 00:14:32,948
ce qui ouvre la porte à sa diffusion 

273
00:14:32,948 --> 00:14:36,582
en le branchant partout ou nous le pourrons.

274
00:14:36,582 --> 00:14:39,954
Vous pouvez aussi lancer Red en mode console

275
00:14:39,954 --> 00:14:42,206
et nous avons une console Red.

276
00:14:42,206 --> 00:14:45,499
Pour la cross-compilation… Red est maintenant capable de cross-compiler

277
00:14:45,499 --> 00:14:49,442
de n'importe quel système vers n'importe quel autre.

278
00:14:49,442 --> 00:14:52,731
En fait il est capable de compiler depuis n'importe quel plateforme

279
00:14:52,731 --> 00:14:56,113
où Rebol fonctionne vers n'importe quel autre plateforme.

280
00:14:56,113 --> 00:15:00,808
Pour y parvenir, vous n'avez pas besoin d'un HOWTO,

281
00:15:00,808 --> 00:15:02,363
vous n'avez par besoin d'un tutoriel,

282
00:15:02,363 --> 00:15:04,788
vous n'avez pas besoin de rechercher sur le Web

283
00:15:04,788 --> 00:15:07,182
pour savoir comment faire.

284
00:15:07,182 --> 00:15:10,293
Vous passez simplement l'option « -t », l'identifiant de la cible

285
00:15:10,293 --> 00:15:11,777
et c'est tout !

286
00:15:11,777 --> 00:15:16,750
L'identifiant de la cible est seulement une entrée

287
00:15:16,750 --> 00:15:21,988
dans un fichier de configuration, un simple dialect Red,

288
00:15:21,988 --> 00:15:26,132
qui énumère quelques options pour les plateformes cibles.

289
00:15:26,132 --> 00:15:31,110
Donc, pour le moment, nous avons cette liste d'environ 8 cibles

290
00:15:31,110 --> 00:15:33,602
Nous pouvons les cross-compiler mutuellement

291
00:15:33,602 --> 00:15:35,828
à partir du moment ou Rebol

292
00:15:35,828 --> 00:15:40,124
fonctionne sur ces plateformes

293
00:15:40,124 --> 00:15:41,557
Comme vous pouvez le voir, nous supportons

294
00:15:41,557 --> 00:15:45,594
principalement les plateformes x86 et ARM.

295
00:15:45,594 --> 00:15:49,412
Pour aller un peu plus loin dans la chaîne de compilation

296
00:15:49,412 --> 00:15:51,796
nous avons plusieurs parties.

297
00:15:51,796 --> 00:15:54,506
Nous avons le couple classique : compilateur, éditeur de liens.

298
00:15:54,506 --> 00:16:01,832
La couche du compilateur est capable de traiter

299
00:16:01,832 --> 00:16:07,115
principalement les deux sorties x68 et ARM.

300
00:16:07,115 --> 00:16:11,919
Mais nous prévoyons d'étendre son support

301
00:16:11,919 --> 00:16:17,236
aux plateformes ARMv7 "thumb mode" et 64-bit.

302
00:16:17,236 --> 00:16:22,287
Nous ajouterons aussi les sorties pour les machines virtuelles.

303
00:16:22,287 --> 00:16:26,207
JavaScript, code objet pour la JVM… Dex pour Dalvik

304
00:16:26,207 --> 00:16:30,153
comme alternative à la JVM sur Android.

305
00:16:30,153 --> 00:16:34,462
Et MSIL, nommé ainsi pour le code objet 

306
00:16:34,462 --> 00:16:37,043
de la plateforme .NET.

307
00:16:37,043 --> 00:16:39,737
L'éditeur de liens supporte les formats principaux.

308
00:16:39,737 --> 00:16:43,532
Nous l'étendrons aux bibliothèques statiques.

309
00:16:43,532 --> 00:16:46,418
Vous pourrez compiler un programme Red

310
00:16:46,418 --> 00:16:51,578
sous forme de bibliothèque statique pour pouvoir

311
00:16:51,578 --> 00:16:55,233
le lier ensuite avec une autre chaîne de compilation, comme C.

312
00:16:55,233 --> 00:16:59,655
C'est une autre manière de diffuser Red

313
00:16:59,655 --> 00:17:02,448
et de permettre aux gens de l'utiliser

314
00:17:02,448 --> 00:17:04,962
en complément de leurs langages et applications.

315
00:17:04,962 --> 00:17:09,242
Ensuite nous nous rapprochons également du noyau

316
00:17:09,242 --> 00:17:14,305
et proposerons un support pour écrire des pilotes,

317
00:17:14,305 --> 00:17:19,234
ou même un système d'exploitation entier,

318
00:17:19,234 --> 00:17:21,787
directement depuis Red.

319
00:17:21,787 --> 00:17:24,199
Nous avons un support expérimental

320
00:17:24,199 --> 00:17:27,504
de pilotes Windows, déjà fonctionnel.

321
00:17:27,504 --> 00:17:31,980
S'il y a des développeurs noyau parmi nous,

322
00:17:31,980 --> 00:17:34,213
c'est le moment de vous éclatez. :-P

323
00:17:34,213 --> 00:17:37,458
Enfin : une chose qui n'existe pas à ma connaissance

324
00:17:37,458 --> 00:17:40,247
dans la chaîne de compilation C classique :

325
00:17:40,247 --> 00:17:42,530
nous aurons une couche d'empaquetage

326
00:17:42,530 --> 00:17:46,044
elle n'est pas encore implémentée, mais c'est pour bientôt.

327
00:17:46,044 --> 00:17:51,589
Nous commencerons par la sortie Android APK.

328
00:17:51,589 --> 00:17:54,697
L'objet de cette couche est uniquement

329
00:17:54,697 --> 00:17:58,850
de collecter plusieurs fichiers, de les formater

330
00:17:58,850 --> 00:18:03,445
et de les empaqueter suivant les spécificités de la plateforme cible.

331
00:18:03,445 --> 00:18:06,426
Nous supporterons Android et iOS

332
00:18:06,426 --> 00:18:08,997
Mais il sera aussi possible d'empaqueter

333
00:18:08,997 --> 00:18:13,409
des applications web.

334
00:18:13,409 --> 00:18:17,371
Comme Java avec son format .WAR

335
00:18:17,371 --> 00:18:20,196
qui a des capacités intéressantes

336
00:18:20,196 --> 00:18:23,489
comme simplifier le déploiement d'applications web

337
00:18:23,489 --> 00:18:25,276
en versionnant les livrables

338
00:18:25,276 --> 00:18:27,050
pour permettre de retirer un déploiement

339
00:18:27,050 --> 00:18:29,342
ce qui est une excellente chose à avoir.

340
00:18:29,342 --> 00:18:31,027
Un autre aspect de la chaîne de compilation

341
00:18:31,027 --> 00:18:32,544
est qu'actuellement elle est 

342
00:18:32,544 --> 00:18:36,774
bootstrappée avec Rebol 2.

343
00:18:36,774 --> 00:18:40,686
Nous sommes dessus depuis déjà deux ans.

344
00:18:40,686 --> 00:18:46,907
La version finale de Red aura un compilateur JIT

345
00:18:46,907 --> 00:18:50,717
Pour ça, nous devons nous auto-héberger.

346
00:18:50,717 --> 00:18:54,347
Nous avons donc besoin d'un Red écrit en Red.

347
00:18:54,347 --> 00:18:58,587
C'est la seule manière d'avoir un compilateur JIT propre.

348
00:18:58,587 --> 00:19:03,543
Nous travaillerons probablement sur ce sujet l'année à venir.

349
00:19:03,543 --> 00:19:07,550
J'ai quelques diapos sur le langage Red lui-même.

350
00:19:07,550 --> 00:19:10,796
Mais je ne veux pas trop entrer dans les détails

351
00:19:10,796 --> 00:19:13,394
parce que ce serait trop long.

352
00:19:13,394 --> 00:19:18,018
La première chose à comprendre à propos de Red

353
00:19:18,018 --> 00:19:21,098
est qu'il est très proche de Rebol.

354
00:19:21,098 --> 00:19:26,585
Vous avez les principales caractéristiques de Rebol

355
00:19:26,585 --> 00:19:31,588
tel que la portée définitionnelle et la liaison dynamique.

356
00:19:31,588 --> 00:19:37,178
Vous avez aussi la possibilité de programmer en Red

357
00:19:37,178 --> 00:19:40,106
en utilisant le paradigme de votre choix.

358
00:19:40,106 --> 00:19:43,031
"Pradigme-agnostique" est une expression

359
00:19:43,031 --> 00:19:46,673
de Gabriele (Santilli) que j'aime particulièrement

360
00:19:46,673 --> 00:19:50,013
parce qu'elle exprime bien cette habileté

361
00:19:50,013 --> 00:19:53,878
à ne pas être contraint par un paradigme quelconque.

362
00:19:55,318 --> 00:19:59,298
Une différence entre Red et Rebol

363
00:19:59,298 --> 00:20:05,376
est que Red permet de typer facultativement

364
00:20:05,376 --> 00:20:09,756
les variables locales ainsi que la valeur

365
00:20:09,756 --> 00:20:12,147
de retour des functions.

366
00:20:12,147 --> 00:20:17,048
En Rebol, ça n'a pas de sens parce que

367
00:20:17,048 --> 00:20:25,102
c'est un interpréteur, et il n'y a pas de valeur.

368
00:20:25,102 --> 00:20:27,874
Mais pour un compilateur, c'est très utile.

369
00:20:27,874 --> 00:20:33,604
Parce que l'annotation des types des fonctions

370
00:20:33,604 --> 00:20:37,791
permet au compilateur de produire

371
00:20:37,791 --> 00:20:43,616
du code plus spécifique, rapide et efficace

372
00:20:43,616 --> 00:20:46,818
que sans ces annotations.

373
00:20:47,728 --> 00:20:53,186
Red est "facultativement typé". Donc vous pouvez typer ou pas.

374
00:20:53,186 --> 00:20:56,989
Ça dépend de vos besoins, ou de la façon dont vous programmez.

375
00:20:56,989 --> 00:20:59,333
Vous pouvez aussi épouser la manière de Rebol

376
00:20:59,333 --> 00:21:01,619
qui est très souple.

377
00:21:01,619 --> 00:21:06,168
Mais vous obtiendrez des performances inférieurs.

378
00:21:06,168 --> 00:21:08,549
Ou vous pouvez le faire en statique

379
00:21:08,549 --> 00:21:10,581
en indiquant tous les types

380
00:21:10,581 --> 00:21:13,702
et le compilateur sera capable de mieux vérifier les types

381
00:21:13,702 --> 00:21:16,969
et de fournir des avertissements et messages d'erreurs

382
00:21:16,969 --> 00:21:21,230
à la compilation au lieu de l'exécution.

383
00:21:21,230 --> 00:21:28,353
Si vous n'utilisez pas les annotations de type

384
00:21:28,353 --> 00:21:31,687
le compilateur sera encore capable dans

385
00:21:31,687 --> 00:21:34,141
certains cas d'inférer seul les types.

386
00:21:34,141 --> 00:21:36,654
Ainsi, il sera capable de deviner les types pour vous.

387
00:21:36,654 --> 00:21:41,093
Mais Red, comme Rebol, est un langage très dynamique

388
00:21:41,093 --> 00:21:48,734
et les cas où le moteur d'inférence ne peut pas

389
00:21:48,734 --> 00:21:53,581
deviner le type sont très limités.

390
00:21:53,581 --> 00:21:56,756
Donc, ça aidera un peu, mais pas tellement.

391
00:21:56,756 --> 00:22:01,167
Nous avons biensûr le support d'Unicode.

392
00:22:01,167 --> 00:22:04,623
Le code source de Red est en UTF-8.

393
00:22:04,623 --> 00:22:09,567
Nous fournirons des codecs externes pour les autres formats.

394
00:22:09,567 --> 00:22:16,728
En interne, à la base, Red stocke et gère

395
00:22:16,728 --> 00:22:20,036
les chaînes Unicode comme Python

396
00:22:20,036 --> 00:22:22,719
dans ses dernières versions.

397
00:22:22,719 --> 00:22:29,671
Le stockage interne utilise une taille fixe.

398
00:22:29,671 --> 00:22:35,382
Mais il peut utiliser de 1 à 4 octets

399
00:22:35,382 --> 00:22:37,921
par point.

400
00:22:37,921 --> 00:22:40,144
Et le système s'adapte automatiquement

401
00:22:40,144 --> 00:22:43,224
et ajuste la taille suivant l'entrée

402
00:22:43,224 --> 00:22:48,908
et les modifications que vous pouvez faire sur une chaîne.

403
00:22:48,908 --> 00:22:54,977
Une autre partie très importante de Red

404
00:22:54,977 --> 00:22:57,640
est le support de la concurrence.

405
00:22:57,640 --> 00:23:00,108
Pour le moment ce n'est pas implémenté

406
00:23:00,108 --> 00:23:04,207
donc je ne m'étendrais pas sur ce point.

407
00:23:04,207 --> 00:23:09,102
Nous voulons supporter deux choses en particulier :

408
00:23:09,102 --> 00:23:11,330
Le parallélisme des tâches

409
00:23:11,330 --> 00:23:15,331
pour exécuter plusieurs threads

410
00:23:15,331 --> 00:23:18,367
en parallèle sur plus d'un cœur.

411
00:23:18,367 --> 00:23:21,891
Nous utiliserons surement l'abstraction par Acteur.

412
00:23:21,891 --> 00:23:26,693
Mais il y a d'autres abstractions

413
00:23:26,693 --> 00:23:31,042
qui depuis le début de Red

414
00:23:31,042 --> 00:23:34,926
ont suscité beaucoup d'intérêt, comme les Go routines

415
00:23:34,926 --> 00:23:38,981
qui sont devenues un point d'attraction

416
00:23:38,981 --> 00:23:40,645
du langage Go.

417
00:23:40,645 --> 00:23:43,082
C'est peut-être une chose à considérer

418
00:23:43,082 --> 00:23:45,725
pour Red aussi, à voir…

419
00:23:45,725 --> 00:23:48,651
en plus ou en remplacement des acteurs

420
00:23:48,651 --> 00:23:50,974
ou d'autres types d'abstraction

421
00:23:50,974 --> 00:23:54,765
Lorsque nous serons arrivés à ce point

422
00:23:54,765 --> 00:23:57,311
nous devrons réviser tous les choix

423
00:23:57,311 --> 00:23:59,900
d'implémentation et voir

424
00:23:59,900 --> 00:24:03,665
si nous pouvons les mettre à jour 

425
00:24:03,665 --> 00:24:06,840
en copiant d'autres strategies payantes.

426
00:24:06,840 --> 00:24:09,047
Nous voulons aussi avoir un certain niveau

427
00:24:09,047 --> 00:24:13,712
de parallélisme des données en utilisant

428
00:24:13,712 --> 00:24:16,582
soit les instructions SIMD ou le multicœur.

429
00:24:16,582 --> 00:24:19,851
Donc, fondamentalement, ça utilisera la capacité

430
00:24:19,851 --> 00:24:25,917
de paralléliser des series Red.

431
00:24:25,917 --> 00:24:30,758
Nous voulons aussi nous occuper d'une chose

432
00:24:30,758 --> 00:24:33,476
que Rebol a presque ignoré jusque là :

433
00:24:33,476 --> 00:24:36,231
Comment fabriquer un dialecte ?

434
00:24:36,231 --> 00:24:38,956
Ou comment implémenter un DSL ?

435
00:24:38,956 --> 00:24:41,438
Rebol est exceptionnel pour ça.

436
00:24:41,438 --> 00:24:44,368
C'est probablement le meilleur outil

437
00:24:44,368 --> 00:24:45,658
parce qu'il possède PARSE et parce

438
00:24:45,658 --> 00:24:48,084
qu'il a certaines qualités intéressantes

439
00:24:48,084 --> 00:24:50,101
qui en font un excellent choix.

440
00:24:50,101 --> 00:24:54,911
De toute manière, fabriquer un dialecte

441
00:24:54,911 --> 00:24:57,186
est une tâche difficile en soi.

442
00:24:57,186 --> 00:24:59,774
Parce que vous devez le concevoir d'abord.

443
00:24:59,774 --> 00:25:01,425
C'est déjà un gros travail.

444
00:25:01,425 --> 00:25:03,427
Ensuite seulement vous pouvez l'implémenter.

445
00:25:03,427 --> 00:25:07,113
Et implémenter un DSL ou un dialecte,

446
00:25:07,113 --> 00:25:11,151
c'est implémenter un interpréteur ou un compilateur.

447
00:25:11,151 --> 00:25:17,524
Dans ce cas de figure vous êtes presque seul avec le code.

448
00:25:17,524 --> 00:25:20,462
Donc, vous n'avez pas vraiment de framework

449
00:25:20,462 --> 00:25:22,134
pour cette tâche.

450
00:25:22,134 --> 00:25:25,585
Il est possible de tirer parti des qualités

451
00:25:25,585 --> 00:25:27,439
de Rebol dans Red

452
00:25:27,439 --> 00:25:29,507
ou peut-être même en Rebol

453
00:25:29,507 --> 00:25:32,431
pour fabriquer une sorte de méta-DSL

454
00:25:32,431 --> 00:25:38,218
qui permettra d'être beaucoup plus productif

455
00:25:38,218 --> 00:25:40,920
et vous donnera un framework

456
00:25:40,920 --> 00:25:44,260
pour construire de nouveaux dialecte et de nouveaux DSLs.

457
00:25:44,260 --> 00:25:47,156
Fondamentalement, ce sera quelque chose comme

458
00:25:47,156 --> 00:25:50,105
une version haut niveau de PARSE.

459
00:25:50,105 --> 00:25:52,557
Vous pouvez y penser, par exemple,

460
00:25:52,557 --> 00:25:59,457
comme à un PARSE avec une boucle événementielle,

461
00:25:59,457 --> 00:26:03,732
laquelle sera cachée.

462
00:26:03,732 --> 00:26:07,914
Quelque chose comme Visual Basic en son temps.

463
00:26:07,914 --> 00:26:11,544
Vous implémenterez seulement les événements

464
00:26:11,544 --> 00:26:17,351
pour créer votre DSL comme un interpréteur ou un compilateur.

465
00:26:17,351 --> 00:26:26,170
Alors que fait le compilateur Red ?

466
00:26:26,170 --> 00:26:30,786
Le compilateur Red convertie le code Red

467
00:26:30,786 --> 00:26:34,944
en Red / System qui est une couche de bas niveau.

468
00:26:34,944 --> 00:26:40,093
Je voulais juste vous montrer à quoi ça ressemble.

469
00:26:40,093 --> 00:26:45,535
Donc, si nous prenons une expression Red très simple

470
00:26:45,535 --> 00:26:48,493
le compilateur Red l'analyse

471
00:26:48,493 --> 00:26:53,88
en utilisant une pile abstraite pour placer les arguments

472
00:26:53,884 --> 00:26:58,480
En fait, il utilise deux piles : une pour les appels

473
00:26:58,480 --> 00:27:01,819
et une autre pour les arguments.

474
00:27:01,819 --> 00:27:05,361
Puis l'émetteur va produire le code Red / System

475
00:27:05,361 --> 00:27:08,363
sur cette base.

476
00:27:08,363 --> 00:27:10,782
Donc ce que vous voyez à droite

477
00:27:10,782 --> 00:27:14,350
est une sortie Red / System pour l'expression

478
00:27:14,350 --> 00:27:18,061
qui appelle l'API du runtime Red.

479
00:27:22,651 --> 00:27:28,334
Un autre aspect singulier du compilateur Red

480
00:27:28,334 --> 00:27:29,406
et du langage Red

481
00:27:29,406 --> 00:27:34,169
est la combinaison de plusieurs types d'approches

482
00:27:34,169 --> 00:27:37,846
qui est quelque chose d'unique, je pense.

483
00:27:37,846 --> 00:27:41,156
Donc, fondamentalement, vous avez un compilateur statique.

484
00:27:41,156 --> 00:27:44,538
Ce compilateur statique générera le code

485
00:27:44,538 --> 00:27:46,584
avec un interprète à l'intérieur, et demain

486
00:27:46,584 --> 00:27:51,606
un compilateur JIT embarqué à l'intérieur de votre exécutable.

487
00:27:51,606 --> 00:27:58,368
Ces trois parties seront en mesure de travailler ensemble

488
00:27:58,368 --> 00:28:02,334
d'une manière très collaborative.

489
00:28:02,334 --> 00:28:05,191
Par exemple, le code compilé

490
00:28:05,191 --> 00:28:08,428
peut appeler un interpréteur interne

491
00:28:08,428 --> 00:28:12,551
qui lui-même peut appeler de nouveau le code compilé.

492
00:28:12,551 --> 00:28:16,189
Même chose pour le compilateur JIT.

493
00:28:16,189 --> 00:28:19,973
Il est un peu abstrait, mais je peux vous montrer ça à la fin

494
00:28:19,973 --> 00:28:21,707
de la présentation du diaporama

495
00:28:21,707 --> 00:28:23,904
avec un cas pratique d'une telle approche.

496
00:28:23,904 --> 00:28:28,901
En fait, c'est un outil très puissant

497
00:28:28,901 --> 00:28:35,136
pour résoudre des cas à la sémantique très complexe.

498
00:28:35,136 --> 00:28:39,575
Par exemple, la compilation de code symbolique,

499
00:28:39,575 --> 00:28:42,229
qui est quelque chose de difficile à faire.

500
00:28:42,229 --> 00:28:43,740
Mais si vous combinez différentes approches

501
00:28:43,740 --> 00:28:49,758
vous pouvez trouver une solution très efficace.

502
00:28:49,758 --> 00:28:54,407
Ceci est juste un exemple très simple

503
00:28:54,407 --> 00:29:00,583
de ce à quoi ressemble du code Red.

504
00:29:00,583 --> 00:29:03,399
Vous avez le même principe en Rebol.

505
00:29:03,399 --> 00:29:08,492
Vous avez un marqueur qui est [Red]

506
00:29:08,492 --> 00:29:13,355
suivi par un bloc qui constitue un entête

507
00:29:13,355 --> 00:29:17,254
et votre code vient après ça.

508
00:29:17,254 --> 00:29:19,921
Hello world s'écrit seulement [print "Hello World"]

509
00:29:19,921 --> 00:29:22,312
comme en Rebol, et le reste du code

510
00:29:22,312 --> 00:29:26,336
ressemble probablement beaucoup à du Rebol

511
00:29:26,336 --> 00:29:32,270
excepté peut-être pour [return: [type!]]

512
00:29:32,270 --> 00:29:36,908
qui est facultatif, mais c'est le genre de type

513
00:29:36,908 --> 00:29:40,409
facultatif dont j'ai parlé avant.

514
00:29:40,409 --> 00:29:43,389
Vous avez un exemple ici.

515
00:29:43,389 --> 00:29:48,196
Il n'est pas obligatoire, mais si vous le mettez

516
00:29:48,196 --> 00:29:54,758
le compilateur générera un code meilleur et plus rapide.

517
00:29:54,758 --> 00:29:59,006
Ensuite une vue plus détaillé

518
00:29:59,006 --> 00:30:02,905
des entrailles de Red, et des différentes parties

519
00:30:02,905 --> 00:30:05,640
afin que vous ayez une meilleure idée de la façon dont

520
00:30:05,640 --> 00:30:09,472
toutes ces choses coopèrent.

521
00:30:09,472 --> 00:30:13,971
Si nous partons de l'homme sur le droit

522
00:30:13,971 --> 00:30:17,047
nous avons un script frontal en ligne de commande

523
00:30:17,047 --> 00:30:19,852
écrit en Rebol

524
00:30:19,852 --> 00:30:25,527
et derrière lui, nous avons les deux piles

525
00:30:25,527 --> 00:30:28,351
pour les deux compilateurs. Une pour Red, qui est

526
00:30:28,351 --> 00:30:32,604
plus courte parce que c'est seulement un émetteur de code Red / System.

527
00:30:32,604 --> 00:30:34,311
Et une pour Red / System

528
00:30:34,311 --> 00:30:36,720
qui descend vers l'empaqueteur

529
00:30:36,720 --> 00:30:41,424
et peut émettre et produire des fichiers binaires.

530
00:30:41,424 --> 00:30:47,027
Tout ceci est écrit en rebol 2.

531
00:30:47,027 --> 00:30:52,304
Sur le côté gauche, vous avez le runtime de Red.

532
00:30:52,304 --> 00:30:55,586
Qui est un gros morceau de code,

533
00:30:55,586 --> 00:30:59,651
en fait probablement le plus grand de tous.

534
00:30:59,651 --> 00:31:02,964
qui est écrit en Red / System.

535
00:31:02,964 --> 00:31:06,914
Vous trouverez toute la puissance réelle de ce côté-là

536
00:31:06,914 --> 00:31:08,649
par exemple, tous les types de données,

537
00:31:08,649 --> 00:31:12,104
tous les fonctions natives, tout le code mezzanine,

538
00:31:12,104 --> 00:31:16,600
l'interpréteur, les ponts, — comme java

539
00:31:16,600 --> 00:31:19,025
qui est déjà disponible.

540
00:31:19,025 --> 00:31:23,058
Le gestionnaire de mémoire et les interfaces de bas niveau

541
00:31:23,058 --> 00:31:26,485
aux parties sous-jacentes.

542
00:31:26,485 --> 00:31:28,829
Par exemple vous avez un accès direct

543
00:31:28,829 --> 00:31:31,993
à l'API de l'OS mais aussi au noyau.

544
00:31:31,993 --> 00:31:34,001
Sur Linux vous pouvez faire des appels système directement.

545
00:31:34,001 --> 00:31:38,340
Et si nécessaire vous pouvez aller jusqu'au

546
00:31:38,340 --> 00:31:41,869
matériel et appeler des fonctionnalités de très bas niveau.

547
00:31:44,599 --> 00:31:46,625
Peut-être ais-je oublié de parler de la console Red

548
00:31:46,625 --> 00:31:49,985
qui est aussi écrite en Red

549
00:31:49,985 --> 00:31:52,946
et Red / System pour les parties de bas niveau.

550
00:31:53,816 --> 00:31:57,120
À propos de Red / System… J'ai une petite présentation

551
00:31:57,120 --> 00:32:01,142
pour demain spécifique à Red / System, parce que

552
00:32:01,142 --> 00:32:06,082
c'est le genre de chose qui est nouvelle comparé à Rebol.

553
00:32:06,082 --> 00:32:08,541
J'ai juste une diapo sur Red / System

554
00:32:08,541 --> 00:32:10,120
pour vous donner un aperçu.

555
00:32:10,120 --> 00:32:16,748
En gros c'est le type de chose réalisée en C

556
00:32:16,748 --> 00:32:20,078
mais avec une syntaxe Red.

557
00:32:20,078 --> 00:32:22,760
C'est dont souvent comme coder en Red

558
00:32:22,760 --> 00:32:29,827
mais avec des types de données et des actions de très bas niveau.

559
00:32:29,827 --> 00:32:32,630
C'est compilé statiquement.

560
00:32:32,630 --> 00:32:35,956
Ce n'est pas optimisé pour le moment. :-)

561
00:32:35,956 --> 00:32:40,988
En étant seulement 4 fois plus lent que du C

562
00:32:40,988 --> 00:32:43,849
optimisé et compilé avec l'option « -O2 ».

563
00:32:43,849 --> 00:32:47,674
Donc, c'est d'un bon niveau, voir très très bon.

564
00:32:47,674 --> 00:32:51,224
Parce qu'une fois que nous ajouterons les couches

565
00:32:51,224 --> 00:32:53,398
d'optimisation nous serons très très proche du C.

566
00:32:53,398 --> 00:32:57,362
Nous ne le battrons probablement pas, mais ce n'est pas le but.

567
00:32:57,362 --> 00:33:00,014
Mais nous serons très, vraiment très proche.

568
00:33:00,014 --> 00:33:05,041
Red / System sera une alternative réellement viable au C.

569
00:33:05,041 --> 00:33:09,334
Et il fait déjà des merveilles pour certains

570
00:33:09,334 --> 00:33:11,936
traitement d'image par exemple

571
00:33:11,936 --> 00:33:15,680
que Bo (Lechnowsky) vous montrera demain.

572
00:33:15,680 --> 00:33:17,968
Quelque chose que le langage C n'a pas

573
00:33:17,968 --> 00:33:22,310
ou que la plupart des langages de très bas niveau n'ont pas :

574
00:33:22,310 --> 00:33:24,792
Red / System possède des espaces de nom

575
00:33:24,792 --> 00:33:27,024
qui sont quelque chose comme les contextes en Rebol

576
00:33:27,024 --> 00:33:33,586
mais très statique, donc nous utilisons le mot clef CONTEXT

577
00:33:33,586 --> 00:33:35,909
pour les déclarer en Red /System aussi.

578
00:33:35,909 --> 00:33:38,936
Et vous pouvez aussi utiliser le mot clef WITH

579
00:33:38,936 --> 00:33:43,428
pour mettre une partie de votre code dans un contexte

580
00:33:43,428 --> 00:33:47,121
quelque chose comme des déclarations dans d'autres langues.

581
00:33:47,121 --> 00:33:52,155
Nous avons un système de type très limité en Red / Système

582
00:33:52,155 --> 00:34:00,763
Nous avons neuf types.

583
00:34:00,763 --> 00:34:05,467
En gros les mêmes types de données qu'en C.

584
00:34:05,467 --> 00:34:11,372
Les fonctions ne sont pas un type de données de première classe complet

585
00:34:11,372 --> 00:34:16,155
J'ai beaucoup hésité à ce sujet, parce que…

586
00:34:16,155 --> 00:34:19,723
Si j'en fait un type de données de première classe complet

587
00:34:19,723 --> 00:34:22,571
Les gens commenceront à me demander

588
00:34:22,571 --> 00:34:24,925
de faire de Red /System un langage fonctionnel.

589
00:34:24,925 --> 00:34:27,986
ce qui est possible mais ce n'est pas le but.

590
00:34:27,986 --> 00:34:32,540
Ça ne sert pas notre objectif, donc je suis assez réticent

591
00:34:32,540 --> 00:34:37,835
à ajouter de nouvelle fonctionnalités à ce type de données.

592
00:34:37,835 --> 00:34:40,324
nous avons l'inférence de type,

593
00:34:40,324 --> 00:34:42,395
donc nous n'avons pas à spécifier le type de données

594
00:34:42,395 --> 00:34:45,235
d'une variable locale, le compilateur s'en occupe.

595
00:34:45,235 --> 00:34:48,666
Nous avons aussi un transtypage limitée

596
00:34:48,666 --> 00:34:52,473
pour les types compatibles.

597
00:34:52,473 --> 00:34:56,548
Et nous avons quelque chose que C n'a pas

598
00:34:56,548 --> 00:35:04,017
mais que C++ a, un certain niveau ne réflexivité.

599
00:35:04,017 --> 00:35:07,445
Donc vous pouvez déclarer une fonction en Red / System

600
00:35:07,445 --> 00:35:12,157
avec un nombre d'arguments variable

601
00:35:12,157 --> 00:35:14,311
et vous pouvez mettre des parenthèses autour

602
00:35:14,311 --> 00:35:16,341
et à l'intérieur du corps de cette fonction

603
00:35:16,341 --> 00:35:19,854
vous pouvez parcourir cette liste d'arguments

604
00:35:19,854 --> 00:35:23,665
et vous pouvez interroger leur type.

605
00:35:23,665 --> 00:35:26,778
C'est une fonctionnalité très puissante

606
00:35:26,778 --> 00:35:32,499
et actuellement Kaj de Vos l'utilise pour

607
00:35:32,499 --> 00:35:36,773
fabriquer un dialecte VID en Red / System

608
00:35:36,773 --> 00:35:38,853
ce qui est un exploit en fait,

609
00:35:38,853 --> 00:35:42,243
parce que nous n'avons pas de symboles en Red / System :-)

610
00:35:42,243 --> 00:35:47,656
Donc il ressemble à VID, mais il utilise cette fonctionnalité

611
00:35:47,656 --> 00:35:50,854
pour s'exécuter, et c'est vraiment super.

612
00:35:50,854 --> 00:35:55,630
Nous avons aussi un préprocesseur dans Red / System

613
00:35:55,630 --> 00:36:01,262
mais je tiens à le retirer de la prochaine version majeure

614
00:36:01,262 --> 00:36:06,590
parce que nous avons plus de problèmes avec

615
00:36:06,590 --> 00:36:11,779
lui que d'avantages.

616
00:36:11,779 --> 00:36:13,727
Nous en garderons une partie

617
00:36:13,727 --> 00:36:16,774
mais nous devons le repenser, le redessiner.

618
00:36:16,774 --> 00:36:20,186
#define est une option très puissante

619
00:36:20,186 --> 00:36:22,128
parce que ça vous donne presque la même puissance

620
00:36:22,128 --> 00:36:27,392
que les macros C, de sorte que vous pouvez même utiliser des paramètres.

621
00:36:27,392 --> 00:36:34,001
Nous voulons aussi avoir un support de processeur bas niveau.

622
00:36:34,001 --> 00:36:39,385
Actuellement nous avons accès aux registres d'un processeur

623
00:36:39,385 --> 00:36:41,747
dans un style cross-plateforme.

624
00:36:41,747 --> 00:36:43,617
Nous accédons directement à la pile —

625
00:36:43,617 --> 00:36:46,743
vous pouvez manipuler la pile native

626
00:36:46,743 --> 00:36:49,724
au niveau de Red / System dans un style cross-plateforme.

627
00:36:49,724 --> 00:36:55,232
Nous ajouterons le support des interruptions d'E/S

628
00:36:55,232 --> 00:37:02,004
et d'autres fonctionnalités très courantes des processeurs.

629
00:37:02,004 --> 00:37:07,289
Peut-être nous ajouterons le support de l'assembleur en ligne

630
00:37:07,289 --> 00:37:10,224
mais ce n'est pas un besoin pressant.

631
00:37:10,224 --> 00:37:13,926
Quelques indicateurs sur le projet Red.

632
00:37:13,926 --> 00:37:18,596
Il est BSD, pour la plupart du code de base.

633
00:37:18,596 --> 00:37:22,560
Et les parties du runtime de Red sont sous « BSL »

634
00:37:22,560 --> 00:37:25,945
la « Boost Software License »

635
00:37:25,945 --> 00:37:32,015
qui est encore plus libérale que les BSD.

636
00:37:32,015 --> 00:37:34,999
Vous avez même moins de restriction que BSD.

637
00:37:34,999 --> 00:37:37,856
Nous sommes sur GitHub depuis le début

638
00:37:37,856 --> 00:37:43,033
nous avons 9 committers… Je pense que cela est faux

639
00:37:43,033 --> 00:37:46,604
nous en avons 11 à ce jour.

640
00:37:46,604 --> 00:37:50,335
Nous avons plus de 2000 commits

641
00:37:50,335 --> 00:37:52,867
sans compter les commits de fusion.

642
00:37:52,867 --> 00:37:58,035
Nous avons environ 500 tickets dans le bug tracker

643
00:37:58,035 --> 00:38:00,490
mais ils sont presque tous fermés

644
00:38:00,490 --> 00:38:03,576
nous essayons de les résoudre aussi vite que possible

645
00:38:03,576 --> 00:38:05,852
pour éviter de les entasser.

646
00:38:05,852 --> 00:38:07,516
Parce que s'il s'entassent,

647
00:38:07,516 --> 00:38:10,788
il devient presque impossible d'en venir à bout.

648
00:38:10,788 --> 00:38:14,469
Nous avons vraiment besoin de les garder très très bas.

649
00:38:14,469 --> 00:38:16,696
Nous avons beaucoup de tests unitaires

650
00:38:16,696 --> 00:38:19,569
qui sont écrit par Peter Wood

651
00:38:19,569 --> 00:38:23,180
qui a fait un grand travail sur ça.

652
00:38:23,180 --> 00:38:25,361
c'est très, très utile.

653
00:38:25,361 --> 00:38:27,897
Et là, vous avez un petit indicateur

654
00:38:27,897 --> 00:38:30,019
de la taille du code source

655
00:38:30,019 --> 00:38:32,026
pour les parties Red et Red / Systen.

656
00:38:32,026 --> 00:38:34,073
Pour le compilateur, pour l'éditeur de liens.

657
00:38:34,073 --> 00:38:35,923
vous pouvez voir par vous-même

658
00:38:35,923 --> 00:38:37,897
que c'est vraiment un code compacte.

659
00:38:37,897 --> 00:38:41,619
On peut faire beaucoup de choses, grâce à Rebol :-)

660
00:38:41,619 --> 00:38:45,444
On peut réaliser beaucoup avec une petit base de code

661
00:38:45,444 --> 00:38:47,680
et en peu de lignes.

662
00:38:47,680 --> 00:38:50,946
Vous pouvez le comparer aux autres chaînes de compilation

663
00:38:50,946 --> 00:38:55,006
et vous trouverez souvent une différence

664
00:38:55,006 --> 00:38:57,700
de un à deux ordres de grandeur.

665
00:38:57,700 --> 00:38:59,251
Biensûr ils couvrent probablement

666
00:38:59,251 --> 00:39:01,428
un éventail plus large,

667
00:39:01,428 --> 00:39:06,544
mais avec une si petite base de code

668
00:39:06,544 --> 00:39:09,376
nous pouvons déjà couvrir beaucoup de terrain.

669
00:39:09,376 --> 00:39:14,352
Nous avons encore beaucoup de travail

670
00:39:14,352 --> 00:39:18,824
C'est un gros chantier.

671
00:39:18,824 --> 00:39:23,389
Il manque encore de grosses parties.

672
00:39:23,389 --> 00:39:30,653
Nous avons encore besoin de supporter le paradigme objet.

673
00:39:30,653 --> 00:39:34,083
Nous n'avons pas encore de gestion d'erreur appropriée

674
00:39:34,083 --> 00:39:36,009
parce que nous avons besoins des objets pour ça !

675
00:39:36,009 --> 00:39:40,244
Nous manquons de vérification de type pour les arguments

676
00:39:40,244 --> 00:39:42,915
dans certaines parties du compilateur.

677
00:39:42,915 --> 00:39:45,487
Nous n'avons pas encore d'E/S, mais…

678
00:39:45,487 --> 00:39:50,941
évidemment les objets et les E/S sont prioritaires sur la liste.

679
00:39:50,941 --> 00:39:54,697
Ils vont probablement être implémentés cet été.

680
00:39:54,697 --> 00:39:59,696
Nous voulons un premier support de la concurrence

681
00:39:59,696 --> 00:40:05,334
dans la version 1.0, et nous voulons naturellement aussi

682
00:40:05,334 --> 00:40:09,829
une compilation modulaire et un système de module.

683
00:40:09,829 --> 00:40:14,260
Nous fournirons probablement un IDE minimaliste pour Red

684
00:40:14,260 --> 00:40:18,032
qui sera surement juste un éditeur de code

685
00:40:18,032 --> 00:40:23,468
plus un débogueur… et nous l'étendrons

686
00:40:23,468 --> 00:40:27,570
dans les versions suivantes.

687
00:40:27,570 --> 00:40:31,050
Nous voulons aussi une documentation complète

688
00:40:31,050 --> 00:40:37,597
de sorte que c'est un grand frein pour sortir la 1.0

689
00:40:37,597 --> 00:40:41,836
nous avons donc beaucoup de travail pour écrire la documentation

690
00:40:41,836 --> 00:40:43,650
et des tutoriels.

691
00:40:43,650 --> 00:40:46,529
Et biensûr, nous avons besoin d'un nouveau site Web

692
00:40:46,529 --> 00:40:49,753
pour le lancement de la version 1.0.

693
00:40:51,613 --> 00:40:54,761
mais ce n'est pas tout… :-)

694
00:40:54,761 --> 00:40:57,310
Ce n'est pas le vrai Red.

695
00:40:57,310 --> 00:41:00,523
Le vrai Red sera la version 2.0.

696
00:41:00,523 --> 00:41:05,640
Et nous avons une très bonne présentation pour ça (rires)

697
00:41:05,640 --> 00:41:07,538
Alors, c'est quoi « Le vrai Red » ?

698
00:41:07,538 --> 00:41:11,329
En fait, ce que je vous ai présenté aujourd'hui

699
00:41:11,329 --> 00:41:13,583
est une sorte d'échafaudage.

700
00:41:13,583 --> 00:41:15,570
Parce que le vrai c'est ça d'abord.

701
00:41:15,570 --> 00:41:23,308
Le vrai Red sera avant tout un compilateur JIT

702
00:41:23,308 --> 00:41:27,206
capable de travailler aussi comme un compilateur statique.

703
00:41:27,206 --> 00:41:29,613
L'ensemble de l'architecture interne

704
00:41:29,613 --> 00:41:32,929
sera totalement différente de l'actuelle

705
00:41:32,929 --> 00:41:35,846
implémentée dans la versionde bootstrappe.

706
00:41:35,846 --> 00:41:39,254
Il sera greffable

707
00:41:39,254 --> 00:41:40,910
ç-à-d que le compilateur et la chaîne de compilation

708
00:41:40,910 --> 00:41:44,718
seront un shell vide — un framework —

709
00:41:44,718 --> 00:41:49,830
où vous pourrez brancher des modules

710
00:41:49,830 --> 00:41:54,223
pour ajouter des fonctionnalités à chaque étape de compilation.

711
00:41:54,223 --> 00:41:57,606
De l'analyseur à la génération des fichiers.

712
00:41:57,606 --> 00:42:00,981
Vous aurez une API pour travailler avec.

713
00:42:00,981 --> 00:42:03,679
Il fournira un framework

714
00:42:03,679 --> 00:42:07,304
et les modules indispensables

715
00:42:07,304 --> 00:42:10,946
pour avoir le même niveau de fonctionnalité que la version 1.0.

716
00:42:10,946 --> 00:42:15,920
Et cette API sera bien sûr documentée

717
00:42:15,920 --> 00:42:18,986
quiconque sera en mesure de modifier

718
00:42:18,986 --> 00:42:22,012
et d'ajouter de nouvelles fonctionnalités au compilateur

719
00:42:22,012 --> 00:42:25,657
d'une manière très isolée et très structurée.

720
00:42:25,657 --> 00:42:29,935
Cette API peut également être appelée à l'exécution.

721
00:42:29,935 --> 00:42:34,584
Je vous laisse imaginer les options et les possibilités

722
00:42:34,584 --> 00:42:37,270
de la modification du compilateur lui-même

723
00:42:37,270 --> 00:42:38,819
et de l'ensemble des outils à l'exécution.

724
00:42:38,819 --> 00:42:40,186
Il est possible à l'exécution

725
00:42:40,186 --> 00:42:43,657
de modifier le langage lui-même et d'ajouter de nouvelles fonctionnalités.

726
00:42:43,657 --> 00:42:47,107
Cela peut sembler complètement fou

727
00:42:47,107 --> 00:42:48,494
mais c'est quelque chose que d'autres langues

728
00:42:48,494 --> 00:42:53,525
qui grandissent actuellement

729
00:42:53,525 --> 00:42:56,184
font… par exemple, Scala

730
00:42:56,184 --> 00:42:57,921
fait exactement ça.

731
00:42:57,921 --> 00:43:00,094
Et certaines personnes de la communauté Scala

732
00:43:00,094 --> 00:43:04,242
utilisent ce genre de fonction pour faire des merveilles

733
00:43:04,242 --> 00:43:07,042
Par exemple, un gars très intelligent

734
00:43:07,042 --> 00:43:13,634
utilise cette API pour ajouter le support parallèle aux boucles for

735
00:43:13,634 --> 00:43:18,648
en utilisant le GPGPU pour la parallélisation 

736
00:43:18,648 --> 00:43:23,715
qui utilise OpenCL comme couche de bas de niveau.

737
00:43:23,715 --> 00:43:27,094
Voilà une fonctionnalité très puissante

738
00:43:27,094 --> 00:43:31,124
qui permet également une architecture de compilateur

739
00:43:31,124 --> 00:43:37,405
beaucoup plus solide et une ouverture

740
00:43:37,405 --> 00:43:39,391
aux contributeurs plus facile

741
00:43:39,391 --> 00:43:42,666
et plus structurée.

742
00:43:42,666 --> 00:43:45,410
L'implication pour le cœur du code

743
00:43:45,410 --> 00:43:50,145
du compilateur… dans le schéma des entrailles de Red

744
00:43:50,145 --> 00:43:53,929
est sur la partie droite des blocs…

745
00:43:53,929 --> 00:43:56,942
Le code actuel est en Rebol 2

746
00:43:56,942 --> 00:44:00,594
une sorte de code jetable.

747
00:44:00,594 --> 00:44:04,283
Depuis le début, je l'ai écrit très vite

748
00:44:04,283 --> 00:44:08,540
pensant que je le jetterais rapidement

749
00:44:08,540 --> 00:44:10,412
au bout d'un an,

750
00:44:10,412 --> 00:44:14,035
et serait capable de le réécrire aussi vite en Red.

751
00:44:14,035 --> 00:44:18,069
Mais nous avons changé beaucoup de choses dans le projet

752
00:44:18,069 --> 00:44:22,374
nous nous ajustons à l'évolution de l'environnement

753
00:44:22,374 --> 00:44:25,218
et donc nous n'en sommes pas encore là.

754
00:44:25,218 --> 00:44:29,434
nous allons d'abord sortir la version 1.0 bootstrappée

755
00:44:29,434 --> 00:44:32,590
et la 2.0 sera une version auto-hébergée

756
00:44:32,590 --> 00:44:35,173
avec une chaîne de compilation réécrite en Red.

757
00:44:35,173 --> 00:44:41,975
L'ensemble du runtime Red restera le même

758
00:44:41,975 --> 00:44:43,714
parce qu'il est écrit en Red / System

759
00:44:43,714 --> 00:44:47,340
il survivra, et c'est vraiment un gros morceau.

760
00:44:47,340 --> 00:44:50,087
La seule partie qui sera réécrite

761
00:44:50,087 --> 00:44:53,342
sera celle en Rebol 2, qui est

762
00:44:53,342 --> 00:44:56,511
essentiellement les compilateurs Red et Red / System

763
00:44:56,511 --> 00:44:59,654
Juste un dernier mot à propos l'organisation du projet :

764
00:44:59,654 --> 00:45:05,659
nous avons deux collaborateurs sur GitHub

765
00:45:05,659 --> 00:45:10,028
ce qui signifie qu'il y a un admin et deux personnes

766
00:45:10,028 --> 00:45:15,747
qui ont les droits d'administration. Donc si je passe sous un bus

767
00:45:15,747 --> 00:45:21,832
ces deux gars peuvent prendre le code source

768
00:45:21,832 --> 00:45:26,973
du dépôt et s'en occuper.

769
00:45:26,973 --> 00:45:30,940
Nous avons environ 11 contributeurs de code

770
00:45:30,940 --> 00:45:33,673
depuis le début. Nous avons une liste de diffusion.

771
00:45:33,673 --> 00:45:37,359
Nous avons une page Facebook, un canal IRC

772
00:45:37,359 --> 00:45:42,087
avec une joli bot IRC d'Andreas

773
00:45:42,087 --> 00:45:44,471
pour signaler les commits.

774
00:45:44,471 --> 00:45:46,792
Et bien sûr, nous sommes à la recherche d'autres personnes

775
00:45:46,792 --> 00:45:49,389
qui sont intéressés à contribuer

776
00:45:49,389 --> 00:45:52,707
et participer sur tous les plans

777
00:45:52,707 --> 00:45:54,940
parce que c'est vraiment un gros projet…

778
00:45:54,940 --> 00:45:58,775
et nous avons besoin de beaucoup de bras.

779
00:46:00,945 --> 00:46:03,564
Une fois n'est pas coutume :-)

780
00:46:03,564 --> 00:46:09,450
J'ai investi dans ce projet… depuis que j'ai commencé

781
00:46:09,450 --> 00:46:12,146
il y a environ 2 ans et demi…

782
00:46:12,146 --> 00:46:16,020
chaque centime que j'ai pu économiser. :-)

783
00:46:16,020 --> 00:46:20,434
Je crois totalement à ce projet

784
00:46:20,434 --> 00:46:22,075
et à son succès.

785
00:46:22,075 --> 00:46:27,231
Mais j'ai manqué d'argent assez rapidement. :-)

786
00:46:27,231 --> 00:46:30,128
Depuis un an, je vis uniquement sur les dons

787
00:46:30,128 --> 00:46:33,280
que les utilisateurs et les supporters m'envoient.

788
00:46:33,280 --> 00:46:35,522
Je tiens à les remercier beaucoup

789
00:46:35,522 --> 00:46:39,136
parce que je ne serais pas ici sans eux

790
00:46:39,136 --> 00:46:41,448
et Red ne serait pas à ce stade

791
00:46:41,448 --> 00:46:42,987
ou n'existerait probablement pas

792
00:46:42,987 --> 00:46:45,865
si des gens ne m'aidaient pas.

793
00:46:45,865 --> 00:46:49,165
Donc, merci beaucoup, et continuons

794
00:46:49,165 --> 00:46:52,832
à le soutenir pour en faire une réalité.

795
00:46:52,832 --> 00:46:55,053
Merci pour votre attention.

796
00:46:55,053 --> 00:46:59,053
(applaudissements)
