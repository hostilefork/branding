1
00:00:10,593 --> 00:00:14,410
Unser nächster Redner ist Nenad Rakocevic

2
00:00:14,410 --> 00:00:17,039
der uns erzählen wird, "was Red ist"

3
00:00:17,039 --> 00:00:22,496
(Applaus)

4
00:00:22,886 --> 00:00:27,767
Danke Gregg. Und Dankeschön an alle,

5
00:00:27,767 --> 00:00:31,908
die für meine Reisekosten gespendet haben, 

6
00:00:31,908 --> 00:00:33,728
damit ich heute hier sein kann.

7
00:00:33,728 --> 00:00:36,932
Ich habe eine ganze Reihe Vorträge zu Red gehalten,

8
00:00:36,932 --> 00:00:43,013
aber wer Red noch nicht kennt, stellt mir oft 

9
00:00:43,013 --> 00:00:45,517
diese einfache Frage:

10
00:00:45,517 --> 00:00:47,400
"Was genau ist Red eigentlich?",

11
00:00:47,400 --> 00:00:50,166
denn das Projekt hat viele Facetten,

12
00:00:50,166 --> 00:00:51,741
und ich verstehe das.

13
00:00:51,741 --> 00:00:54,042
Also werde ich in diesem Vortrag versuchen, Ihnen

14
00:00:54,042 --> 00:00:58,673
a good view of every part of the project.
einen guten Überblick zu jedem Teil des Projekts zu verschaffen.***

15
00:00:58,673 --> 00:01:02,522
Beginnen wir mit einem Überblick über das Problem.

16
00:01:02,522 --> 00:01:06,517
Das ist nicht mein kartiertes Gehirn.

17
00:01:06,517 --> 00:01:10,566
Das ist ein Computermodell

18
00:01:10,566 --> 00:01:12,772
des bekannten Universums.

19
00:01:12,772 --> 00:01:14,740
Das vermittelt Ihnen einen guten Eindruck

20
00:01:14,740 --> 00:01:18,230
vom Umfang der Aufgabe (Gelächter).

21
00:01:18,230 --> 00:01:20,329
Und nebenbei weist das auf mein

22
00:01:20,329 --> 00:01:23,036
ursprüngliches Berufsziel hin

23
00:01:23,036 --> 00:01:26,011
denn ich studierte Astrophysik

24
00:01:26,011 --> 00:01:30,570
und habe an der Uni zu Informatik gewechselt. 

25
00:01:30,570 --> 00:01:34,589
Meine Ansicht zur Art, wie wir Rechner nutzen

26
00:01:34,589 --> 00:01:38,792
ist, daß wir selbst heute noch einige primitive

27
00:01:38,792 --> 00:01:41,018
tools and techniques.
Werkzeuge und Techniken einsetzen.

28
00:01:41,018 --> 00:01:44,653
So sehr unterscheiden wir uns nicht von diesen beiden,

29
00:01:44,653 --> 00:01:46,357
jedenfalls was unsere Software betrifft.

30
00:01:46,357 --> 00:01:49,283
Wir bauen das immer noch auf eine sehr primitive Art

31
00:01:49,283 --> 00:01:51,928
und Weise, weil wir beständig das Rad neu erfinden

32
00:01:51,928 --> 00:01:54,513
und andauernd die gleichen Fehler begehen,

33
00:01:54,513 --> 00:01:56,041
wieder und wieder

34
00:01:56,041 --> 00:01:58,892
Die KI wird also lachen.

35
00:01:58,902 --> 00:02:02,541
Hoffe ich zumindest. :-) (Gelächter)

36
00:02:02,541 --> 00:02:08,308
Wenn wir also zum Thema zurückkehren,

37
00:02:08,308 --> 00:02:12,563
es gibt wirklich eine Menge Programmiersprachen.

38
00:02:12,563 --> 00:02:14,927
Wenn Sie sich die Liste der Programmiersprachen

39
00:02:14,927 --> 00:02:18,596
auf Wikipedia anschauen, das sind nur die unter 'A'
 
40
00:02:18,596 --> 00:02:23,107
und die Liste ist noch nicht einmal vollständig.

41
00:02:23,107 --> 00:02:24,802
Es gibt also im Wortsinn Tausende

42
00:02:24,802 --> 00:02:27,188
Programmiersprachen.

43
00:02:27,188 --> 00:02:29,588
Wenn Sie sich die anschauen, finden Sie Sprachen,

44
00:02:29,588 --> 00:02:32,839
die für und auf dem Amiga entworfen wurden.

45
00:02:32,839 --> 00:02:34,465
Das berühmte "Amiga E"

46
00:02:34,465 --> 00:02:37,288
und AMOS, entwickelt von einem Franzosen,

47
00:02:37,288 --> 00:02:42,988
dem hellen Kopf François Lionet.

48
00:02:42,988 --> 00:02:46,500
Dieses Basic kam mit einer DSL.

49
00:02:46,500 --> 00:02:50,240
Es war ein Tool, das ich vor

50
00:02:50,240 --> 00:02:52,899
mehr als 20 Jahren in Gebrauch hatte.

51
00:02:52,899 --> 00:02:56,445
Die DSL war für Animationen gedacht ...

52
00:02:56,445 --> 00:03:00,268
...und wurde in Maschinencode compiliert.

53
00:03:00,268 --> 00:03:04,439
Und der komplette Interpreter, der Compiler und die IDE

54
00:03:04,439 --> 00:03:10,624
für AMOS waren komplett in Assembler geschrieben.

55
00:03:10,624 --> 00:03:15,262
Dieser Mensch hat mich ganz schön inspiriert.

56
00:03:15,262 --> 00:03:19,448
Trotz so vieler Programmiersprachen

57
00:03:19,448 --> 00:03:22,985
und -werkzeuge suchen wir immer noch 

58
00:03:22,985 --> 00:03:25,197
nach einer neueren, besseren Lösung.

59
00:03:25,197 --> 00:03:28,035
Die Probleme, denen wir uns bei Software

60
00:03:28,035 --> 00:03:31,225
täglich gegenübersehen, sind heute ganz gut bekannt,

61
00:03:31,225 --> 00:03:34,345
aber trotzdem laufen wir weiter in sie hinein.

62
00:03:34,345 --> 00:03:37,582
Etwa die explodierende Komplexität...Bloatware...

63
00:03:37,582 --> 00:03:40,334
Nein, ich meine natürlich nicht Java. (Gelächter)

64
00:03:40,334 --> 00:03:42,225
Kein Gedanke an Java. :-P

65
00:03:42,225 --> 00:03:44,769
Langsam...Black Boxes, wie z.B. Software ohne 

66
00:03:44,769 --> 00:03:46,554
Zugang zum Quellcode.

67
00:03:46,554 --> 00:03:49,598
Was oft ein großes Problem darstellt, wenn Sie versuchen,

68
00:03:49,598 --> 00:03:53,461
Bugs zu beheben, an die Sie nicht herankommen.

69
00:03:53,461 --> 00:03:57,872
Anstatt uns den Kopf an diesen Wänden einzurennen,

70
00:03:57,872 --> 00:04:00,348
sollten wir Spaß am Programmieren haben,

71
00:04:00,348 --> 00:04:02,665
weil es beim Programmieren ums Vergnügen geht.

72
00:04:02,665 --> 00:04:05,265
Und das ist die Einstellung, die wir haben sollten, wenn

73
00:04:05,265 --> 00:04:07,852
wir an unseren Rechnern sitzen und mit ihnen arbeiten.

74
00:04:07,852 --> 00:04:11,400
Fast so wie in den Zeiten, in denen Programmieren

75
00:04:11,400 --> 00:04:13,440
was *only* fun.
*nur* Vergnügen war.

76
00:04:13,440 --> 00:04:16,441
Seit damals, seit den 80ern

77
00:04:16,441 --> 00:04:19,490
gab es eine Menge Revolutionen.

78
00:04:19,490 --> 00:04:21,716
Und heute erleben wir -- glaube ich -- zwei

79
00:04:21,716 --> 00:04:25,710
sehr bedeutsame Entwicklungen bei Computern:

80
00:04:25,710 --> 00:04:28,281
Die erste ist die Leistungssteigerung 

81
00:04:28,281 --> 00:04:31,224
von Computern durch mehr Kerne

82
00:04:31,224 --> 00:04:34,934
anstatt höherem CPU-Takt.

83
00:04:34,934 --> 00:04:39,320
Das hat weitreichende Folgen für Programmierwerkzeuge.

84
00:04:39,320 --> 00:04:44,062
Die andere große Revolution ist, daß wir jetzt alle

85
00:04:44,062 --> 00:04:46,772
auf Mobilgeräte umsteigen.

86
00:04:46,772 --> 00:04:49,987
Der Markt entwickelt sich sehr schnell.

87
00:04:49,987 --> 00:04:52,947
Somit müssen sich die Programmiertools ebenfalls anpassen.

88
00:04:52,947 --> 00:04:56,540
Trotz dieser Änderungen

89
00:04:56,540 --> 00:04:59,593
nutzen wir ja wirklich immer noch sehr alte Tools.
 
90
00:04:59,593 --> 00:05:03,677
Ich habe mir also mal die fünf beliebtesten

91
00:05:03,677 --> 00:05:07,004
Programmiersprachen der Tiobe-Rangliste angeschaut ...

92
00:05:07,004 --> 00:05:09,111
... dem berühmten Ranking.

93
00:05:09,111 --> 00:05:12,114
Yeah, C ist immer noch die Nummer 1

94
00:05:12,114 --> 00:05:14,672
und hängt inzwischen seit fast 40 Jahren hier ab.

95
00:05:14,672 --> 00:05:18,748
In der Informtik ist das eine ziemlich lange Zeit!

96
00:05:18,748 --> 00:05:22,984
Und C ist absolut nicht für die Erfordernisse

97
00:05:22,984 --> 00:05:25,417
modernen Computereinsatzes ausgelegt.

98
00:05:25,417 --> 00:05:27,973
Und wenn Sie sich die anderen anschauen,

99
00:05:27,973 --> 00:05:30,784
bei denen ist das mehr oder weniger das gleiche.

100
00:05:30,784 --> 00:05:33,205
Zum Glück gibt es ein paar Menschen ...

101
00:05:33,205 --> 00:05:36,211
...ein paar wenige Menschen, die sich dessen bewußt 

102
00:05:36,211 --> 00:05:41,981
und dazu in der Lage waren, Antworten auf diese Fragen zu geben.

103
00:05:41,981 --> 00:05:45,129
Leute wie Carl (zeigt auf Carl Sassenrath) 

104
00:05:45,129 --> 00:05:47,309
der Rebol erfunden hat ... ein fantastisches Tool.

105
00:05:47,309 --> 00:05:50,383
Wahrscheinlich eine der größten Erfindungen 

106
00:05:50,383 --> 00:05:55,080
im Bereich Programmieren in den letzten 20 Jahren.

107
00:05:55,080 --> 00:05:57,875
Also Rebol war eine gute Lösung, oder eine sehr

108
00:05:57,875 --> 00:06:00,598
gute Lösung für eine Menge Herausforderungen.

109
00:06:00,598 --> 00:06:01,978
*Aber nicht für alle.*

110
00:06:01,978 --> 00:06:05,352
Etwas, das ich Carl gerne zeigen würde ...

111
00:06:05,352 --> 00:06:08,556
... vielleicht kennt er es noch nicht ?

112
00:06:08,556 --> 00:06:12,917
Die Wunder, die Rebol vollbracht hat, bis vor kurzem

113
00:06:12,917 --> 00:06:17,277
haben davon nur die Rebol-Anwender geschwärmt

114
00:06:17,277 --> 00:06:20,004
und versucht, anderen zu erklären, was für ein

115
00:06:20,004 --> 00:06:23,947
produktives und ausdrucksstarkes Tool Rebol ist.

116
00:06:23,947 --> 00:06:28,282
Aber kürzlich hat man versucht, die Ausdrucksstärke

117
00:06:28,282 --> 00:06:32,133
von Programmiersprachen wissenschaftlich zu prüfen.

118
00:06:32,133 --> 00:06:37,597
Hat man also geprüft. Und Rebol... *Überraschung*! Ist Nummer 3.

119
00:06:37,597 --> 00:06:41,516
Dazu kommt: Nummer 1 und 2 sind DSL.

120
00:06:41,516 --> 00:06:44,526
Also raten Sie, wer auf Platz 1 steht? (Gelächter)

121
00:06:44,526 --> 00:06:49,040
Das bestätigt somit etwas, das wir alle von

122
00:06:49,040 --> 00:06:51,141
Anfang an gewußt haben.

123
00:06:51,141 --> 00:06:53,307
Rebol ist ein sehr produktives Tool

124
00:06:53,307 --> 00:06:55,935
und das ist jetzt bewiesen. (Gelächter)

125
00:06:55,935 --> 00:07:00,715
Aber Red versucht, über das hinauszugehen, was Rebol bietet.

126
00:07:00,715 --> 00:07:03,002
Hauptsächlich hinsichtlich seiner Implementierung,

127
00:07:03,002 --> 00:07:06,519
nicht hinsichtlich der Sprachsemantik oder -syntax.

128
00:07:06,519 --> 00:07:10,458
Sondern eher hinsichtlcih der Toolchain, der Implementierung,

129
00:07:10,458 --> 00:07:13,065
und der Weiterverbreitung.

130
00:07:13,065 --> 00:07:16,160
Also, was ist Red denn nun eigentlich?

131
00:07:16,160 --> 00:07:17,653
Red ist was ich eine

132
00:07:17,653 --> 00:07:19,212
*Full-Stack Programming Language* nenne.

133
00:07:19,212 --> 00:07:22,317
Vielleicht haben Sie von Full-Stack-Entwicklern gehört ?

134
00:07:22,317 --> 00:07:25,796
Also das hier ist eine Full-Stack-Programmiersprache.

135
00:07:25,796 --> 00:07:28,995
Und seine wesentliche Eigenschaft ist vermutlich,

136
00:07:28,995 --> 00:07:31,188
daß es eine echte 

137
00:07:31,188 --> 00:07:33,287
Allzweck-Programmierlösung darstellt.

138
00:07:33,287 --> 00:07:35,182
Es gibt viele Sprachen,

139
00:07:35,182 --> 00:07:39,288
die sich als "Allzweck-" preisen...

140
00:07:39,288 --> 00:07:43,358
...aber sie sind nicht so breit aufgestellt wie es Red sein kann.

141
00:07:43,358 --> 00:07:47,121
Die andere großartige Eigenschaft von Red

142
00:07:47,121 --> 00:07:49,413
besteht darin, daß es eine eigenständige Toolchain bildet,

143
00:07:49,413 --> 00:07:52,050
so daß wir nicht von der Standard-C-Toolchain

144
00:07:52,050 --> 00:07:56,488
abhöngen sondern unsere eigene haben.

145
00:07:56,488 --> 00:07:59,648
Ein anderer wichtiger Aspekt von Red,

146
00:07:59,648 --> 00:08:01,421
hier geht es um *Freiheit*.

147
00:08:01,421 --> 00:08:03,695
Von Anfang an war meine Motivation für Red

148
00:08:03,695 --> 00:08:07,334
jede Art von Einschränkung abzuschütteln, 

149
00:08:07,334 --> 00:08:08,995
bzw. jede Art Eingrenzung.

150
00:08:08,995 --> 00:08:14,230
Ich möchte, daß Anwender von Red das genauso empfinden.

151
00:08:14,230 --> 00:08:18,165
Deswegen ist Red einfach in der Anwendung, *dank Rebol*, ...

152
00:08:18,165 --> 00:08:23,770
aber Red hat keine willkürlichen Beschränkungen.

153
00:08:23,770 --> 00:08:26,374
Wir haben versucht, jede denkbare Anforderung

154
00:08:26,374 --> 00:08:28,138
zu berücksichtigen und jede mögliche Perspektive,

155
00:08:28,138 --> 00:08:33,154
so daß es auf jede benötigte Plattform installiert oder portiert werden kann.

156
00:08:33,154 --> 00:08:35,799
Noch was, etwas sehr wichtigees beim Programmieren:

157
00:08:35,799 --> 00:08:39,061
Sie müssen das Gefühl haben, Ihr Werkzeug unter Kontrolle zu haben.

158
00:08:39,061 --> 00:08:42,836
Oft nutzen Sie Tools, die sehr mächtig sein können,

159
00:08:42,836 --> 00:08:44,878
aber Sie haben es nicht unter Kontrolle, weil

160
00:08:44,878 --> 00:08:47,250
Sie nicht verstehen, was unter der Haube abläuft.

161
00:08:47,250 --> 00:08:48,730
Oft genug, weil es eine Black Box ist.

162
00:08:48,730 --> 00:08:52,495
Oder weil es auf einem großen Stapel von

163
00:08:52,495 --> 00:08:56,225
Softwareschichten aufsetzt, so daß Sie einfach

164
00:08:56,225 --> 00:08:57,921
nicht verstehen können, was innendrin vorgeht.

165
00:08:57,921 --> 00:09:02,394
Und eine letzte wichtige Sache :-)

166
00:09:02,394 --> 00:09:04,521
Das ist der *Spaß*. Yeah, wir wollen wieder Spaß haben.

167
00:09:04,521 --> 00:09:08,808
Manch einer, der Red oder Red/System testen wollte,

168
00:09:08,808 --> 00:09:11,465
kam nach dem erfolgreichen Compilieren und

169
00:09:11,465 --> 00:09:14,262
Ausführen seines ersten Programms

170
00:09:14,262 --> 00:09:16,175
zu mir und sagte:

171
00:09:16,175 --> 00:09:17,367
"Das ist großartig, weil es Spaß macht."

172
00:09:17,367 --> 00:09:21,281
"Ich hab's einfach ausprobiert, und es hat funktioniert, großartig."
 
173
00:09:21,281 --> 00:09:25,132
Leute kriegen dieses Gefühl -- wovon ich gesprochen

174
00:09:25,132 --> 00:09:27,620
habe -- dieses 80er-Jahre-Feeling.

175
00:09:27,620 --> 00:09:29,347
Wo man sich so richtig als Meister

176
00:09:29,347 --> 00:09:31,121
seiner Programmierumgebung fühlt.

177
00:09:31,121 --> 00:09:34,387
Also versuche ich jetzt zu erklären, was ich mit

178
00:09:34,387 --> 00:09:36,782
"Full-Stack Programming Language" meine und

179
00:09:36,782 --> 00:09:40,455
"echter Allzweck-Programmiersprache".

180
00:09:40,455 --> 00:09:42,096
Ich hab mal diese Grafik vorbereitet:

181
00:09:42,096 --> 00:09:43,414
"Einsatzbereiche / Anwendungsfelder"

182
00:09:43,414 --> 00:09:46,570
für ein paar der wichtigsten Programmiersprachen.

183
00:09:46,570 --> 00:09:49,393
Bei Assembler sind es beispielsweise Treiber

184
00:09:49,393 --> 00:09:52,019
und sehr systemnaher Code.

185
00:09:52,019 --> 00:09:54,895
Sie sehen, daß Java ziemlich beschränkt ist

186
00:09:54,895 --> 00:09:58,084
hinsichtlich seiner Eignung für unterschiedliche Abstraktionsebenen.

187
00:09:58,084 --> 00:10:00,607
Ruby ist ziemlich allgemein;

188
00:10:00,607 --> 00:10:02,989
vielleicht geht es gar nicht bis auf Betriebssystemebene?

189
00:10:02,989 --> 00:10:05,598
Ich weiß nicht, ob das Ruby-Interface für die Nutzung

190
00:10:05,598 --> 00:10:09,888
der Betriebssystem-APIs wirklich gut ist oder nicht.

191
00:10:09,888 --> 00:10:13,324
Rebol hat einen recht umfassenden Ansatz.

192
00:10:13,324 --> 00:10:16,880
Rascal ist eine sehr spezifische Programmiersprache.

193
00:10:16,880 --> 00:10:19,540
Das ist eine Art DSL,

194
00:10:19,540 --> 00:10:23,246
dafür gedacht, andere DSLs zu schreiben.

195
00:10:23,246 --> 00:10:26,522
Somit steht es auf der Meta-DSL-Ebene.

196
00:10:26,522 --> 00:10:30,356
So where is Red on that scale?
Wo steht Red in diesem Feld ?

197
00:10:30,356 --> 00:10:33,954
Nun, Red zielt auf alle Anforderungen ab,

198
00:10:33,954 --> 00:10:37,272
von ganz unten bis ganz oben.

199
00:10:37,272 --> 00:10:40,596
Weil ich nicht auf ein anderes Tool angewiesen sein wollte.

200
00:10:40,596 --> 00:10:43,056
Ich möchte, daß die Programmiersprache Red

201
00:10:43,056 --> 00:10:45,913
alle Anforderungen bedient, ohne von

202
00:10:45,913 --> 00:10:48,272
etwas anderem abzuhängen.

203
00:10:48,272 --> 00:10:51,236
Jetzt sagen Sie mir sicher, das es so ziemlich unmöglich sei 

204
00:10:51,236 --> 00:10:53,307
eine Sprache zu entwerfen,

205
00:10:53,307 --> 00:10:56,058
die so ein weites Feld abdeckt.

206
00:10:56,058 --> 00:10:58,201
Und Sie haben Recht.

207
00:10:58,201 --> 00:11:00,771
Aber Red hat einen Trumpf.

208
00:11:00,771 --> 00:11:04,418
Red/System deckt die niedrigen Ebene ab,

209
00:11:04,418 --> 00:11:06,604
und Red die höheren Schichten.

210
00:11:06,604 --> 00:11:10,037
Die sind miteinander integriert

211
00:11:10,037 --> 00:11:11,702
und arbeiten zusammen.

212
00:11:11,702 --> 00:11:15,114
Red/System ist quasi eine Variante von Red.

213
00:11:15,114 --> 00:11:17,191
Sie können es getrennt nutzen

214
00:11:17,191 --> 00:11:20,112
oder vollkommen in Red eingebettet. 

215
00:11:20,112 --> 00:11:25,446
Werfen wir eine Blick auf die unterstützten Plattformen.

216
00:11:25,446 --> 00:11:26,597
Zunächst auf dem Desktop

217
00:11:26,597 --> 00:11:30,755
unterstützen wir die 3 Klassiker.

218
00:11:30,755 --> 00:11:34,424
Wir unterstützen auch einige weitere

219
00:11:34,424 --> 00:11:36,693
Betriebssysteme wie Syllable.

220
00:11:36,693 --> 00:11:38,829
Wir würden gerne FreeBSD supporten,

221
00:11:38,829 --> 00:11:41,350
but we had some low-level issues
aber wir haben einige Probleme im systemnahen Bereich

222
00:11:41,350 --> 00:11:45,053
and no FreeBSD experts among us
und keine FreeBSD-Experten im Boot,

223
00:11:45,053 --> 00:11:48,456
sie zu lösen, im Moment tritt das also etwas auf der Stelle.

224
00:11:48,456 --> 00:11:52,454
Aber wahrscheinlich könnten wir Red schnell

225
00:11:52,454 --> 00:11:54,855
auf FreeBSD portiert kriegen.

226
00:11:54,855 --> 00:11:57,687
Dann wollen wir auch 

227
00:11:57,687 --> 00:12:00,774
den Embedded-Markt bedienen, als erstes Android,

228
00:12:00,774 --> 00:12:02,771
das wir bereits unterstützen.

229
00:12:02,771 --> 00:12:04,787
Das nächste wird iOS sein.

230
00:12:04,787 --> 00:12:07,905
Und wir laufen schon auf dem Raspberry Pi,

231
00:12:07,905 --> 00:12:10,367
der sich zunehmender Beliebtheit erfreut.

232
00:12:10,367 --> 00:12:14,720
Ich schätze, Bo wird einiges vorführen,

233
00:12:14,720 --> 00:12:17,929
vielleicht morgen.

234
00:12:17,929 --> 00:12:22,868
Wir haben auch eine experimentelle Portierung auf Arduino.

235
00:12:22,868 --> 00:12:27,030
Mit AVR 8-bit haben wir begonnen.

236
00:12:27,030 --> 00:12:30,044
Aber im Moment ist das ein Experiment,

237
00:12:30,044 --> 00:12:32,895
denn andere Boards kommen bald heraus

238
00:12:32,895 --> 00:12:36,014
wie 32-Bit-Boards oder der Raspberry Pi.

239
00:12:36,014 --> 00:12:41,790
Somit ist 8-Bit-Support vielleicht gerade nicht angesagt.

240
00:12:41,790 --> 00:12:45,320
Wir möchten auch VMs unterstützen.

241
00:12:45,320 --> 00:12:49,753
Wir wollen uns mit .NET verbinden können,

242
00:12:49,753 --> 00:12:53,139
mit der JVM und JavaScript.

243
00:12:53,139 --> 00:12:55,602
Es gibt im wesentlichen zwei Möglichkeiten,

244
00:12:55,602 --> 00:12:56,467
das zu erreichen.

245
00:12:56,467 --> 00:13:00,940
Mit einer Brückentechnologie, Red so belassen,

246
00:13:00,940 --> 00:13:06,438
wie es jetzt ist, und uns mit diesen VMs koppeln

247
00:13:06,438 --> 00:13:08,746
Oder wir entwickeln ein neues Backend

248
00:13:08,746 --> 00:13:11,146
für Red und Red/System,

249
00:13:11,146 --> 00:13:13,710
um direkt in den Bytecode

250
00:13:13,710 --> 00:13:15,817
dieser VMs zu compilieren.

251
00:13:15,817 --> 00:13:17,905
Diese beiden Optionen haben wir also.

252
00:13:17,905 --> 00:13:21,645
Wir haben damit begonnen, ein paar Brücken zur JVM zu schlagen.

253
00:13:21,645 --> 00:13:26,405
Wir versuchen, jedesmal die

254
00:13:26,405 --> 00:13:30,067
richtige Entscheidung zu treffen -- die beste für die zu lösende Aufgabe.

255
00:13:30,067 --> 00:13:33,188
Im Moment koppeln wir uns mit der JVM.

256
00:13:33,188 --> 00:13:37,997
Aber wahrscheinlich werden wir direkt nach JavaScript compilieren.

257
00:13:37,997 --> 00:13:41,551
Wir haben jetzt asm.js, also eine

258
00:13:41,551 --> 00:13:45,325
richtig interesante Plattform zu unterstützen.

259
00:13:45,325 --> 00:13:47,584
Ich erwarte, daß Red und Red/System

260
00:13:47,584 --> 00:13:50,755
ziemlich flott darauf laufen werden.

261
00:13:50,755 --> 00:13:53,753
Ein weiterer Blick auf die Arbeitsweise, mehr für den Praktiker:

262
00:13:53,753 --> 00:13:57,242
Sie haben also Red: 1 Binary.

263
00:13:57,242 --> 00:14:01,118
Sie laden es herunter und kriegen all diese Features.

264
00:14:01,118 --> 00:14:04,756
Sie können ein Red-Skript direkt aus dem Speicher ausführen. 

265
00:14:04,756 --> 00:14:08,124
Sie können ein Executable bauen.

266
00:14:08,124 --> 00:14:12,805
Sie können es Cross-compilieren...

267
00:14:12,805 --> 00:14:15,324
wir kommen auf dieses Feature noch zurück.

268
00:14:15,324 --> 00:14:19,071
Sie können auch direkt Red/System-Skripte compilieren,

269
00:14:19,071 --> 00:14:22,291
wenn Sie die Red-Schicht nicht nutzen

270
00:14:22,291 --> 00:14:26,063
sondern eine maschinennahe Anwendung erstellen wollen.

271
00:14:26,063 --> 00:14:29,955
Und Sie können jetzzt auch Shared Libraries compilieren,

272
00:14:29,955 --> 00:14:32,948
was die Tür zur weiteren Verbreitung von Red öffnet,

273
00:14:32,948 --> 00:14:36,582
indem wir es anflanschen, wo immer wir können.

274
00:14:36,582 --> 00:14:39,954
Sie können Red auch in einem Kommandozeilenmodus starten,

275
00:14:39,954 --> 00:14:42,206
dann haben Sie eine Red-Shell.

276
00:14:42,206 --> 00:14:45,499
Nun also zum Cross-compilieren...Red ist jetzt in der Lage,

277
00:14:45,499 --> 00:14:49,442
für andere Systeme zu compilieren, von einem System zum anderen.

278
00:14:49,442 --> 00:14:52,731
Genauer gesagt, kann es von jeder Plattform,

279
00:14:52,731 --> 00:14:56,113
auf der Rebol läuft, auf jede andere Plattform compilieren.

280
00:14:56,113 --> 00:15:00,808
Dafür brauchen Sie kein HOWTO,

281
00:15:00,808 --> 00:15:02,363
und Sie brauchen kein Tutorial.

282
00:15:02,363 --> 00:15:04,788
Sie müssen nicht im Netz danach suchen,

283
00:15:04,788 --> 00:15:07,182
wie Sie es bewerkstelligen können.

284
00:15:07,182 --> 00:15:10,293
Sie übergeben einfach ein "-t" und die Ziel-ID,

285
00:15:10,293 --> 00:15:11,777
das ist alles.

286
00:15:11,777 --> 00:15:16,750
Eine Ziel-ID ist nur ein Eintrag in einer Konfigurationsdatei,

287
00:15:16,750 --> 00:15:21,988
eine einfache Red-Variante, mit der wir nur

288
00:15:21,988 --> 00:15:26,132
ein paar Einstellungen für die Ziel-Plattform auflisten.

289
00:15:26,132 --> 00:15:31,110
Zur Zeit haben wir diese Liste von um die 8 Zielplattformen.

290
00:15:31,110 --> 00:15:33,602
Wir können also auf jeder für jede andere

291
00:15:33,602 --> 00:15:35,828
compilieren, so lange Rebol

292
00:15:35,828 --> 00:15:40,124
auf der Quellplattform läuft.

293
00:15:40,124 --> 00:15:41,557
Wie Sie sehen können, unterstützen wir also

294
00:15:41,557 --> 00:15:45,594
hauptsächlich Plattformen auf Basis von x86 und ARM.

295
00:15:45,594 --> 00:15:49,412
Steigen wir etwas tiefer in die Toolchain ein.

296
00:15:49,412 --> 00:15:51,796
Wir haben diverse Komponenten.

297
00:15:51,796 --> 00:15:54,506
Da wäre das klassische Paar: Compiler, Linker.

298
00:15:54,506 --> 00:16:01,832
Der Compiler kann im wesentlichen Code für 

299
00:16:01,832 --> 00:16:07,115
diese beiden Backends generieren, x86 und ARM.

300
00:16:07,115 --> 00:16:11,919
Wir haben aber vor, auch den "thumb mode" des ARMv7

301
00:16:11,919 --> 00:16:17,236
und 64-Bit-Plattformen zu unterstützen.

302
00:16:17,236 --> 00:16:22,287
Wir werden auch die VM-Backends ergänzen.

303
00:16:22,287 --> 00:16:26,207
JavaScript, JVM Bytecode ... Dex für Dalvik

304
00:16:26,207 --> 00:16:30,153
als Alternative für JVM auf Android.

305
00:16:30,153 --> 00:16:34,462
Und MSIL bezeichnet 

306
00:16:34,462 --> 00:16:37,043
den Bytecode von .NET

307
00:16:37,043 --> 00:16:39,737
Der Linker unterstützt damit die wichtigsten Dateiformate.

308
00:16:39,737 --> 00:16:43,532
Wir werden ihn um die Unterstützung statischer Bibliotheken erweitern.

309
00:16:43,532 --> 00:16:46,418
Damit können Sie ein Red-Programm als statische

310
00:16:46,418 --> 00:16:51,578
Bibliothek compilieren und später mit einer 

311
00:16:51,578 --> 00:16:55,233
anderen externen Toolchain linken, z.B. aus der C-Welt.

312
00:16:55,233 --> 00:16:59,655
Das ist ein weiterer Weg, um Red weiterzuverbreiten

313
00:16:59,655 --> 00:17:02,448
und es jedem zu ermöglichen, Red in Toolchain-

314
00:17:02,448 --> 00:17:04,962
Sprachen und -Applikationen von Dritten einzusetzen.

315
00:17:04,962 --> 00:17:09,242
Wir werden uns auch der Kernelebene zuwenden

316
00:17:09,242 --> 00:17:14,305
und Support für die Erstellung von Kernel-

317
00:17:14,305 --> 00:17:19,234
Treibern bieten, bis hin zu kompletten Betriebssystemen

318
00:17:19,234 --> 00:17:21,787
direkt aus Red heraus.

319
00:17:21,787 --> 00:17:24,199
Aktuell haben wir einen experimentellen

320
00:17:24,199 --> 00:17:27,504
Support für Windows-Kernel-Treiber am laufen.

321
00:17:27,504 --> 00:17:31,980
Falls Entwickler von Kerneltreibern anwesend sind,

322
00:17:31,980 --> 00:17:34,213
können Sie damit Ihren Spaß haben. :-P

323
00:17:34,213 --> 00:17:37,458
Zum Schluß: Etwas, das es meines Wissens nach

324
00:17:37,458 --> 00:17:40,247
in der klassischen C-Toolchain nicht gibt:

325
00:17:40,247 --> 00:17:42,530
Wir werden einen Packager haben, 

326
00:17:42,530 --> 00:17:46,044
der ist noch nicht implementiert, aber bald.

327
00:17:46,044 --> 00:17:51,589
Wir werden mit dem Android APK-Backend beginnen.

328
00:17:51,589 --> 00:17:54,697
Das Ziel bei dieser Ebene besteht darin,

329
00:17:54,697 --> 00:17:58,850
nur ein paar Dateien zu nehmen und sie in der Form

330
00:17:58,850 --> 00:18:03,445
und in dem Format zu packen, wie von der Zielplattform erwartet.

331
00:18:03,445 --> 00:18:06,426
Also wir werden Android supporten, wir werden iOS supporten.

332
00:18:06,426 --> 00:18:08,997
So ein Packager ließe sich aber auch dafür einsetzen,

333
00:18:08,997 --> 00:18:13,409
Web-Anwendungen zusammenzustellen.

334
00:18:13,409 --> 00:18:17,371
Etwa wie das Java mit dem .WAR-Format macht,

335
00:18:17,371 --> 00:18:20,196
das sehr interessante Möglichkeiten eröffnet,

336
00:18:20,196 --> 00:18:23,489
wie vereinfachtes Rollout von Web-Anwendungen

337
00:18:23,489 --> 00:18:25,276
und der Möglichkeit, sie zu versionieren,

338
00:18:25,276 --> 00:18:27,050
oder ein Rollout zurückzufahren,

339
00:18:27,050 --> 00:18:29,342
alles großartige Dinge, die man gerne haben möchte. 

340
00:18:29,342 --> 00:18:31,027
Ein anderer Punkt bei der Toolchain

341
00:18:31,027 --> 00:18:32,544
ist, daß die Tooolchain zur Zeit

342
00:18:32,544 --> 00:18:36,774
als Rebol 2 - Bootstrap realisiert ist.

343
00:18:36,774 --> 00:18:40,686
Wir haben das in der Form bereits seit 2 Jahren laufen.

344
00:18:40,686 --> 00:18:46,907
Die finale Red-Version wird aber einen JIT-Compiler haben.

345
00:18:46,907 --> 00:18:50,717
Um einen JIT-Compiler zu haben, müssen wir autark werden.

346
00:18:50,717 --> 00:18:54,347
Wir müssen also Red in Red schreiben.

347
00:18:54,347 --> 00:18:58,587
Das ist der einzige Weg, einen richtigen JIT-Compiler zu bekommen.

348
00:18:58,587 --> 00:19:03,543
Höchstwahrscheinlich werden wir nächstes Jahr also daran arbeiten.

349
00:19:03,543 --> 00:19:07,550
Hier sind ein paar Folien zu Sprache Red selbst.

350
00:19:07,550 --> 00:19:10,796
Ich werde aber nicht zu sehr ins Detail gehen,

351
00:19:10,796 --> 00:19:13,394
weil das zuviel Zeit kosten würde.

352
00:19:13,394 --> 00:19:18,018
Als erstes muß man über Red wissen,

353
00:19:18,018 --> 00:19:21,098
daß sie sehr stark Rebol ähnelt.

354
00:19:21,098 --> 00:19:26,585
Es gibt einige der wesentlichen Eigenschaften Rebols

355
00:19:26,585 --> 00:19:31,588
wie "definitional scoping" und dynamische Bindung.

356
00:19:31,588 --> 00:19:37,178
Sie haben auch die Möglichkeit, in Red unter

357
00:19:37,178 --> 00:19:40,106
jedem beliebigen Paradigma zu entwickeln.

358
00:19:40,106 --> 00:19:43,031
*"Paradigmen-neutral"* ist ein Begriff von

359
00:19:43,031 --> 00:19:46,673
Gabriele (Santilli), und er gefällt mir sehr, weil

360
00:19:46,673 --> 00:19:50,013
er sehr gut die Freiheit ausdrückt, nicht an

361
00:19:50,013 --> 00:19:53,878
ein bestimmtes Paradigma gebunden zu sein.

362
00:19:55,318 --> 00:19:59,298
Ein Unterschied zwischen Red und Rebol

363
00:19:59,298 --> 00:20:05,376
besteht darin, daß man in Red lokale Variablen optional 

364
00:20:05,376 --> 00:20:09,756
typisieren kann, genauso wie Rückgabewerte 

365
00:20:09,756 --> 00:20:12,147
von Funktionen.

366
00:20:12,147 --> 00:20:17,048
In Rebol ist das kaum von Bedeutung, weil 

367
00:20:17,048 --> 00:20:25,102
es für einen Interpreter keinen Wert hat.

368
00:20:25,102 --> 00:20:27,874
Für einen Compiler ist das hingegen äußerst vorteilhaft.

369
00:20:27,874 --> 00:20:33,604
Durch Typisierungen in der Funktion 

370
00:20:33,604 --> 00:20:37,791
kann der Compiler viel spezialisierteren,

371
00:20:37,791 --> 00:20:43,616
schnelleren und effizienteren Code generieren

372
00:20:43,616 --> 00:20:46,818
als ohne die Typisierung.

373
00:20:47,728 --> 00:20:53,186
Red ist "optional typisiert". Sie können also typisieren oder nicht.

374
00:20:53,186 --> 00:20:56,989
Das hängt ganz von Ihren Anforderungen ab, Ihrer Programmierweise.

375
00:20:56,989 --> 00:20:59,333
Sie können wie in Rebol vorgehen,

376
00:20:59,333 --> 00:21:01,619
womit Sie sehr flexibel sind.

377
00:21:01,619 --> 00:21:06,168
Allerdings erhalten Sie schlechtere Performance.

378
00:21:06,168 --> 00:21:08,549
Oder Sie folgen dem statischen Modell,

379
00:21:08,549 --> 00:21:10,581
typisieren alles

380
00:21:10,581 --> 00:21:13,702
und der Compiler kann mehr statische Typ-Püfungen vornehmen,

381
00:21:13,702 --> 00:21:16,969
so daß Sie einige Warnungen bzw. Fehler beim

382
00:21:16,969 --> 00:21:21,230
Compilieren statt während der Ausführung erhalten.

383
00:21:21,230 --> 00:21:28,353
Wenn Sie keine Typen vergeben, kann der Compiler zudem

384
00:21:28,353 --> 00:21:31,687
in manchen Fällen 

385
00:21:31,687 --> 00:21:34,141
Typen ableiten.

386
00:21:34,141 --> 00:21:36,654
Er kann also die Typen an Ihrer Statt ermitteln.

387
00:21:36,654 --> 00:21:41,093
Da Red, wie Rebol, eine sehr dynamische Sprache ist,

388
00:21:41,093 --> 00:21:48,734
bleiben die Fähigkeiten der Inferenzmaschine

389
00:21:48,734 --> 00:21:53,581
zur Ermittlung der Typen jedoch recht eingeschränkt.

390
00:21:53,581 --> 00:21:56,756
Das wird also eine kleine Hilfe sein, aber nichts Großes.

391
00:21:56,756 --> 00:22:01,167
Wir unterstützen natürlich Unicode.

392
00:22:01,167 --> 00:22:04,623
Red-Quellcode ist UTF-8. 

393
00:22:04,623 --> 00:22:09,567
Wir werden einige externe Codecs für andere Zeichensätze bereitstellen.

394
00:22:09,567 --> 00:22:16,728
Intern speichert und verarbeitet Red 

395
00:22:16,728 --> 00:22:20,036
Unicode in etwa so wie Python

396
00:22:20,036 --> 00:22:22,719
in den jüngsten Versionen.

397
00:22:22,719 --> 00:22:29,671
Das interne Format hat eine feste Länge. 

398
00:22:29,671 --> 00:22:35,382
Es kann 1 bis 4 Bytes belegen 

399
00:22:35,382 --> 00:22:37,921
pro Codepoint.

400
00:22:37,921 --> 00:22:40,144
Das System paßt zudem automatisch die

401
00:22:40,144 --> 00:22:43,224
Länge abhängig von der Eingabe und Ihren

402
00:22:43,224 --> 00:22:48,908
Updates der Zeichenkette an.

403
00:22:48,908 --> 00:22:54,977
Ein anderer sehr wichtiger Teil in Red

404
00:22:54,977 --> 00:22:57,640
ist die Unterstützung von Parallelität.

405
00:22:57,640 --> 00:23:00,108
Im Moment ist das aber nicht implementiert,

406
00:23:00,108 --> 00:23:04,207
daher werde ich dazu nicht auf Details eingehen.

407
00:23:04,207 --> 00:23:09,102
Wir wollen hauptsächlich zwei Sachen unterstützen:

408
00:23:09,102 --> 00:23:11,330
Wir wollen Nebenläufigkeit auf Task-Ebene unterstützen,

409
00:23:11,330 --> 00:23:15,331
so daß Sie mehrere Threads parallel

410
00:23:15,331 --> 00:23:18,367
auf mehreren Kernen ausführen können. 

411
00:23:18,367 --> 00:23:21,891
Wir verwenden voraussichtlich die Aktoren-Metapher.

412
00:23:21,891 --> 00:23:26,693
Wobei es andere Abstraktionen gibt,

413
00:23:26,693 --> 00:23:31,042
die seit Beginn der Projekts Red an

414
00:23:31,042 --> 00:23:34,926
Zugkraft gewinnen. Wie etwa Go-Routinen,

415
00:23:34,926 --> 00:23:38,981
die ein großes Plus

416
00:23:38,981 --> 00:23:40,645
für die Sprache Go werden.

417
00:23:40,645 --> 00:23:43,082
Das ist also etwas, das wir auch für

418
00:23:43,082 --> 00:23:45,725
Red in Betracht ziehen sollten, vielleicht...

419
00:23:45,725 --> 00:23:48,651
als Ergänzung oder Ersatz für Aktoren

420
00:23:48,651 --> 00:23:50,974
und andere Abstraktionen.

421
00:23:50,974 --> 00:23:54,765
Wenn wir also an den Punkt gelangen, die

422
00:23:54,765 --> 00:23:57,311
Parallelität zu implementieren, müssen wir alle

423
00:23:57,311 --> 00:23:59,900
Entwurfsentscheidungen überarbeiten und schauen,

424
00:23:59,900 --> 00:24:03,665
ob wir sie durch Übernahme anderer erfolgreicher

425
00:24:03,665 --> 00:24:06,840
Strategien aktualisieren können.

426
00:24:06,840 --> 00:24:09,047
Wir wollen auch einen gewissen Grad an

427
00:24:09,047 --> 00:24:13,712
Datenparallelität haben, entweder per SIMD

428
00:24:13,712 --> 00:24:16,582
oder durch Mehrkernverarbeitung.

429
00:24:16,582 --> 00:24:19,851
Im Prinzip wird das also die Fähigkeit nutzen,

430
00:24:19,851 --> 00:24:25,917
die Verarbeitung von Red-Sequenzen zu parallelisieren.

431
00:24:25,917 --> 00:24:30,758
Wir würden auch gerne einen Punkt angehen,

432
00:24:30,758 --> 00:24:33,476
den Rebol gegenwärtig gar nicht behandelt,

433
00:24:33,476 --> 00:24:36,231
nämlich: wie erstellt man eine Sprachvariante ?

434
00:24:36,231 --> 00:24:38,956
Oder wie generiert man eine DSL?

435
00:24:38,956 --> 00:24:41,438
Rebol ist großartig für diesen Zweck --

436
00:24:41,438 --> 00:24:44,368
wahrscheinlich ist es eins der besten Werkzeuge dafür,

437
00:24:44,368 --> 00:24:45,658
denn es verfügt über PARSE und 

438
00:24:45,658 --> 00:24:48,084
einige interessante Eigenschaften,

439
00:24:48,084 --> 00:24:50,101
wegen derer es eine gute Wahl darstellt.

440
00:24:50,101 --> 00:24:54,911
Jedenfalls ist es nicht einfach, eine DSL 

441
00:24:54,911 --> 00:24:57,186
oder eine Sprachvariante zu erstellen.

442
00:24:57,186 --> 00:24:59,774
Zunächst müssen Sie sie nämlich enwerfen.

443
00:24:59,774 --> 00:25:01,425
Und schon das bedeutet eine Menge Arbeit.

444
00:25:01,425 --> 00:25:03,427
Und anschließend müssen Sie sie implementieren. 

445
00:25:03,427 --> 00:25:07,113
Und eine DSL oder eine Sprachvariante zu implementieren

446
00:25:07,113 --> 00:25:11,151
heißt, einen Interpreter oder Compiler zu schreiben.

447
00:25:11,151 --> 00:25:17,524
Dabei sind Sie praktisch immer auf sich gestellt: es gibt nur Sie und den Code.

448
00:25:17,524 --> 00:25:20,462
Sie haben also kein wirkliches Framework,

449
00:25:20,462 --> 00:25:22,134
um so etwas zu realisieren.

450
00:25:22,134 --> 00:25:25,585
Und es ist möglich, die Eigenschaften

451
00:25:25,585 --> 00:25:27,439
von Rebol in Red oder vielleicht

452
00:25:27,439 --> 00:25:29,507
sogar in Rebol dafür auszunutzen,

453
00:25:29,507 --> 00:25:32,431
eine Art Meta-DSL zu entwickeln,

454
00:25:32,431 --> 00:25:38,218
die es ermöglicht, um vieles produktiver zu sein,

455
00:25:38,218 --> 00:25:40,920
und Ihnen ein Framework schafft für die

456
00:25:40,920 --> 00:25:44,260
Erschaffung neuer Sprachvarianten und neuer DSLs.

457
00:25:44,260 --> 00:25:47,156
Im Grunde wird das eine Art

458
00:25:47,156 --> 00:25:50,105
allgemeinere Version von PARSE sein.

459
00:25:50,105 --> 00:25:52,557
Stellen Sie sich das zum Beispiel so vor,

460
00:25:52,557 --> 00:25:59,457
als hätten Sie PARSE mit einer

461
00:25:59,457 --> 00:26:03,732
versteckten Ereignisschleife.

462
00:26:03,732 --> 00:26:07,914
In der Art von Visual Basic.

463
00:26:07,914 --> 00:26:11,544
Und Sie implmentieren nur Ereignisse,

464
00:26:11,544 --> 00:26:17,351
um Ihre DSL als Interpreter oder Compiler zu erzeugen.

465
00:26:17,351 --> 00:26:26,170
Was macht also der Red-Compiler?

466
00:26:26,170 --> 00:26:30,786
Der Red-Compiler übersetzt Red-Code

467
00:26:30,786 --> 00:26:34,944
nach Red/System, der maschinennäheren Ebene.

468
00:26:34,944 --> 00:26:40,093
Ich wollte Ihnen nur mal zeigen, wie das aussieht.

469
00:26:40,093 --> 00:26:45,535
Nehmen wir also einen sehr einfachen Red-Ausdruck, 

470
00:26:45,535 --> 00:26:48,493
der Red-Compiler parst ihn

471
00:26:48,493 --> 00:26:53,884
und nutzt einen Stack für die Parameterübergabe.

472
00:26:53,884 --> 00:26:58,480
Effektiv nutzt er zwei Stacks: einen für die Aufrufe

473
00:26:58,480 --> 00:27:01,819
und einen für die Parameter.

474
00:27:01,819 --> 00:27:05,361
Und anschließend erzeugt der Codegenerator auf

475
00:27:05,361 --> 00:27:08,363
dieser Basis Instruktionen in Red/System.

476
00:27:08,363 --> 00:27:10,782
Was Sie auf der rechten Seite sehen,

477
00:27:10,782 --> 00:27:14,350
ist also der Red/System-Code für diesen Ausdruck,

478
00:27:14,350 --> 00:27:18,061
mit Aufrufen des APIs der Red-Runtime.

479
00:27:22,651 --> 00:27:28,334
Ein weiterer herausragender Aspekt

480
00:27:28,334 --> 00:27:29,406
der Sprache Red und ihres Compilers

481
00:27:29,406 --> 00:27:34,169
ist die Verbindung verschiedener Konzepte,

482
00:27:34,169 --> 00:27:37,846
was glaube ich ziemlich einzigartig ist.

483
00:27:37,846 --> 00:27:41,156
Zunächst haben Sie also einen statischen Compiler.

484
00:27:41,156 --> 00:27:44,538
Dieser statische Compiler generiert Code,

485
00:27:44,538 --> 00:27:46,584
der einen Interpreter enthält, und demnächst

486
00:27:46,584 --> 00:27:51,606
einen JIT-Compiler, eingebettet in Ihr Executable.

487
00:27:51,606 --> 00:27:58,368
Diese drei Teile werden alle in einer sehr

488
00:27:58,368 --> 00:28:02,334
kollaborativen Art und Weise zusammenarbeiten können.

489
00:28:02,334 --> 00:28:05,191
Zum Beispiel kann der compilierte Code

490
00:28:05,191 --> 00:28:08,428
den internen Interpreter aufrufen,

491
00:28:08,428 --> 00:28:12,551
der selbst wiederum compilierten Code aufrufen kann.

492
00:28:12,551 --> 00:28:16,189
Analoges gilt für den JIT-Compiler.

493
00:28:16,189 --> 00:28:19,973
Das ist gerade ein bißchen abstrakt, aber zum

494
00:28:19,973 --> 00:28:21,707
Abschluß des Vortrags kann ich Ihnen eine Folie mit

495
00:28:21,707 --> 00:28:23,904
einem Fallbeispiel für diesen Ansatz zeigen.

496
00:28:23,904 --> 00:28:28,901
Solch ein Ansatz ist tatsächlich ein sehr mächtiges Werkzeug

497
00:28:28,901 --> 00:28:35,136
um sehr komplexe Semantiken anzugehen.

498
00:28:35,136 --> 00:28:39,575
Zum Beispiel, Code zur Symbolverarbeitung zu compilieren,

499
00:28:39,575 --> 00:28:42,229
was ziemlich schwierig zu bewerkstelligen ist.

500
00:28:42,229 --> 00:28:43,740
Aber wenn Sie verschiedene Ansätze kombinieren,

501
00:28:43,740 --> 00:28:49,758
können Sie eine sehr effiziente Lösung finden.

502
00:28:49,758 --> 00:28:54,407
Das ist jetzt nur ein ganz einfaches Beispiel,

503
00:28:54,407 --> 00:29:00,583
wie Red-Code aussieht.

504
00:29:00,583 --> 00:29:03,399
Sie sehen das gleiche Prinzip wie in Rebol,
 
505
00:29:03,399 --> 00:29:08,492
Sie haben also einen Marker, das ist [Red],

506
00:29:08,492 --> 00:29:13,355
gefolgt von einem Block in der Funktion eines Headers

507
00:29:13,355 --> 00:29:17,254
und anschließend kommt Ihr Code.

508
00:29:17,254 --> 00:29:19,921
Hello World ist einfach [print "Hello World"]

509
00:29:19,921 --> 00:29:22,312
wie in Rebol, und der Rest des Codes 

510
00:29:22,312 --> 00:29:26,336
ähnelt wahrscheinlich stark Rebol

511
00:29:26,336 --> 00:29:32,270
außer vielleicht das optionale [return: [type!]],

512
00:29:32,270 --> 00:29:36,908
aber das ist genau die Art optionaler

513
00:29:36,908 --> 00:29:40,409
Typisierung, über die ich zuvor gesprochen habe.

514
00:29:40,409 --> 00:29:43,389
Das wäre also ein Beispel dafür.

515
00:29:43,389 --> 00:29:48,196
Man muß das nicht zwingend angeben, aber wenn

516
00:29:48,196 --> 00:29:54,758
man es angibt, generiert der Compiler besseren, schnelleren Code.

517
00:29:54,758 --> 00:29:59,006
Jetzt zu einem etwas detaillierten Blick

518
00:29:59,006 --> 00:30:02,905
auf die Interna von Red und seiner verschiedenen Komponenten,

519
00:30:02,905 --> 00:30:05,640
damit Sie einen besseren Eindruck darüber gewinnen,

520
00:30:05,640 --> 00:30:09,472
in welcher Beziehung diese Elemente untereinander stehen.

521
00:30:09,472 --> 00:30:13,971
Beginnen wir mit dem Freund zur Rechten,

522
00:30:13,971 --> 00:30:17,047
wir haben ein Kommandozeilen-Skript des Front-Ends,

523
00:30:17,047 --> 00:30:19,852
das gegenwärtig in Rebol 2 geschrieben ist,

524
00:30:19,852 --> 00:30:25,527
und im Hintergrund haaben wir die beiden Stacks

525
00:30:25,527 --> 00:30:28,351
für die beiden Compiler. Einer für Red, der

526
00:30:28,351 --> 00:30:32,604
ist kleiner, weil er nur Code für Red/System erzeugt.

527
00:30:32,604 --> 00:30:34,311
Und einer für Red/System,

528
00:30:34,311 --> 00:30:36,720
der geht bis auf die Ebene des Packagers,

529
00:30:36,720 --> 00:30:41,424
kann also Maschinencode generieren und Binärdateien erzeugen.

530
00:30:41,424 --> 00:30:47,027
Das ganze ist die in Rebol 2 geschriebene Toolchain.

531
00:30:47,027 --> 00:30:52,304
Auf der linken Seiten haben Sie die Red-Runtime.

532
00:30:52,304 --> 00:30:55,586
Ein ziemlich umfängliches Stück Code,

533
00:30:55,586 --> 00:30:59,651
tatsächlich wohl größer als die andere Seite.

534
00:30:59,651 --> 00:31:02,964
Und zwar geschrieben in Red/System.

535
00:31:02,964 --> 00:31:06,914
So finden Sie die ganze effektive Mächtigkeit auf dieser Seite

536
00:31:06,914 --> 00:31:08,649
zum Beispiel alle Datentypen,

537
00:31:08,649 --> 00:31:12,104
alle Kernroutinen, den Code der Zwischenebenen,

538
00:31:12,104 --> 00:31:16,600
den Interpreter, die Kopplungen -- wie die nach Java,

539
00:31:16,600 --> 00:31:19,025
die bereits verfügbar ist.

540
00:31:19,025 --> 00:31:23,058
Die Speicherverwaltung und die maschinennahen

541
00:31:23,058 --> 00:31:26,485
Schnittstellen zu den tieferliegenden Teilen.

542
00:31:26,485 --> 00:31:28,829
So haben Sie zum Beispiel den direkten Zugriff

543
00:31:28,829 --> 00:31:31,993
auf das API des Betriebssystems, aber auch auf den Kernel.

544
00:31:31,993 --> 00:31:34,001
Unter Linnux können Sie Systemaufrufe direkt ausführen

545
00:31:34,001 --> 00:31:38,340
und falls nötig, können Sie sogar hinunter

546
00:31:38,340 --> 00:31:41,869
auf Hardware-Ebene gehen und ganz spezielle Features aufrufen.

547
00:31:44,599 --> 00:31:46,625
Vielleicht habe ich gerade die Red-Shell übersprungen,

548
00:31:46,625 --> 00:31:49,985
die auch in Red geschrieben ist,

549
00:31:49,985 --> 00:31:52,946
und in Red/System für die maschinennahen Teile.

550
00:31:53,816 --> 00:31:57,120
Zu Red/System... morgen halte ich einen kleinen

551
00:31:57,120 --> 00:32:01,142
Vortrag speziell über Red/System, denn darin

552
00:32:01,142 --> 00:32:06,082
unterscheidet sich Red in gewissem Sinne von Rebol.

553
00:32:06,082 --> 00:32:08,541
Deswegen habe ich nur eine Folie über Red/System,

554
00:32:08,541 --> 00:32:10,120
um Ihnen einen Überblick zu geben.

555
00:32:10,120 --> 00:32:16,748
Im wesentlichen ist das nur eine Art C,

556
00:32:16,748 --> 00:32:20,078
aber in der Syntax von Red.

557
00:32:20,078 --> 00:32:22,760
Daher fühlt man sich oft, als würde man Red

558
00:32:22,760 --> 00:32:29,827
schreiben, nur mit sehr elementaren Datentypen und Aktionen.

559
00:32:29,827 --> 00:32:32,630
Das wird statisch compiliert.

560
00:32:32,630 --> 00:32:35,956
Gegenwärtig wird es überhaupt nicht optimiert. :-)

561
00:32:35,956 --> 00:32:40,988
Trotzdem ist es nur 4x langsamer als mit

562
00:32:40,988 --> 00:32:43,849
"-O2" compiliertes C.

563
00:32:43,849 --> 00:32:47,674
Es ist also ganz gut, eigentlich sogar sehr gut.

564
00:32:47,674 --> 00:32:51,224
Denn sobald wir den Optimierer ergänzen,

565
00:32:51,224 --> 00:32:53,398
werden wir sehr nahe an C herankommen.

566
00:32:53,398 --> 00:32:57,362
Wir werden es wahrscheinlich nicht schlagen, das ist aber auch nicht das Ziel.

567
00:32:57,362 --> 00:33:00,014
Aber wir werden sehr, sehr nah dran sein.

568
00:33:00,014 --> 00:33:05,041
Red/System wird also zu einer durchaus praktikablen Alternative zu C.

569
00:33:05,041 --> 00:33:09,334
Und wirkt bereits Wunder

570
00:33:09,334 --> 00:33:11,936
bei bestimmten Arten der Bildverarbeitung,

571
00:33:11,936 --> 00:33:15,680
was Bo (Lechnowsky) Ihnen morgen zeigen wird.

572
00:33:15,680 --> 00:33:17,968
Noch etwas, über das C nicht verfügt bzw.

573
00:33:17,968 --> 00:33:22,310
die meisten maschinennahen Sprachen nicht verfügen:

574
00:33:22,310 --> 00:33:24,792
Red/System kennt Namensräume,

575
00:33:24,792 --> 00:33:27,024
vergleichbar mit Kontexten in Rebol, nur

576
00:33:27,024 --> 00:33:33,586
sehr statisch, daher deklarieren wir sie mit CONTEXT

577
00:33:33,586 --> 00:33:35,909
auch in Red/System. 

578
00:33:35,909 --> 00:33:38,936
Und mit dem Schlüsselwort WITH können Sie

579
00:33:38,936 --> 00:33:43,428
gewisse Teile Ihres Codes in einen Kontext stellen,

580
00:33:43,428 --> 00:33:47,121
ähnlich wie Deklaratioenn in anderen Sprachen.

581
00:33:47,121 --> 00:33:52,155
Wir haben in Red/System ein stark reduziertes Typsystem.

582
00:33:52,155 --> 00:34:00,763
Es gibt neun Typen.

583
00:34:00,763 --> 00:34:05,467
Im Prinzip die gleichen Datentypen wie C.

584
00:34:05,467 --> 00:34:11,372
Der Datentyp "Funktion" ist kein First-Class-Datentyp.

585
00:34:11,372 --> 00:34:16,155
Dagegen habe ich mich immer gesträubt, denn...

586
00:34:16,155 --> 00:34:19,723
wenn ich den zu einem First-Class-Datentyp mache,

587
00:34:19,723 --> 00:34:22,571
werden die Leute von mir verlangen,

588
00:34:22,571 --> 00:34:24,925
aus Red/System eine funktionale Sprache zu machen.

589
00:34:24,925 --> 00:34:27,986
Was möglich wäre, aber nicht das Ziel ist.

590
00:34:27,986 --> 00:34:32,540
Das erfüllt keinen Zweck, also bin ich ziemlich zögerlich,

591
00:34:32,540 --> 00:34:37,835
neue Features für diesen Datentyp zu ergänzen.

592
00:34:37,835 --> 00:34:40,324
Es gibt die Typ-Inferenz,

593
00:34:40,324 --> 00:34:42,395
und somit müssen Sie keinen Datentyp für 

594
00:34:42,395 --> 00:34:45,235
lokale Variablen anegben, Der Compiler ermittelt ihn selbständig.

595
00:34:45,235 --> 00:34:48,666
Wir haben auch in beschränktem Maße

596
00:34:48,666 --> 00:34:52,473
Casts zwischen kompatiblen Datentypen.

597
00:34:52,473 --> 00:34:56,548
Und wir haben etwas, das C nicht hat,

598
00:34:56,548 --> 00:35:04,017
dafür aber C++, nämlich ein gewisses Maß Reflection.

599
00:35:04,017 --> 00:35:07,445
Sie können also eine Funktion in Red/System

600
00:35:07,445 --> 00:35:12,157
mit einer variablen Zahl Parameter deklarieren,

601
00:35:12,157 --> 00:35:14,311
Sie können sie klammern

602
00:35:14,311 --> 00:35:16,341
und im Funktionsrumpf

603
00:35:16,341 --> 00:35:19,854
über diese Parameterliste iterieren

604
00:35:19,854 --> 00:35:23,665
und den Typ jedes einzelnen Parameters abfragen.

605
00:35:23,665 --> 00:35:26,778
Das ist ein ziemlich mächtiges Feature

606
00:35:26,778 --> 00:35:32,499
und Kaj de Vos hat es effektiv eingesetzt,

607
00:35:32,499 --> 00:35:36,773
um einen VID-ähnlichen Dialekt in Red/System zu bauen,

608
00:35:36,773 --> 00:35:38,853
eine beachtliche Leistung, denn 

609
00:35:38,853 --> 00:35:42,243
in Red/System gibt es keine Symbole :-)

610
00:35:42,243 --> 00:35:47,656
Das sieht also aus wie VID, nutzt aber besagtes Feature

611
00:35:47,656 --> 00:35:50,854
zur Ausführung und ist richtig großartig.

612
00:35:50,854 --> 00:35:55,630
Wir haben auch einen Präprozessor in Red/System,

613
00:35:55,630 --> 00:36:01,262
den würde ich mit dem nächsten großen Release aber gerne entsorgen,

614
00:36:01,262 --> 00:36:06,590
da wir uns mit ihm mehr Probleme einhandeln,

615
00:36:06,590 --> 00:36:11,779
als er uns Vorteile bringt.

616
00:36:11,779 --> 00:36:13,727
Ein paar davon werden wir behalten,

617
00:36:13,727 --> 00:36:16,774
müssen sie aber neu denken und überarbeiten.

618
00:36:16,774 --> 00:36:20,186
Das #define ist eine sehr mächtige Option,

619
00:36:20,186 --> 00:36:22,128
denn Sie gibt Ihnen fast die gleichen Möglichkeiten

620
00:36:22,128 --> 00:36:27,392
wie Makros in C, Sie können sogar Parameter angeben.

621
00:36:27,392 --> 00:36:34,001
Wir wollen auch einen gewissen Grad an CPU-Unterstützung

622
00:36:34,001 --> 00:36:39,385
momentan haben wir Zugriff auf einige CPU-Register

623
00:36:39,385 --> 00:36:41,747
in plattformübergreifender Form.

624
00:36:41,747 --> 00:36:43,617
Wir haben Zugriff auf den Stack --

625
00:36:43,617 --> 00:36:46,743
Sie können den nativen Stack auf Ebene von 

626
00:36:46,743 --> 00:36:49,724
Red/System in plattformübergreifender Manier manipulieren. 

627
00:36:49,724 --> 00:36:55,232
Dazu werden wir Support für interruptgesteuertes I/O

628
00:36:55,232 --> 00:37:02,004
und andere sehr grundlegende CPU-Features ergänzen.

629
00:37:02,004 --> 00:37:07,289
Vielleicht kommt eine Art Inline-Assembler,

630
00:37:07,289 --> 00:37:10,224
aber im Moment besteht daran kein großer Bedarf.

631
00:37:10,224 --> 00:37:13,926
Etwas Statistik zum Projekt "Red":

632
00:37:13,926 --> 00:37:18,596
Der größte Teil der Codebasis ist BSD.

633
00:37:18,596 --> 00:37:22,560
Und die Elemente der Runtime von Red sind "BSL",

634
00:37:22,560 --> 00:37:25,945
die "Boost Software License",

635
00:37:25,945 --> 00:37:32,015
die sogar noch großzügiger ist als BSD.

636
00:37:32,015 --> 00:37:34,999
Sie haben also weniger Beschränkungen als mit BSD.

637
00:37:34,999 --> 00:37:37,856
Wir sind von Anfang an auf GitHub,

638
00:37:37,856 --> 00:37:43,033
wir haben 9 Committer... das heißt falsch, ich glaube

639
00:37:43,033 --> 00:37:46,604
inzwischen sind es 11 Committer.

640
00:37:46,604 --> 00:37:50,335
Wir haben mehr als 2000 Commits,

641
00:37:50,335 --> 00:37:52,867
ohne Merge-Commits.

642
00:37:52,867 --> 00:37:58,035
Es gibt ca. 500 Tickets im Bug-Tracker,

643
00:37:58,035 --> 00:38:00,490
die sind aber fast alle geschlossen.

644
00:38:00,490 --> 00:38:03,576
Wir bemühen uns, die schnellstmöglich abzuarbeiten,

645
00:38:03,576 --> 00:38:05,852
damit sie nicht auflaufen.

646
00:38:05,852 --> 00:38:07,516
Denn sobald die einmal angefangen haben aufzulaufen,

647
00:38:07,516 --> 00:38:10,788
bekommt man sie fast nie mehr abgearbeitet.

648
00:38:10,788 --> 00:38:14,469
Also bemühen wir uns, ihre Zahl sehr, sehr niedrig zu halten.

649
00:38:14,469 --> 00:38:16,696
Wir haben viele Unit-Tests,

650
00:38:16,696 --> 00:38:19,569
erstellt von Peter Wood, der damit

651
00:38:19,569 --> 00:38:23,180
eine großartige Arbeit geleistet hat.

652
00:38:23,180 --> 00:38:25,361
Das ist außerordentlich hilfreich.

653
00:38:25,361 --> 00:38:27,897
Und hier haben Sie ein paar Daten

654
00:38:27,897 --> 00:38:30,019
über den Codeumfang

655
00:38:30,019 --> 00:38:32,026
für Red und Red/System.

656
00:38:32,026 --> 00:38:34,073
Für den Compiler und für den Linker.

657
00:38:34,073 --> 00:38:35,923
Sie sehen selbst,

658
00:38:35,923 --> 00:38:37,897
das ist eine wirklich kleine Codebasis.

659
00:38:37,897 --> 00:38:41,619
Man kann eine Menge erreichen, dank Rebol :-)

660
00:38:41,619 --> 00:38:45,444
Man kann eine Menge erreichen mit einer kleinen Codebasis

661
00:38:45,444 --> 00:38:47,680
und wenigen Zeilen Code.

662
00:38:47,680 --> 00:38:50,946
Sie können das mit anderen Toolchains vergleichen

663
00:38:50,946 --> 00:38:55,006
und Sie werden oft ein bis zwei

664
00:38:55,006 --> 00:38:57,700
Größenordnungen Unterschied feststellen.

665
00:38:57,700 --> 00:38:59,251
Natürlich decken die vermutlich

666
00:38:59,251 --> 00:39:01,428
mehr Bereiche ab als wir.

667
00:39:01,428 --> 00:39:06,544
Aber für so eine kleine Codebasis

668
00:39:06,544 --> 00:39:09,376
decken wir bereits einen gewaltigen Bereich ab. 

669
00:39:09,376 --> 00:39:14,352
Wir haben also noch viel Arbeit vor uns.

670
00:39:14,352 --> 00:39:18,824
Das ganze ist noch eine große Baustelle.

671
00:39:18,824 --> 00:39:23,389
Und uns fehlen immer noch ein paar große Kernkomponenten.

672
00:39:23,389 --> 00:39:30,653
Wir brauchen OOP-Support, den wir noch gar nicht haben.

673
00:39:30,653 --> 00:39:34,083
Es gibt noch keine richtiges Fehler-Handling,

674
00:39:34,083 --> 00:39:36,009
denn dafür brauchen wir OBJECT!

675
00:39:36,009 --> 00:39:40,244
Uns fehlt die Typprüfung für Parameter

676
00:39:40,244 --> 00:39:42,915
an manchen Stellen im Compiler.

677
00:39:42,915 --> 00:39:45,487
Wir haben noch kein I/O, aber ...

678
00:39:45,487 --> 00:39:50,941
natürlich stehen Objekte und I/O ganz oben auf der Liste.

679
00:39:50,941 --> 00:39:54,697
Wahrscheinlich werden sie diesen Sommer implementiert.

680
00:39:54,697 --> 00:39:59,696
Wir wollen einen gewissen Grad an Parallelität 

681
00:39:59,696 --> 00:40:05,334
im Release 1.0 und natürlich wollen wir auch

682
00:40:05,334 --> 00:40:09,829
getrenntes Compilieren und ein Modulsystem.

683
00:40:09,829 --> 00:40:14,260
Wir werden wahrscheinlich eine sehr rudimentäre IDE liefern,

684
00:40:14,260 --> 00:40:18,032
vermutlich nicht mehr als ein Code-Editor

685
00:40:18,032 --> 00:40:23,468
mit einem Debugger... und wir werden daran arbeten,

686
00:40:23,468 --> 00:40:27,570
sie in späteren Versionen zu erweitern.

687
00:40:27,570 --> 00:40:31,050
Wir wollen auch eine vollständige Dokumentation,

688
00:40:31,050 --> 00:40:37,597
ein großes Hindernis für das Release 1.0, 

689
00:40:37,597 --> 00:40:41,836
wir haben eine Menge zu tun, um diese Dokumentation

690
00:40:41,836 --> 00:40:43,650
zu schreiben und Tutorials zu erstellen.

691
00:40:43,650 --> 00:40:46,529
Und natürlich brauchen wir eine neue Website

692
00:40:46,529 --> 00:40:49,753
für den Start von Version 1.0.

693
00:40:51,613 --> 00:40:54,761
Aber das ist noch nicht alles ... :-)

694
00:40:54,761 --> 00:40:57,310
Das ist nicht das echte Red.

695
00:40:57,310 --> 00:41:00,523
Das echte Red wird die 2.0 sein.

696
00:41:00,523 --> 00:41:05,640
Und wir haben eine ganz schön gute Besetzung dafür (Gelächter)

697
00:41:05,640 --> 00:41:07,538
Was ist denn nun das "echte Red" ?

698
00:41:07,538 --> 00:41:11,329
Was ich bis jetzt vorgestellt habe,

699
00:41:11,329 --> 00:41:13,583
ist effektiv eine Art Skizzenblock.

700
00:41:13,583 --> 00:41:15,570
Denn das echte Red ist dieses hier.

701
00:41:15,570 --> 00:41:23,308
Das echte Red wird im Prinzip ein JIT-Compiler sein,

702
00:41:23,308 --> 00:41:27,206
der auch als statischer Compiler arbeiten kann.

703
00:41:27,206 --> 00:41:29,613
Die gesamte interne Architektur

704
00:41:29,613 --> 00:41:32,929
wird sich komplett von der aktuellen, in der 

705
00:41:32,929 --> 00:41:35,846
Bootstrap-Version implementierten, unterscheiden.

706
00:41:35,846 --> 00:41:39,254
Sie wird Plug-In-orientiert sein.

707
00:41:39,254 --> 00:41:40,910
Im wesentlichen werden der Compiler und die Toolchain

708
00:41:40,910 --> 00:41:44,718
eine leere Hülle sein -- ein Framework --,

709
00:41:44,718 --> 00:41:49,830
in das Sie Module werden einfügen können,

710
00:41:49,830 --> 00:41:54,223
um Features für jede Compilationsstufe nachzurüsten. 

711
00:41:54,223 --> 00:41:57,606
Vom Parsing bis zur Generierung der Dateien.

712
00:41:57,606 --> 00:42:00,981
Sie werden ein API bekommen, das Sie nutzen können.

713
00:42:00,981 --> 00:42:03,679
Ich werde also das Framework und den

714
00:42:03,679 --> 00:42:07,304
Grundstock an Modulen liefern, um die Features

715
00:42:07,304 --> 00:42:10,946
aus Version 1.0 zum Laufen zu bringen.

716
00:42:10,946 --> 00:42:15,920
Und dieses API wird natürlich dokumentiert sein,

717
00:42:15,920 --> 00:42:18,986
damit jeder in der Lage ist,

718
00:42:18,986 --> 00:42:22,012
den Compiler abzuändern und neue Features zu ergänzen, 

719
00:42:22,012 --> 00:42:25,657
auf eine sehr modulare und sehr strukturierte Art.

720
00:42:25,657 --> 00:42:29,935
Dieses API ließe sich auch zur Laufzeit aufrufen.

721
00:42:29,935 --> 00:42:34,584
Ich überlasse es Ihnen, sich die Optionen und Möglichkeiten

722
00:42:34,584 --> 00:42:37,270
vorzustellen, die eine Änderung des Compilers und 

723
00:42:37,270 --> 00:42:38,819
der Toolchain zur Laufzeit eröffnen.

724
00:42:38,819 --> 00:42:40,186
Zur Laufzeit kann man etwa 

725
00:42:40,186 --> 00:42:43,657
die Sprache selbst ändern oder um neue Feautures erweitern.

726
00:42:43,657 --> 00:42:47,107
Das mag völlig verrückt klingen,

727
00:42:47,107 --> 00:42:48,494
aber genau diesen Weg gehen andere Sprachen,

728
00:42:48,494 --> 00:42:53,525
die gerade Zulauf erfahren...

729
00:42:53,525 --> 00:42:56,184
Scala zum Beispiel

730
00:42:56,184 --> 00:42:57,921
macht ganau das.

731
00:42:57,921 --> 00:43:00,094
Und mancher aus der Scala-Community nutzt

732
00:43:00,094 --> 00:43:04,242
solche Features, um wahre Wunder in Scala zu vollbringen.

733
00:43:04,242 --> 00:43:07,042
Beispielsweise hat eine sehr smarte Person

734
00:43:07,042 --> 00:43:13,634
dieses API für die Parallelisierung von For-Schleifen

735
00:43:13,634 --> 00:43:18,648
genutzt, indem er die GPGPU zur Auslagerung einsetzt,

736
00:43:18,648 --> 00:43:23,715
mit OpenCL als Basis-Schicht.

737
00:43:23,715 --> 00:43:27,094
Das ist also ein sehr mächtiges Feature

738
00:43:27,094 --> 00:43:31,124
und macht auch die Compiler-Architektur 

739
00:43:31,124 --> 00:43:37,405
deutlich robuster und ermöglicht es Leuten,

740
00:43:37,405 --> 00:43:39,391
deutlich leichter 

741
00:43:39,391 --> 00:43:42,666
und in strukturierterer Weise beizutragen.

742
00:43:42,666 --> 00:43:45,410
Folgerichtig ist die aktuelle Codebasis

743
00:43:45,410 --> 00:43:50,145
des Compilers ... im Diagramm zu den Interna von Red 

744
00:43:50,145 --> 00:43:53,929
war es die rechte Seite der Blöcke ...

745
00:43:53,929 --> 00:43:56,942
Die aktuelle Codebasis in Rebol 2

746
00:43:56,942 --> 00:44:00,594
ist sozusagen Wegwerf-Code.

747
00:44:00,594 --> 00:44:04,283
Von Anfang an habe ich ihn also sehr schnell geschrieben,

748
00:44:04,283 --> 00:44:08,540
in der Annahme, daß ich ihn schnell entsorgen werde,

749
00:44:08,540 --> 00:44:10,412
innerhalb von ca. 1 Jahr,

750
00:44:10,412 --> 00:44:14,035
und ihn schnell in Red nachprogrammieren kann.

751
00:44:14,035 --> 00:44:18,069
Aber wir haben eine Menge Dinge im Projekt geändert,

752
00:44:18,069 --> 00:44:22,374
wir haben uns der Entwicklung des Umfelds angepaßt

753
00:44:22,374 --> 00:44:25,218
und sind deswegen noch nicht am Ziel.

754
00:44:25,218 --> 00:44:29,434
Also veröffentlichen wir zunächst 1.0 in der Bootstrap-Version,

755
00:44:29,434 --> 00:44:32,590
und 2.0 wird die eigenständige Version sein,

756
00:44:32,590 --> 00:44:35,173
mit der in Red reimplementierten Toolchain.

757
00:44:35,173 --> 00:44:41,975
Die gesamte Runtime von Red wird die gleiche bleiben.

758
00:44:41,975 --> 00:44:43,714
weil sie in Red/System programmiert sein wird,

759
00:44:43,714 --> 00:44:47,340
damit wird sie überleben, und das ist eine sehr große Codebasis.

760
00:44:47,340 --> 00:44:50,087
Einzig neu zu schreiben wird der in

761
00:44:50,087 --> 00:44:53,342
Rebol 2 gehaltene Teil sein, also

762
00:44:53,342 --> 00:44:56,511
im Prinzip die Compiler für Red und Red/System.

763
00:44:56,511 --> 00:44:59,654
Nur ein paar Worte zur Organisation des Projekts:

764
00:44:59,654 --> 00:45:05,659
Wir haben zwei Mitarbeiter auf GitHub,

765
00:45:05,659 --> 00:45:10,028
das heißt insgesamt ein Admin und zwei weitere Personen

766
00:45:10,028 --> 00:45:15,747
mit Admin-Rechten. Wenn ich vom Bus überfahren werde,

767
00:45:15,747 --> 00:45:21,832
könnten diese beiden den Quellcode 

768
00:45:21,832 --> 00:45:26,973
im Repository übernehmen und managen.

769
00:45:26,973 --> 00:45:30,940
Wir haben ca. 11 Personen, die von Anfang an zur

770
00:45:30,940 --> 00:45:33,673
Codebasis beigetragen haben. Wir haben eine Mailing-Liste.

771
00:45:33,673 --> 00:45:37,359
Es gibt eine Facebook-Seite, einen IRC-Channel

772
00:45:37,359 --> 00:45:42,087
mit einem netten IRC-Bot von Andreas,

773
00:45:42,087 --> 00:45:44,471
um Commits zu melden.

774
00:45:44,471 --> 00:45:46,792
Und natürlich suchen wir mehr Personen,

775
00:45:46,792 --> 00:45:49,389
die daran Interesse haben, zum Projekt

776
00:45:49,389 --> 00:45:52,707
beizutragen und in jedweder Form mitzuwirken,

777
00:45:52,707 --> 00:45:54,940
denn es ist ein ziemlich großes Projekt ...

778
00:45:54,940 --> 00:45:58,775
und wir brauhen eine Menge Unterstützung.

779
00:46:00,945 --> 00:46:03,564
Zu guter letzt :-)

780
00:46:03,564 --> 00:46:09,450
Ich habe in dieses Projekt ... seit ich vor

781
00:46:09,450 --> 00:46:12,146
ca. 2 1/2 Jahren damit angefangen habe

782
00:46:12,146 --> 00:46:16,020
jeden Cent an Ersparnissen investiert, den ich hatte. :-)

783
00:46:16,020 --> 00:46:20,434
Ich glaube also voll und ganz an dieses Projekt

784
00:46:20,434 --> 00:46:22,075
und an den Erfolg dieses Projekts.

785
00:46:22,075 --> 00:46:27,231
Aber mir geht das Geld bald aus :-)

786
00:46:27,231 --> 00:46:30,128
Seit einem Jahr lebe ich ausschließlich von Spenden,

787
00:46:30,128 --> 00:46:33,280
die mir Anwender und Unterstützer schicken.

788
00:46:33,280 --> 00:46:35,522
Dafür ein ganz großes Dankeschön,

789
00:46:35,522 --> 00:46:39,136
denn ohne sie wäre ich nicht hier

790
00:46:39,136 --> 00:46:41,448
und Red befände sich nicht auf diesem Stand
 
791
00:46:41,448 --> 00:46:42,987
bzw. würde es wahrschinlich gar nicht geben,

792
00:46:42,987 --> 00:46:45,865
würde mich niemand unterstützen.

793
00:46:45,865 --> 00:46:49,165
Also vielen Dank, und wir müssen weiter

794
00:46:49,165 --> 00:46:52,832
dranbleiben, um es wahr werden zu lassen.

795
00:46:52,832 --> 00:46:55,053
Vielen Dank für Ihre Aufmerksamkeit.

796
00:46:55,053 --> 00:46:59,053
(Applaus)
